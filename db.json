{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.e8862b.css","path":"main.e8862b.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.5b7e29.js","path":"slider.5b7e29.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.e9b30a.js","path":"mobile.e9b30a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.e8862b.js","path":"main.e8862b.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1504523708857},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1504523708829},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1504523708829},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1504523708858},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1504523708858},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1504523708857},{"_id":"themes/yilia/README.md","hash":"86757b00d393bd4956a252d92a469f11f2ae8914","modified":1504540845060},{"_id":"themes/yilia/_config.yml","hash":"93fbe367e81b9d48836268c49f9efb1c842758d4","modified":1504926555416},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1504523708921},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1504523708880},{"_id":"source/pageName/index.md","hash":"202fde2da1ca623a0908d4cb87165e21c45a997b","modified":1504523194861},{"_id":"source/_posts/ES6.md","hash":"53ca40806b4a4f373a55e2607534e8635614c367","modified":1505368981286},{"_id":"source/_posts/.ES6.md.swp","hash":"5fd9383f27492e305597e5f08dd3a7565cb57e15","modified":1505370431823},{"_id":"source/_posts/HTML-CSS.md","hash":"62706e3e449556ca560db3b76753055e698763c6","modified":1505052153102},{"_id":"source/_posts/Promise初探.md","hash":"216ea9082032593a00d53fa3a5f6c0bb0096ab2b","modified":1505116975021},{"_id":"source/_posts/Vue可复用性与组合.md","hash":"c6586943dd85a8e078b189e6b2a71c69b7448d72","modified":1506479952909},{"_id":"source/_posts/Vue-Nodejs搭建博客.md","hash":"99095165ed26a82bfb8c6dcce2deb74477d4c75d","modified":1506993402827},{"_id":"source/_posts/Vue-Router-基础.md","hash":"0659d633b1aa631071922c6ce499676725f9e454","modified":1506505162740},{"_id":"source/_posts/Vue组件.md","hash":"5399faff4e02bc4b7ba482bbcf59793a05464fb3","modified":1506327843581},{"_id":"source/_posts/Webpack配置初探.md","hash":"cb9262818578dd910016d69d85d0ff1df4712ed3","modified":1506327802893},{"_id":"source/_posts/Vue中使用Mixins.md","hash":"78418076b97e1eae330f030dadd33db7f536d685","modified":1506473749940},{"_id":"source/_posts/Vue-Router-进阶.md","hash":"30a740fb0554976161e57b3d49dfa30d90a81dbe","modified":1506512518431},{"_id":"source/_posts/Vue组件通信.md","hash":"626c1d7683839934105339d5715de5ee15c44431","modified":1506473849031},{"_id":"source/_posts/Web前端整理.md","hash":"c683bd2e865b41b91bd535c39870c663e731c037","modified":1506327586400},{"_id":"source/_posts/webpack使用过程.md","hash":"d6d363f4f76b46b285ea0c275928c9d33945dddb","modified":1506589858372},{"_id":"source/_posts/WebSocket学习.md","hash":"593f09169f9bfb6239a51397c4da4679424e29c8","modified":1505704791789},{"_id":"source/_posts/前端工程化初探.md","hash":"949c86e2a3f42732ba91604551603db615b7bbfb","modified":1507079933120},{"_id":"source/_posts/前端基本排序算法.md","hash":"fe430c4c852c0ba9609d4e7bcd8e64c21f632b76","modified":1504936720483},{"_id":"source/_posts/leetcode1-10.md","hash":"f5f721f761e110eb63d2bffcbdbd891cad751bc9","modified":1505048852646},{"_id":"source/_posts/在线便利贴项目记录.md","hash":"07e979f9ea642a57347288ebd75c793cefb91949","modified":1505695618692},{"_id":"source/_posts/前端单元测试初探.md","hash":"f265bcb9ab0f2dc2a5cb4a08d22801352c48ad88","modified":1506474229721},{"_id":"source/_posts/预加载.md","hash":"bdf0d559cdc15cad9e77e0f5b6c92455141bc97c","modified":1504941268064},{"_id":"source/_posts/callee和caller用法和区别.md","hash":"c1eb4d0b6507172de36f6d0cebb988ad371cbce3","modified":1505013913421},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"8bf6d6fafdc70d49ab5e6a2856dbd79e3dced638","modified":1504523789029},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1504523708881},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1504523395444},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"45110d6b5126974abe03d21f2c19016cc4e3d1b6","modified":1504523789256},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1504523708815},{"_id":"themes/yilia/.git/config","hash":"24300cece9d72967ea63724bdb2a8e3c2ac2cc52","modified":1504523708819},{"_id":"source/_posts/性能优化.md","hash":"0749b325c09591caa750b413a446997ad38ab7c5","modified":1506327564363},{"_id":"source/_posts/浏览器兼容性问题总结.md","hash":"a8e5868fa463f328c0d3d859802ac09419ab8190","modified":1506474603455},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1504523708910},{"_id":"themes/yilia/.git/packed-refs","hash":"9ecf4d9ae339937dfc68d55f0d2b3ee898b60c7b","modified":1504523708812},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1504523708859},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1504523708860},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1504523708861},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1504523708862},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1504523708861},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1504523708860},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1504523708878},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1504523708863},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1504523708878},{"_id":"themes/yilia/.git/index","hash":"66eb38e374c4c17c4563264b43d72c18bf8d71be","modified":1504523708922},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1504523708877},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1504523708879},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1504523708879},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1504523708880},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1504523708878},{"_id":"themes/yilia/source/main.e8862b.css","hash":"6b9cfabb81f021081a93da5a069674e9be910194","modified":1504523708916},{"_id":"themes/yilia/source/slider.5b7e29.js","hash":"1a621ae5d7667a9b944456c2f7156880abfeab44","modified":1504523708921},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1504523708876},{"_id":"themes/yilia/.git/logs/HEAD","hash":"ebc6e673ebc83766dfb7f72a0bd8bb1b87e6f9c8","modified":1504523708817},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1504523708905},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1504523708905},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9c9f5e38cefcb2196543dce7fa585152238833e7","modified":1504523708906},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1504523708906},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1504523708907},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1504523708908},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1504523708908},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1504523708909},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1504523708906},{"_id":"themes/yilia/source-src/js/slider.js","hash":"707842efee006e3ea9b6765d7460f4ef4f08e41f","modified":1504523708909},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1504523708909},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1504523395483},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"3e0fd4479a40ddbd1571c6c953df7e23637b61f5","modified":1504523708910},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1504523395444},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1504523395472},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1504523395475},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1504523395474},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1504523395476},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1504523395473},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1504523395482},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1504523395481},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1504523708882},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1504523395480},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1504523708882},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"2d1c70bb606c0d87e4f68ec2e600e08b27f32b99","modified":1504523708886},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1504523708883},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1504523708884},{"_id":"themes/yilia/source/mobile.e9b30a.js","hash":"a0bc3e45b7c1c9edf07d22559d3a3dec3cfbe7df","modified":1504523708920},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1504523708886},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1504523708883},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1504523708890},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1504523708895},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1504523708886},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1504523708897},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1504523708895},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1504523708898},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1504523708897},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1504523708898},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1504523708897},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1504523708899},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1504523708900},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1504523708900},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1504523708899},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1504523708901},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1504523708894},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1504523708902},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1504523708914},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1504523708885},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"6932c642bf8191768d7090982a91c8c1f1c4ed1e","modified":1504523708902},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1504523708915},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1504523708894},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1504523708913},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1504523708911},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1504523708903},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1504523708912},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1504523708913},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1504523708914},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1504523708914},{"_id":"themes/yilia/source/main.e8862b.js","hash":"c7580aa534bd0b9500b7111b1de50c91b1a2e4ea","modified":1504523708917},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1504523708912},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1504523708864},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1504523708864},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1504523708864},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1504523708866},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1504523708866},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"b8c1da5565479c81d7f7aa93c6d0d0acda93fd76","modified":1504523708866},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1504523708868},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1504523708867},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1504523708865},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"dff6e1f3b5e82495ec776baa24d9e6bbaad883df","modified":1504523708865},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1504523708867},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"e2b3f2b3631ef211a4d98d11f0da2d285340f10e","modified":1504523708868},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1504523708868},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1504523708866},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1504523708877},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1504523708876},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"a6880c459e798c74c49a99d76ab92307d765ec9f","modified":1504523708875},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1504523708891},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1504523708896},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1504523708896},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1504523708896},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1504523708893},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1504523708894},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1504523708892},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1504523708888},{"_id":"themes/yilia/.git/refs/heads/master","hash":"45110d6b5126974abe03d21f2c19016cc4e3d1b6","modified":1504523708816},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1504523708889},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1504523708887},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1504523708889},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"f75b236818b6c0ec0e5e6c12a517825d6230d756","modified":1504523708869},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1504523708888},{"_id":"themes/yilia/.git/objects/pack/pack-2c4e5ba8327f4759711af57c2dc5064717ae5803.idx","hash":"9595f7c55c41ab8359c595809b7c6092428ac14d","modified":1504523708076},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"cc384aeaed9ffde92efdf192c26db4da3fe5858f","modified":1504523708870},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1504523708870},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1504523708871},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1504523708871},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"06a2dd18ac9a43fbc9a59c61e6f795f9326e9927","modified":1504523708872},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1504523708874},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1504523708873},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1504523708874},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"ebc6e673ebc83766dfb7f72a0bd8bb1b87e6f9c8","modified":1504523708817},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1504523708813},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"ebc6e673ebc83766dfb7f72a0bd8bb1b87e6f9c8","modified":1504523708815},{"_id":"themes/yilia/.git/objects/pack/pack-2c4e5ba8327f4759711af57c2dc5064717ae5803.pack","hash":"19cfbdab6ea83f2567fd9bc12eb1eb781a3f87a1","modified":1504523708360},{"_id":"public/content.json","hash":"4c1f6a8e4e3aa20512c455f316758e8fa819e0bd","modified":1507434292393},{"_id":"public/pageName/index.html","hash":"ffb3c75d0dcee221f3e6da7f2a09945560420af9","modified":1507434292643},{"_id":"public/2017/10/04/前端工程化初探/index.html","hash":"91d35fcf7912f852036c203197b9f56fefa6024d","modified":1507434293793},{"_id":"public/2017/10/01/Vue-Nodejs搭建博客/index.html","hash":"7c6535ec70ce212da251fffa650d0b0f7725f8b8","modified":1507434294161},{"_id":"public/2017/09/27/Vue-Router-基础/index.html","hash":"ff0e5b5cef06286233d0840203a79f4ddc31f7dc","modified":1507434294209},{"_id":"public/2017/09/27/Vue可复用性与组合/index.html","hash":"a1259b53678b3283c33a8f112b4f15570f894751","modified":1507434294209},{"_id":"public/2017/09/27/Vue-Router-进阶/index.html","hash":"7df0dd1e412e0dd281d7aabbc97898d28e20c40e","modified":1507434294209},{"_id":"public/2017/09/26/Vue中使用Mixins/index.html","hash":"67312ddfb3dd4bbfb910dac3cf8f571fe9dcef0a","modified":1507434294209},{"_id":"public/2017/09/21/浏览器兼容性问题总结/index.html","hash":"fccc83afa700b98caceba64167acb36f7cf33134","modified":1507434294210},{"_id":"public/2017/09/25/Vue组件通信/index.html","hash":"357b9ca07cb6794f3338b2ec5f5e902443c27f5c","modified":1507434294210},{"_id":"public/2017/09/25/Webpack配置初探/index.html","hash":"65797e9d97f964a879cc34a3e630de00d6720938","modified":1507434294210},{"_id":"public/2017/09/25/Vue组件/index.html","hash":"81ad19212290ba2cbff517fdd7ff6e5b7bf79ea4","modified":1507434294210},{"_id":"public/2017/09/18/WebSocket学习/index.html","hash":"3e9373afcf53c66470626343d917e42734e3b7e2","modified":1507434294210},{"_id":"public/2017/09/16/在线便利贴项目记录/index.html","hash":"f5bb047e4076a7429da5ab90697a1d9b44e77cfe","modified":1507434294211},{"_id":"public/2017/09/14/ES6/index.html","hash":"1a430f22d700f503fc34e9754e171976dbfb8e5d","modified":1507434294211},{"_id":"public/2017/09/11/前端单元测试初探/index.html","hash":"13a9f6cd261588c23962574d9d26d43b7d5c98a3","modified":1507434294211},{"_id":"public/2017/09/11/Promise初探/index.html","hash":"24ca2509c353def1ab857a73ab4731a4c83fb8d5","modified":1507434294211},{"_id":"public/2017/09/10/callee和caller用法和区别/index.html","hash":"6efae33b47d026f64b362429e35992c624611078","modified":1507434294212},{"_id":"public/2017/09/28/webpack使用过程/index.html","hash":"d50837b5d8d3c734615354ed80dbe1c01452325c","modified":1507434294326},{"_id":"public/2017/09/10/leetcode1-10/index.html","hash":"331b2d69fb2133c95293ab20856e474f68d2af42","modified":1507434294401},{"_id":"public/2017/09/09/性能优化/index.html","hash":"ca85eaec928d70b607b7f56ba6f43ea6b1722327","modified":1507434294411},{"_id":"public/2017/09/09/前端基本排序算法/index.html","hash":"57c80d7f49ff1c791f1049929a09ef3c71f2f6b1","modified":1507434294412},{"_id":"public/2017/09/09/预加载/index.html","hash":"da927188c982bcbc2cff564a63da80b0b16b6498","modified":1507434294412},{"_id":"public/2017/09/09/HTML-CSS/index.html","hash":"87a3b810ee5005717ff76321c98f3cbd5eb6bb79","modified":1507434294412},{"_id":"public/archives/index.html","hash":"5f7f0c27b8ded9ce4986dbeb6bfe15930617d175","modified":1507434294412},{"_id":"public/2017/09/06/Web前端整理/index.html","hash":"e7404a0b81282523aae3d205c7e9c88ebacd471e","modified":1507434294412},{"_id":"public/archives/2017/index.html","hash":"7adc0bb8ef1b74f9a595bf5c0cafb82886fddaf5","modified":1507434294413},{"_id":"public/archives/page/2/index.html","hash":"6fc80d26c1eb28e6888c6bd1cbed68cb417e5ea0","modified":1507434294413},{"_id":"public/archives/2017/09/index.html","hash":"898c799424d789c9b92985d45f3edb1065f12471","modified":1507434294413},{"_id":"public/archives/2017/09/page/2/index.html","hash":"bb5c3cc494c16f98a39c400ee99069bd580f5c5f","modified":1507434294413},{"_id":"public/index.html","hash":"7e1f694e263bdef719eff5f45671583d07edf728","modified":1507434294413},{"_id":"public/categories/Web/index.html","hash":"149ea2a9b7997f25ebe3aa5cbc171b7b584a7ef0","modified":1507434294413},{"_id":"public/archives/2017/page/2/index.html","hash":"d2ea4d2f973514c65db8b449541f1e2a8047e774","modified":1507434294414},{"_id":"public/page/2/index.html","hash":"981ca683817426a237f155561ff35c7e426ed73f","modified":1507434294414},{"_id":"public/tags/面试相关/index.html","hash":"1615a4ea5345bf007cd1bf3b8ad75d1bf8768b82","modified":1507434294414},{"_id":"public/tags/Vue-Router/index.html","hash":"ebac794832b0ae5d0b4847341185d819d88040bd","modified":1507434294414},{"_id":"public/tags/Javascript/index.html","hash":"ae230aeaa708e8b508acf7a5e6e6e5a4454115a4","modified":1507434294414},{"_id":"public/tags/Vue/index.html","hash":"073e2f6fa7a9dff5cac4820f5f0c4a47baa1b409","modified":1507434294415},{"_id":"public/tags/WEB/index.html","hash":"8b543f4b277b92044b6b594991b482f55c748afb","modified":1507434294415},{"_id":"public/tags/个人项目/index.html","hash":"e543f99de3a6c1430b2ca846885740dce1edbe5a","modified":1507434294415},{"_id":"public/tags/性能优化/index.html","hash":"57f53ac0cbbd5ddfa50f609f2ec1b9076dfc590c","modified":1507434294416},{"_id":"public/tags/算法/index.html","hash":"c8cfbd89f5df08eabe733eae6eab3543d1404bcf","modified":1507434294417},{"_id":"public/tags/leetcode/index.html","hash":"e227aea3c78126bac86cb71705dd4d11a5510d61","modified":1507434294418},{"_id":"public/archives/page/3/index.html","hash":"c0987adc7646d12797aefc4c160b0025fe953734","modified":1507434294424},{"_id":"public/archives/2017/page/3/index.html","hash":"7dc7e5db9d85cfa655980debc47a8b5ae5aaf3d7","modified":1507434294424},{"_id":"public/archives/2017/10/index.html","hash":"dea4aa71ef8686df75979044fa28b0e0f995c2bd","modified":1507434294425},{"_id":"public/archives/2017/09/page/3/index.html","hash":"e5b74c0d49c96c99be6677834cab5dfb077924cb","modified":1507434294425},{"_id":"public/page/3/index.html","hash":"d1350fd0104cef8a4fbcde6e076a9d33e15f9319","modified":1507434294425},{"_id":"public/tags/Webpack/index.html","hash":"8669d72130985e4deaebc7705fb82594f6784176","modified":1507434294425},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1507434294426},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1507434294426},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1507434294426},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1507434294427},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1507434294427},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1507434294427},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1507434294427},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1507434294427},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1507434294427},{"_id":"public/mobile.e9b30a.js","hash":"7d4d52617d8037dbb58d86e5265a6c8c52b412fb","modified":1507434294433},{"_id":"public/slider.5b7e29.js","hash":"1e871f6ec4512738081bf9a63ff7519d7659cfed","modified":1507434294433},{"_id":"public/main.e8862b.css","hash":"6b9cfabb81f021081a93da5a069674e9be910194","modified":1507434294433},{"_id":"public/main.e8862b.js","hash":"310ce86b4eef869f8ab1289814861ef3c45ff3a4","modified":1507434294433}],"Category":[{"name":"Web","_id":"cj8i7getn000tekri7by6i8oh"}],"Data":[],"Page":[{"title":"pageName","date":"2017-09-04T11:06:34.000Z","_content":"","source":"pageName/index.md","raw":"---\ntitle: pageName\ndate: 2017-09-04 19:06:34\n---\n","updated":"2017-09-04T11:06:34.861Z","path":"pageName/index.html","comments":1,"layout":"page","_id":"cj8i7geqq0000ekri3kllyf6h","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES6","date":"2017-09-14T06:03:01.000Z","_content":"","source":"_posts/ES6.md","raw":"---\ntitle: ES6\ndate: 2017-09-14 14:03:01\ncategories:\ntags:\n---\n","slug":"ES6","published":1,"updated":"2017-09-14T06:03:01.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gequ0001ekrisqmdc3ol","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"HTML&CSS","date":"2017-09-09T07:15:22.000Z","_content":"\n## HTML 语义化\n语义化的含义就是：**让正确的标签做正确的事**\n**为什么要语义化？**\n- 在CSS丢失或没有CSS时，页面仍然能够呈现较为清晰的结构\n- 有利于SEO，有助于爬虫抓取抓取更多有效信息，因为搜索引擎的爬虫也要依赖标签来确定上下文和各个关键字的权重\n- 方便其他设备的解析。向PAD、手机等设备对CSS的解析没有电脑那么强\n- 便于团队开发和维护\n\n## html5 新增了哪些新特性\n- 新的结构化标签，如：header、section、article、footer、nav等更加语义化的标签\n- 音视频标签：audio和video\n- 动画的支持：canvas\n- 新的表单控件：calendar、date、time、email、url\n- 离线存储：localStorage、sessionStorage\n- 新的跨域通信机制：window.postMessage\n\n## 为什么利用多个域名来存储网站资源会更有效\n- CDN 缓存更方便\n- 突破浏览器的并发限制\n- 节约主域名的连接数，优化页面响应\n- 节约cookie带宽\n\n\n## CSS 相关\n### CSS都有哪些选择器？\n- 基本选择器\n  - 元素选择器\n  - id选择器\n  - class选择器\n  - 一些关系选择器，例如：>(直接子元素), +(相邻兄弟选择器)，\n- 属性选择器\n  例如：`E[attr], E[attr*=\"value\"], E[attr^=\"value\"], E[attr$=\"value\"]`\n- 伪类选择器\n  例如：`':first-child', ':last-child'`\n- 伪元素选择器\n  例如：`'::before', '::after', '::first-letter'`\n\n**伪类和伪元素的区别**\n其主要区别是：*有没有从创建一个文档树之外的元素*，如果创造了新的元素，则是伪元素，如果没有，则是伪类\n例如：`:first-child`：其选择的是第一个子元素，说明没有创造新的元素，所以它是伪类，\n`::before`：在元素的前面添加一个新元素，它创建了新的元素，所以是伪元素 \n参考：[伪元素和伪类](http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/)\n\n###通过哪些CSS属性可以使一个元素不出现在浏览器可视范围内\n基本方法：\n- `display: none`\n- `visibility: hidden`\n技巧性的：\n- 设置宽高为0\n- 设置透明度为0：opacity\n- 设置`z-index: -1000em`，其实就是设置元素的层级关系为超级低\n\n###超链接访问过后hover样式就不出现的问题是什么？如何解决？\n主要是对a链接的伪元素属性没有设置好，设置顺序为：*link，visited，hover，active*\n\n### 什么是Css Hack？ie6,7,8的hack分别是什么？\nCSS Hack就是：**针对不同的浏览器编写不同的CSS**\n\n最简单的区分ie6、ie7、ie8的CSS Hack，如下所示：\n```\n.color {\n    background-color: #CC00FF;       // 所有浏览器都能识别\n    background-color: #FF0000\\9;     // 只有IE6、 IE7、IE8能识别\n    *background-color: #0066FF;      // IE6、IE7能识别\n    +background-color: pink;         // 只有IE7能识别\n    _background-color: #009933;      // 只有IE6能识别\n}\n```\n\n\n## DIV + CSS 布局 与 table布局的优缺点\ndiv + css 布局的优点\n- 符合W3C标准，结构、行为和样式的分离\n- 结构清晰，便于扩展\n- 有利于搜索引擎检索，利于SEO\n\n参考：[为什么不使用table布局](https://stackoverflow.com/questions/83073/why-not-use-tables-for-layout-in-html)\n","source":"_posts/HTML-CSS.md","raw":"---\ntitle: HTML&CSS\ndate: 2017-09-09 15:15:22\ncategories:\ntags: 面试相关\n---\n\n## HTML 语义化\n语义化的含义就是：**让正确的标签做正确的事**\n**为什么要语义化？**\n- 在CSS丢失或没有CSS时，页面仍然能够呈现较为清晰的结构\n- 有利于SEO，有助于爬虫抓取抓取更多有效信息，因为搜索引擎的爬虫也要依赖标签来确定上下文和各个关键字的权重\n- 方便其他设备的解析。向PAD、手机等设备对CSS的解析没有电脑那么强\n- 便于团队开发和维护\n\n## html5 新增了哪些新特性\n- 新的结构化标签，如：header、section、article、footer、nav等更加语义化的标签\n- 音视频标签：audio和video\n- 动画的支持：canvas\n- 新的表单控件：calendar、date、time、email、url\n- 离线存储：localStorage、sessionStorage\n- 新的跨域通信机制：window.postMessage\n\n## 为什么利用多个域名来存储网站资源会更有效\n- CDN 缓存更方便\n- 突破浏览器的并发限制\n- 节约主域名的连接数，优化页面响应\n- 节约cookie带宽\n\n\n## CSS 相关\n### CSS都有哪些选择器？\n- 基本选择器\n  - 元素选择器\n  - id选择器\n  - class选择器\n  - 一些关系选择器，例如：>(直接子元素), +(相邻兄弟选择器)，\n- 属性选择器\n  例如：`E[attr], E[attr*=\"value\"], E[attr^=\"value\"], E[attr$=\"value\"]`\n- 伪类选择器\n  例如：`':first-child', ':last-child'`\n- 伪元素选择器\n  例如：`'::before', '::after', '::first-letter'`\n\n**伪类和伪元素的区别**\n其主要区别是：*有没有从创建一个文档树之外的元素*，如果创造了新的元素，则是伪元素，如果没有，则是伪类\n例如：`:first-child`：其选择的是第一个子元素，说明没有创造新的元素，所以它是伪类，\n`::before`：在元素的前面添加一个新元素，它创建了新的元素，所以是伪元素 \n参考：[伪元素和伪类](http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/)\n\n###通过哪些CSS属性可以使一个元素不出现在浏览器可视范围内\n基本方法：\n- `display: none`\n- `visibility: hidden`\n技巧性的：\n- 设置宽高为0\n- 设置透明度为0：opacity\n- 设置`z-index: -1000em`，其实就是设置元素的层级关系为超级低\n\n###超链接访问过后hover样式就不出现的问题是什么？如何解决？\n主要是对a链接的伪元素属性没有设置好，设置顺序为：*link，visited，hover，active*\n\n### 什么是Css Hack？ie6,7,8的hack分别是什么？\nCSS Hack就是：**针对不同的浏览器编写不同的CSS**\n\n最简单的区分ie6、ie7、ie8的CSS Hack，如下所示：\n```\n.color {\n    background-color: #CC00FF;       // 所有浏览器都能识别\n    background-color: #FF0000\\9;     // 只有IE6、 IE7、IE8能识别\n    *background-color: #0066FF;      // IE6、IE7能识别\n    +background-color: pink;         // 只有IE7能识别\n    _background-color: #009933;      // 只有IE6能识别\n}\n```\n\n\n## DIV + CSS 布局 与 table布局的优缺点\ndiv + css 布局的优点\n- 符合W3C标准，结构、行为和样式的分离\n- 结构清晰，便于扩展\n- 有利于搜索引擎检索，利于SEO\n\n参考：[为什么不使用table布局](https://stackoverflow.com/questions/83073/why-not-use-tables-for-layout-in-html)\n","slug":"HTML-CSS","published":1,"updated":"2017-09-10T14:02:33.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gerx0002ekriff2nth2v","content":"<h2 id=\"HTML-语义化\"><a href=\"#HTML-语义化\" class=\"headerlink\" title=\"HTML 语义化\"></a>HTML 语义化</h2><p>语义化的含义就是：<strong>让正确的标签做正确的事</strong><br><strong>为什么要语义化？</strong></p>\n<ul>\n<li>在CSS丢失或没有CSS时，页面仍然能够呈现较为清晰的结构</li>\n<li>有利于SEO，有助于爬虫抓取抓取更多有效信息，因为搜索引擎的爬虫也要依赖标签来确定上下文和各个关键字的权重</li>\n<li>方便其他设备的解析。向PAD、手机等设备对CSS的解析没有电脑那么强</li>\n<li>便于团队开发和维护</li>\n</ul>\n<h2 id=\"html5-新增了哪些新特性\"><a href=\"#html5-新增了哪些新特性\" class=\"headerlink\" title=\"html5 新增了哪些新特性\"></a>html5 新增了哪些新特性</h2><ul>\n<li>新的结构化标签，如：header、section、article、footer、nav等更加语义化的标签</li>\n<li>音视频标签：audio和video</li>\n<li>动画的支持：canvas</li>\n<li>新的表单控件：calendar、date、time、email、url</li>\n<li>离线存储：localStorage、sessionStorage</li>\n<li>新的跨域通信机制：window.postMessage</li>\n</ul>\n<h2 id=\"为什么利用多个域名来存储网站资源会更有效\"><a href=\"#为什么利用多个域名来存储网站资源会更有效\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源会更有效\"></a>为什么利用多个域名来存储网站资源会更有效</h2><ul>\n<li>CDN 缓存更方便</li>\n<li>突破浏览器的并发限制</li>\n<li>节约主域名的连接数，优化页面响应</li>\n<li>节约cookie带宽</li>\n</ul>\n<h2 id=\"CSS-相关\"><a href=\"#CSS-相关\" class=\"headerlink\" title=\"CSS 相关\"></a>CSS 相关</h2><h3 id=\"CSS都有哪些选择器？\"><a href=\"#CSS都有哪些选择器？\" class=\"headerlink\" title=\"CSS都有哪些选择器？\"></a>CSS都有哪些选择器？</h3><ul>\n<li>基本选择器<ul>\n<li>元素选择器</li>\n<li>id选择器</li>\n<li>class选择器</li>\n<li>一些关系选择器，例如：&gt;(直接子元素), +(相邻兄弟选择器)，</li>\n</ul>\n</li>\n<li>属性选择器<br>例如：<code>E[attr], E[attr*=&quot;value&quot;], E[attr^=&quot;value&quot;], E[attr$=&quot;value&quot;]</code></li>\n<li>伪类选择器<br>例如：<code>&#39;:first-child&#39;, &#39;:last-child&#39;</code></li>\n<li>伪元素选择器<br>例如：<code>&#39;::before&#39;, &#39;::after&#39;, &#39;::first-letter&#39;</code></li>\n</ul>\n<p><strong>伪类和伪元素的区别</strong><br>其主要区别是：<em>有没有从创建一个文档树之外的元素</em>，如果创造了新的元素，则是伪元素，如果没有，则是伪类<br>例如：<code>:first-child</code>：其选择的是第一个子元素，说明没有创造新的元素，所以它是伪类，<br><code>::before</code>：在元素的前面添加一个新元素，它创建了新的元素，所以是伪元素<br>参考：<a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/\" target=\"_blank\" rel=\"external\">伪元素和伪类</a></p>\n<p>###通过哪些CSS属性可以使一个元素不出现在浏览器可视范围内<br>基本方法：</p>\n<ul>\n<li><code>display: none</code></li>\n<li><code>visibility: hidden</code><br>技巧性的：</li>\n<li>设置宽高为0</li>\n<li>设置透明度为0：opacity</li>\n<li>设置<code>z-index: -1000em</code>，其实就是设置元素的层级关系为超级低</li>\n</ul>\n<p>###超链接访问过后hover样式就不出现的问题是什么？如何解决？<br>主要是对a链接的伪元素属性没有设置好，设置顺序为：<em>link，visited，hover，active</em></p>\n<h3 id=\"什么是Css-Hack？ie6-7-8的hack分别是什么？\"><a href=\"#什么是Css-Hack？ie6-7-8的hack分别是什么？\" class=\"headerlink\" title=\"什么是Css Hack？ie6,7,8的hack分别是什么？\"></a>什么是Css Hack？ie6,7,8的hack分别是什么？</h3><p>CSS Hack就是：<strong>针对不同的浏览器编写不同的CSS</strong></p>\n<p>最简单的区分ie6、ie7、ie8的CSS Hack，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.color &#123;</div><div class=\"line\">    background-color: #CC00FF;       // 所有浏览器都能识别</div><div class=\"line\">    background-color: #FF0000\\9;     // 只有IE6、 IE7、IE8能识别</div><div class=\"line\">    *background-color: #0066FF;      // IE6、IE7能识别</div><div class=\"line\">    +background-color: pink;         // 只有IE7能识别</div><div class=\"line\">    _background-color: #009933;      // 只有IE6能识别</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"DIV-CSS-布局-与-table布局的优缺点\"><a href=\"#DIV-CSS-布局-与-table布局的优缺点\" class=\"headerlink\" title=\"DIV + CSS 布局 与 table布局的优缺点\"></a>DIV + CSS 布局 与 table布局的优缺点</h2><p>div + css 布局的优点</p>\n<ul>\n<li>符合W3C标准，结构、行为和样式的分离</li>\n<li>结构清晰，便于扩展</li>\n<li>有利于搜索引擎检索，利于SEO</li>\n</ul>\n<p>参考：<a href=\"https://stackoverflow.com/questions/83073/why-not-use-tables-for-layout-in-html\" target=\"_blank\" rel=\"external\">为什么不使用table布局</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTML-语义化\"><a href=\"#HTML-语义化\" class=\"headerlink\" title=\"HTML 语义化\"></a>HTML 语义化</h2><p>语义化的含义就是：<strong>让正确的标签做正确的事</strong><br><strong>为什么要语义化？</strong></p>\n<ul>\n<li>在CSS丢失或没有CSS时，页面仍然能够呈现较为清晰的结构</li>\n<li>有利于SEO，有助于爬虫抓取抓取更多有效信息，因为搜索引擎的爬虫也要依赖标签来确定上下文和各个关键字的权重</li>\n<li>方便其他设备的解析。向PAD、手机等设备对CSS的解析没有电脑那么强</li>\n<li>便于团队开发和维护</li>\n</ul>\n<h2 id=\"html5-新增了哪些新特性\"><a href=\"#html5-新增了哪些新特性\" class=\"headerlink\" title=\"html5 新增了哪些新特性\"></a>html5 新增了哪些新特性</h2><ul>\n<li>新的结构化标签，如：header、section、article、footer、nav等更加语义化的标签</li>\n<li>音视频标签：audio和video</li>\n<li>动画的支持：canvas</li>\n<li>新的表单控件：calendar、date、time、email、url</li>\n<li>离线存储：localStorage、sessionStorage</li>\n<li>新的跨域通信机制：window.postMessage</li>\n</ul>\n<h2 id=\"为什么利用多个域名来存储网站资源会更有效\"><a href=\"#为什么利用多个域名来存储网站资源会更有效\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源会更有效\"></a>为什么利用多个域名来存储网站资源会更有效</h2><ul>\n<li>CDN 缓存更方便</li>\n<li>突破浏览器的并发限制</li>\n<li>节约主域名的连接数，优化页面响应</li>\n<li>节约cookie带宽</li>\n</ul>\n<h2 id=\"CSS-相关\"><a href=\"#CSS-相关\" class=\"headerlink\" title=\"CSS 相关\"></a>CSS 相关</h2><h3 id=\"CSS都有哪些选择器？\"><a href=\"#CSS都有哪些选择器？\" class=\"headerlink\" title=\"CSS都有哪些选择器？\"></a>CSS都有哪些选择器？</h3><ul>\n<li>基本选择器<ul>\n<li>元素选择器</li>\n<li>id选择器</li>\n<li>class选择器</li>\n<li>一些关系选择器，例如：&gt;(直接子元素), +(相邻兄弟选择器)，</li>\n</ul>\n</li>\n<li>属性选择器<br>例如：<code>E[attr], E[attr*=&quot;value&quot;], E[attr^=&quot;value&quot;], E[attr$=&quot;value&quot;]</code></li>\n<li>伪类选择器<br>例如：<code>&#39;:first-child&#39;, &#39;:last-child&#39;</code></li>\n<li>伪元素选择器<br>例如：<code>&#39;::before&#39;, &#39;::after&#39;, &#39;::first-letter&#39;</code></li>\n</ul>\n<p><strong>伪类和伪元素的区别</strong><br>其主要区别是：<em>有没有从创建一个文档树之外的元素</em>，如果创造了新的元素，则是伪元素，如果没有，则是伪类<br>例如：<code>:first-child</code>：其选择的是第一个子元素，说明没有创造新的元素，所以它是伪类，<br><code>::before</code>：在元素的前面添加一个新元素，它创建了新的元素，所以是伪元素<br>参考：<a href=\"http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/\" target=\"_blank\" rel=\"external\">伪元素和伪类</a></p>\n<p>###通过哪些CSS属性可以使一个元素不出现在浏览器可视范围内<br>基本方法：</p>\n<ul>\n<li><code>display: none</code></li>\n<li><code>visibility: hidden</code><br>技巧性的：</li>\n<li>设置宽高为0</li>\n<li>设置透明度为0：opacity</li>\n<li>设置<code>z-index: -1000em</code>，其实就是设置元素的层级关系为超级低</li>\n</ul>\n<p>###超链接访问过后hover样式就不出现的问题是什么？如何解决？<br>主要是对a链接的伪元素属性没有设置好，设置顺序为：<em>link，visited，hover，active</em></p>\n<h3 id=\"什么是Css-Hack？ie6-7-8的hack分别是什么？\"><a href=\"#什么是Css-Hack？ie6-7-8的hack分别是什么？\" class=\"headerlink\" title=\"什么是Css Hack？ie6,7,8的hack分别是什么？\"></a>什么是Css Hack？ie6,7,8的hack分别是什么？</h3><p>CSS Hack就是：<strong>针对不同的浏览器编写不同的CSS</strong></p>\n<p>最简单的区分ie6、ie7、ie8的CSS Hack，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.color &#123;</div><div class=\"line\">    background-color: #CC00FF;       // 所有浏览器都能识别</div><div class=\"line\">    background-color: #FF0000\\9;     // 只有IE6、 IE7、IE8能识别</div><div class=\"line\">    *background-color: #0066FF;      // IE6、IE7能识别</div><div class=\"line\">    +background-color: pink;         // 只有IE7能识别</div><div class=\"line\">    _background-color: #009933;      // 只有IE6能识别</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"DIV-CSS-布局-与-table布局的优缺点\"><a href=\"#DIV-CSS-布局-与-table布局的优缺点\" class=\"headerlink\" title=\"DIV + CSS 布局 与 table布局的优缺点\"></a>DIV + CSS 布局 与 table布局的优缺点</h2><p>div + css 布局的优点</p>\n<ul>\n<li>符合W3C标准，结构、行为和样式的分离</li>\n<li>结构清晰，便于扩展</li>\n<li>有利于搜索引擎检索，利于SEO</li>\n</ul>\n<p>参考：<a href=\"https://stackoverflow.com/questions/83073/why-not-use-tables-for-layout-in-html\" target=\"_blank\" rel=\"external\">为什么不使用table布局</a></p>\n"},{"title":"Vue可复用性&组合","date":"2017-09-27T02:38:28.000Z","_content":"http://jsbin.com/qivodaxexi/6/edit?html,js,console\n","source":"_posts/Vue可复用性与组合.md","raw":"---\ntitle: Vue可复用性&组合\ndate: 2017-09-27 10:38:28\ncategories:\ntags: Vue\n---\nhttp://jsbin.com/qivodaxexi/6/edit?html,js,console\n","slug":"Vue可复用性与组合","published":1,"updated":"2017-09-27T02:39:12.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7ges00003ekriratrz8am","content":"<p><a href=\"http://jsbin.com/qivodaxexi/6/edit?html,js,console\" target=\"_blank\" rel=\"external\">http://jsbin.com/qivodaxexi/6/edit?html,js,console</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://jsbin.com/qivodaxexi/6/edit?html,js,console\" target=\"_blank\" rel=\"external\">http://jsbin.com/qivodaxexi/6/edit?html,js,console</a></p>\n"},{"title":"Vue-Nodejs搭建博客","date":"2017-10-01T03:36:39.000Z","_content":"## Express安装\n- `npm install express --save` \n- 使用Express生成器创建应用程序框架\n  因为并未将express进行全局安装，所以需要在`node_modules`中找到`express-generator`，来生产框架\n  `./node_modules/express-generator/bin/express-cli.js . -f -e`\n  可以通过` ./node_modules/express-generator/bin/express-cli.js -h`来查看该命令的相关选项\n- `npm install` 安装依赖\n- `npm start` 启动网站，然后在浏览器中输入`localhost:3000`打开网站\n  可以在`bin/www`中改变端口号\n","source":"_posts/Vue-Nodejs搭建博客.md","raw":"---\ntitle: Vue-Nodejs搭建博客\ndate: 2017-10-01 11:36:39\ncategories:\ntags: Vue\n---\n## Express安装\n- `npm install express --save` \n- 使用Express生成器创建应用程序框架\n  因为并未将express进行全局安装，所以需要在`node_modules`中找到`express-generator`，来生产框架\n  `./node_modules/express-generator/bin/express-cli.js . -f -e`\n  可以通过` ./node_modules/express-generator/bin/express-cli.js -h`来查看该命令的相关选项\n- `npm install` 安装依赖\n- `npm start` 启动网站，然后在浏览器中输入`localhost:3000`打开网站\n  可以在`bin/www`中改变端口号\n","slug":"Vue-Nodejs搭建博客","published":1,"updated":"2017-10-03T01:16:42.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gesc0005ekri87mk66o6","content":"<h2 id=\"Express安装\"><a href=\"#Express安装\" class=\"headerlink\" title=\"Express安装\"></a>Express安装</h2><ul>\n<li><code>npm install express --save</code> </li>\n<li>使用Express生成器创建应用程序框架<br>因为并未将express进行全局安装，所以需要在<code>node_modules</code>中找到<code>express-generator</code>，来生产框架<br><code>./node_modules/express-generator/bin/express-cli.js . -f -e</code><br>可以通过<code>./node_modules/express-generator/bin/express-cli.js -h</code>来查看该命令的相关选项</li>\n<li><code>npm install</code> 安装依赖</li>\n<li><code>npm start</code> 启动网站，然后在浏览器中输入<code>localhost:3000</code>打开网站<br>可以在<code>bin/www</code>中改变端口号</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Express安装\"><a href=\"#Express安装\" class=\"headerlink\" title=\"Express安装\"></a>Express安装</h2><ul>\n<li><code>npm install express --save</code> </li>\n<li>使用Express生成器创建应用程序框架<br>因为并未将express进行全局安装，所以需要在<code>node_modules</code>中找到<code>express-generator</code>，来生产框架<br><code>./node_modules/express-generator/bin/express-cli.js . -f -e</code><br>可以通过<code>./node_modules/express-generator/bin/express-cli.js -h</code>来查看该命令的相关选项</li>\n<li><code>npm install</code> 安装依赖</li>\n<li><code>npm start</code> 启动网站，然后在浏览器中输入<code>localhost:3000</code>打开网站<br>可以在<code>bin/www</code>中改变端口号</li>\n</ul>\n"},{"title":"Promise初探","date":"2017-09-11T08:01:40.000Z","_content":"## Promise是什么？\n**Promise**是一个进行 **异步处理的对象**，并且其提供了一些 **标准化的接口**，在使用时，必须按照统一的编码方式进行编码，\n\n## Promise解决了什么问题\nJavaScript是 **单线程工作**，意味着两段脚本不能同时运行，必须一个接一个运行，\n如果要执行异步操作，只能通过 **回调函数和事件**，回调函数嵌套太多会导致代码变得复杂，逻辑不清晰，不利于维护，而且容易导致 **回调地狱**，Promise的出现就是为了解决异步的问题\n\n## 使用Promise\n创建一个promise对象的流程如下：\n1. `new Promise(fn)` 返回一个promise对象\n2. 在`fn`中指定异步等处理\n    - 处理结果正常的话，调用`resolve(处理结果值)`\n    - 处理结果错误的话，调用`reject(Error对象)`\n\n下面代码创造了一个`Promise`实例\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n代码分析：\n   - Promise对象接收一个函数作为参数，该函数带有两个参数: `resolve`和`reject`，而`resolve`和`reject`都是函数，由Javascript引擎提供，不用自己部署；\n   - `resolve`函数的作用是：将Promise对象的状态 **从\"未完成\"变为\"成功**（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n   - `reject`函数的作用是：将Promise对象的状态从 **\"未完成\"变为\"失败\"**(即从 pending变为rejected)，在异步操作失败时调用，并将异步操作报出的错误信息，作为参数传递出去；\n\n在`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数\n```\npromise.then(function(value) {\n    // success\n}, function(value) {\n    // failure\n})\n```\n\n`then`方法可以接受两个回调函数作为参数。\n第一个回调函数是`Promise`对象的状态变为`resolved`时调用\n第二个回调函数是`Promise`对象的状态变为`rejected`时调用。\n其中第二个回调函数是可选的，不一定要提供。这两个函数都接收`Promise`对象传出的值作为**参数**，也就是在`Promise`对象中`resolve()`函数和`reject()`函数传出来的值\n\n一个示例如下：\n```\nvar getJSON = function(url) {\n  var promise = new Promise(function(resolve, reject){\n    var client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n    function handler() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n## Promise的特点\n1. **对象的状态不受外界影响**\nPromise对象的三种状态：\n  - `pending`(进行时)\n  - `fulfilled`(已成功)\n  - `rejected`(已失败)\n  **注意：**只有 **异步操作的结果**(例如：一个使用Promise封装的XMLHttpRequest，其异步操作的结果就是 *请求成功*或是 *请求失败*)，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是`Promise`这个名字的由来\n2. **一旦状态改变，就不会再变，任何时候都可以得到这个结果**。 Promise的状态改变只有两种情况：**从`pending`变为`fulfilled` 和 从`pending`变为`rejected`**。只要这两种情况发生了，状态就**凝固**了，不会再变了，会一直保持这个结果，这时就称为: **resolved(已定型)**。\n\n## Promise的缺点\n1. 无法取消`Promise`，一旦新建它就会立即执行，无法中途取消\n2. 其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。\n3. 当处于`pending`状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)\n\n参考：[JavaScript Promise：简介](https://developers.google.com/web/fundamentals/getting-started/primers/promises?hl=zh-cn)\n[nodejs 异步实现](https://zhuanlan.zhihu.com/p/25562598)\n[promise迷你书](http://liubin.org/promises-book/)\n\n","source":"_posts/Promise初探.md","raw":"---\ntitle: Promise初探\ndate: 2017-09-11 16:01:40\ncategories:\ntags: Javascript\n---\n## Promise是什么？\n**Promise**是一个进行 **异步处理的对象**，并且其提供了一些 **标准化的接口**，在使用时，必须按照统一的编码方式进行编码，\n\n## Promise解决了什么问题\nJavaScript是 **单线程工作**，意味着两段脚本不能同时运行，必须一个接一个运行，\n如果要执行异步操作，只能通过 **回调函数和事件**，回调函数嵌套太多会导致代码变得复杂，逻辑不清晰，不利于维护，而且容易导致 **回调地狱**，Promise的出现就是为了解决异步的问题\n\n## 使用Promise\n创建一个promise对象的流程如下：\n1. `new Promise(fn)` 返回一个promise对象\n2. 在`fn`中指定异步等处理\n    - 处理结果正常的话，调用`resolve(处理结果值)`\n    - 处理结果错误的话，调用`reject(Error对象)`\n\n下面代码创造了一个`Promise`实例\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n代码分析：\n   - Promise对象接收一个函数作为参数，该函数带有两个参数: `resolve`和`reject`，而`resolve`和`reject`都是函数，由Javascript引擎提供，不用自己部署；\n   - `resolve`函数的作用是：将Promise对象的状态 **从\"未完成\"变为\"成功**（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n   - `reject`函数的作用是：将Promise对象的状态从 **\"未完成\"变为\"失败\"**(即从 pending变为rejected)，在异步操作失败时调用，并将异步操作报出的错误信息，作为参数传递出去；\n\n在`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数\n```\npromise.then(function(value) {\n    // success\n}, function(value) {\n    // failure\n})\n```\n\n`then`方法可以接受两个回调函数作为参数。\n第一个回调函数是`Promise`对象的状态变为`resolved`时调用\n第二个回调函数是`Promise`对象的状态变为`rejected`时调用。\n其中第二个回调函数是可选的，不一定要提供。这两个函数都接收`Promise`对象传出的值作为**参数**，也就是在`Promise`对象中`resolve()`函数和`reject()`函数传出来的值\n\n一个示例如下：\n```\nvar getJSON = function(url) {\n  var promise = new Promise(function(resolve, reject){\n    var client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n    function handler() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n## Promise的特点\n1. **对象的状态不受外界影响**\nPromise对象的三种状态：\n  - `pending`(进行时)\n  - `fulfilled`(已成功)\n  - `rejected`(已失败)\n  **注意：**只有 **异步操作的结果**(例如：一个使用Promise封装的XMLHttpRequest，其异步操作的结果就是 *请求成功*或是 *请求失败*)，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是`Promise`这个名字的由来\n2. **一旦状态改变，就不会再变，任何时候都可以得到这个结果**。 Promise的状态改变只有两种情况：**从`pending`变为`fulfilled` 和 从`pending`变为`rejected`**。只要这两种情况发生了，状态就**凝固**了，不会再变了，会一直保持这个结果，这时就称为: **resolved(已定型)**。\n\n## Promise的缺点\n1. 无法取消`Promise`，一旦新建它就会立即执行，无法中途取消\n2. 其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。\n3. 当处于`pending`状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)\n\n参考：[JavaScript Promise：简介](https://developers.google.com/web/fundamentals/getting-started/primers/promises?hl=zh-cn)\n[nodejs 异步实现](https://zhuanlan.zhihu.com/p/25562598)\n[promise迷你书](http://liubin.org/promises-book/)\n\n","slug":"Promise初探","published":1,"updated":"2017-09-11T08:02:55.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gesf0006ekrilh0uqeli","content":"<h2 id=\"Promise是什么？\"><a href=\"#Promise是什么？\" class=\"headerlink\" title=\"Promise是什么？\"></a>Promise是什么？</h2><p><strong>Promise</strong>是一个进行 <strong>异步处理的对象</strong>，并且其提供了一些 <strong>标准化的接口</strong>，在使用时，必须按照统一的编码方式进行编码，</p>\n<h2 id=\"Promise解决了什么问题\"><a href=\"#Promise解决了什么问题\" class=\"headerlink\" title=\"Promise解决了什么问题\"></a>Promise解决了什么问题</h2><p>JavaScript是 <strong>单线程工作</strong>，意味着两段脚本不能同时运行，必须一个接一个运行，<br>如果要执行异步操作，只能通过 <strong>回调函数和事件</strong>，回调函数嵌套太多会导致代码变得复杂，逻辑不清晰，不利于维护，而且容易导致 <strong>回调地狱</strong>，Promise的出现就是为了解决异步的问题</p>\n<h2 id=\"使用Promise\"><a href=\"#使用Promise\" class=\"headerlink\" title=\"使用Promise\"></a>使用Promise</h2><p>创建一个promise对象的流程如下：</p>\n<ol>\n<li><code>new Promise(fn)</code> 返回一个promise对象</li>\n<li>在<code>fn</code>中指定异步等处理<ul>\n<li>处理结果正常的话，调用<code>resolve(处理结果值)</code></li>\n<li>处理结果错误的话，调用<code>reject(Error对象)</code></li>\n</ul>\n</li>\n</ol>\n<p>下面代码创造了一个<code>Promise</code>实例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</div><div class=\"line\">  // ... some code</div><div class=\"line\"></div><div class=\"line\">  if (/* 异步操作成功 */)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>代码分析：</p>\n<ul>\n<li>Promise对象接收一个函数作为参数，该函数带有两个参数: <code>resolve</code>和<code>reject</code>，而<code>resolve</code>和<code>reject</code>都是函数，由Javascript引擎提供，不用自己部署；</li>\n<li><code>resolve</code>函数的作用是：将Promise对象的状态 <strong>从”未完成”变为”成功</strong>（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>\n<li><code>reject</code>函数的作用是：将Promise对象的状态从 <strong>“未完成”变为”失败”</strong>(即从 pending变为rejected)，在异步操作失败时调用，并将异步操作报出的错误信息，作为参数传递出去；</li>\n</ul>\n<p>在<code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">promise.then(function(value) &#123;</div><div class=\"line\">    // success</div><div class=\"line\">&#125;, function(value) &#123;</div><div class=\"line\">    // failure</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p><code>then</code>方法可以接受两个回调函数作为参数。<br>第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用<br>第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。<br>其中第二个回调函数是可选的，不一定要提供。这两个函数都接收<code>Promise</code>对象传出的值作为<strong>参数</strong>，也就是在<code>Promise</code>对象中<code>resolve()</code>函数和<code>reject()</code>函数传出来的值</p>\n<p>一个示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">var getJSON = function(url) &#123;</div><div class=\"line\">  var promise = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">    var client = new XMLHttpRequest();</div><div class=\"line\">    client.open(&quot;GET&quot;, url);</div><div class=\"line\">    client.onreadystatechange = handler;</div><div class=\"line\">    client.responseType = &quot;json&quot;;</div><div class=\"line\">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</div><div class=\"line\">    client.send();</div><div class=\"line\"></div><div class=\"line\">    function handler() &#123;</div><div class=\"line\">      if (this.readyState !== 4) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">      &#125;</div><div class=\"line\">      if (this.status === 200) &#123;</div><div class=\"line\">        resolve(this.response);</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        reject(new Error(this.statusText));</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  return promise;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</div><div class=\"line\">  console.log(&apos;Contents: &apos; + json);</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">  console.error(&apos;出错了&apos;, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"Promise的特点\"><a href=\"#Promise的特点\" class=\"headerlink\" title=\"Promise的特点\"></a>Promise的特点</h2><ol>\n<li><strong>对象的状态不受外界影响</strong><br>Promise对象的三种状态：<ul>\n<li><code>pending</code>(进行时)</li>\n<li><code>fulfilled</code>(已成功)</li>\n<li><code>rejected</code>(已失败)<br><strong>注意：</strong>只有 <strong>异步操作的结果</strong>(例如：一个使用Promise封装的XMLHttpRequest，其异步操作的结果就是 <em>请求成功</em>或是 <em>请求失败</em>)，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是<code>Promise</code>这个名字的由来</li>\n</ul>\n</li>\n<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。 Promise的状态改变只有两种情况：<strong>从<code>pending</code>变为<code>fulfilled</code> 和 从<code>pending</code>变为<code>rejected</code></strong>。只要这两种情况发生了，状态就<strong>凝固</strong>了，不会再变了，会一直保持这个结果，这时就称为: <strong>resolved(已定型)</strong>。</li>\n</ol>\n<h2 id=\"Promise的缺点\"><a href=\"#Promise的缺点\" class=\"headerlink\" title=\"Promise的缺点\"></a>Promise的缺点</h2><ol>\n<li>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消</li>\n<li>其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</li>\n<li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)</li>\n</ol>\n<p>参考：<a href=\"https://developers.google.com/web/fundamentals/getting-started/primers/promises?hl=zh-cn\" target=\"_blank\" rel=\"external\">JavaScript Promise：简介</a><br><a href=\"https://zhuanlan.zhihu.com/p/25562598\" target=\"_blank\" rel=\"external\">nodejs 异步实现</a><br><a href=\"http://liubin.org/promises-book/\" target=\"_blank\" rel=\"external\">promise迷你书</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Promise是什么？\"><a href=\"#Promise是什么？\" class=\"headerlink\" title=\"Promise是什么？\"></a>Promise是什么？</h2><p><strong>Promise</strong>是一个进行 <strong>异步处理的对象</strong>，并且其提供了一些 <strong>标准化的接口</strong>，在使用时，必须按照统一的编码方式进行编码，</p>\n<h2 id=\"Promise解决了什么问题\"><a href=\"#Promise解决了什么问题\" class=\"headerlink\" title=\"Promise解决了什么问题\"></a>Promise解决了什么问题</h2><p>JavaScript是 <strong>单线程工作</strong>，意味着两段脚本不能同时运行，必须一个接一个运行，<br>如果要执行异步操作，只能通过 <strong>回调函数和事件</strong>，回调函数嵌套太多会导致代码变得复杂，逻辑不清晰，不利于维护，而且容易导致 <strong>回调地狱</strong>，Promise的出现就是为了解决异步的问题</p>\n<h2 id=\"使用Promise\"><a href=\"#使用Promise\" class=\"headerlink\" title=\"使用Promise\"></a>使用Promise</h2><p>创建一个promise对象的流程如下：</p>\n<ol>\n<li><code>new Promise(fn)</code> 返回一个promise对象</li>\n<li>在<code>fn</code>中指定异步等处理<ul>\n<li>处理结果正常的话，调用<code>resolve(处理结果值)</code></li>\n<li>处理结果错误的话，调用<code>reject(Error对象)</code></li>\n</ul>\n</li>\n</ol>\n<p>下面代码创造了一个<code>Promise</code>实例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</div><div class=\"line\">  // ... some code</div><div class=\"line\"></div><div class=\"line\">  if (/* 异步操作成功 */)&#123;</div><div class=\"line\">    resolve(value);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    reject(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>代码分析：</p>\n<ul>\n<li>Promise对象接收一个函数作为参数，该函数带有两个参数: <code>resolve</code>和<code>reject</code>，而<code>resolve</code>和<code>reject</code>都是函数，由Javascript引擎提供，不用自己部署；</li>\n<li><code>resolve</code>函数的作用是：将Promise对象的状态 <strong>从”未完成”变为”成功</strong>（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>\n<li><code>reject</code>函数的作用是：将Promise对象的状态从 <strong>“未完成”变为”失败”</strong>(即从 pending变为rejected)，在异步操作失败时调用，并将异步操作报出的错误信息，作为参数传递出去；</li>\n</ul>\n<p>在<code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">promise.then(function(value) &#123;</div><div class=\"line\">    // success</div><div class=\"line\">&#125;, function(value) &#123;</div><div class=\"line\">    // failure</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p><code>then</code>方法可以接受两个回调函数作为参数。<br>第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用<br>第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。<br>其中第二个回调函数是可选的，不一定要提供。这两个函数都接收<code>Promise</code>对象传出的值作为<strong>参数</strong>，也就是在<code>Promise</code>对象中<code>resolve()</code>函数和<code>reject()</code>函数传出来的值</p>\n<p>一个示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">var getJSON = function(url) &#123;</div><div class=\"line\">  var promise = new Promise(function(resolve, reject)&#123;</div><div class=\"line\">    var client = new XMLHttpRequest();</div><div class=\"line\">    client.open(&quot;GET&quot;, url);</div><div class=\"line\">    client.onreadystatechange = handler;</div><div class=\"line\">    client.responseType = &quot;json&quot;;</div><div class=\"line\">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</div><div class=\"line\">    client.send();</div><div class=\"line\"></div><div class=\"line\">    function handler() &#123;</div><div class=\"line\">      if (this.readyState !== 4) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">      &#125;</div><div class=\"line\">      if (this.status === 200) &#123;</div><div class=\"line\">        resolve(this.response);</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        reject(new Error(this.statusText));</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  return promise;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</div><div class=\"line\">  console.log(&apos;Contents: &apos; + json);</div><div class=\"line\">&#125;, function(error) &#123;</div><div class=\"line\">  console.error(&apos;出错了&apos;, error);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"Promise的特点\"><a href=\"#Promise的特点\" class=\"headerlink\" title=\"Promise的特点\"></a>Promise的特点</h2><ol>\n<li><strong>对象的状态不受外界影响</strong><br>Promise对象的三种状态：<ul>\n<li><code>pending</code>(进行时)</li>\n<li><code>fulfilled</code>(已成功)</li>\n<li><code>rejected</code>(已失败)<br><strong>注意：</strong>只有 <strong>异步操作的结果</strong>(例如：一个使用Promise封装的XMLHttpRequest，其异步操作的结果就是 <em>请求成功</em>或是 <em>请求失败</em>)，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是<code>Promise</code>这个名字的由来</li>\n</ul>\n</li>\n<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。 Promise的状态改变只有两种情况：<strong>从<code>pending</code>变为<code>fulfilled</code> 和 从<code>pending</code>变为<code>rejected</code></strong>。只要这两种情况发生了，状态就<strong>凝固</strong>了，不会再变了，会一直保持这个结果，这时就称为: <strong>resolved(已定型)</strong>。</li>\n</ol>\n<h2 id=\"Promise的缺点\"><a href=\"#Promise的缺点\" class=\"headerlink\" title=\"Promise的缺点\"></a>Promise的缺点</h2><ol>\n<li>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消</li>\n<li>其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</li>\n<li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)</li>\n</ol>\n<p>参考：<a href=\"https://developers.google.com/web/fundamentals/getting-started/primers/promises?hl=zh-cn\" target=\"_blank\" rel=\"external\">JavaScript Promise：简介</a><br><a href=\"https://zhuanlan.zhihu.com/p/25562598\" target=\"_blank\" rel=\"external\">nodejs 异步实现</a><br><a href=\"http://liubin.org/promises-book/\" target=\"_blank\" rel=\"external\">promise迷你书</a></p>\n"},{"title":"Vue-Router-基础","date":"2017-09-27T02:51:40.000Z","_content":"## 基础\n路由的使用需要在 **HTML**和 **JS**中进行处理\n### HTML部分\nHTML中主要需要处理 **路由的跳转** 和 **跳转后的显示**\n**路由的跳转**\n通过`<router-link></router-link>`来进行实现，可以将其理解为一个`<a></a>`标签\n通过`to`来指定跳转的位置(其实就是组件)，\n如: `<router-link to=\"/foo\">Go to Foo</router-link>`\n\n**跳转后的显示**\n通过`<router-view></router-view>`来显示跳转后的内容(其实就是组件的内容)\n\n完整的代码如下：\n```html \n<div id=\"app\">\n    <p>\n       <!-- to=\"/foo\"：表示跳转到 \"/foo\" 的地址，而这个地址是与相应的组件绑定的 -->\n        <router-link to=\"/foo\">Go to Foo</router-link>\n        <router-link to=\"/bar\">Go to Bar</router-link>\n    </p>\n    <router-view></router-view>\n</div>\n```\n\n### JS部分\n简单点说，js部分主要是为相应的组件匹配地址，主要分为以下几个步骤进行：\n- **创建组件**\n  该组件就是进行路由跳转的组件，就是`Vue组件`\n  如： `const Foo = { template: '<div>foo</div>' }`\n  当然，组件也可以是通过`import`导入的\n- **定义路由**\n  每个路由映射一个组件，如：\n  ```js \n        const routes = [\n            {path: '/foo', component: Foo},\n            {path: '/Bar', component: Bar}\n        ]\n  ```\n  **path**: 表示的是路由地址\n  **component**: 表示的是映射的组件\n\n- **创建router实例，然后传入 `routes` 配置**\n  ```js \n    const router = new VueRouter({\n        routes: routes;\n    })\n  ```\n\n- **将路由挂载到Vue根实例中**\n  ```js \n    new Vue({\n        el: '#app'\n        router: router\n    })\n  ```\n\njs部分主要包括以上四部分，完整代码：\n**html部分**\n```html\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n**js部分**\n```js\n// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义（路由）组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // （缩写）相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  el: \"#app\",\n  router: router\n})\n\n// 现在，应用已经启动了！\n\n```\n运行效果查看：[这里](http://output.jsbin.com/tecupi#/bar)\n\n## 动态路由匹配\n考虑这样一种场景：现在有一个用户信息界面，不同的用户，显示不同的个人信息，用户通过id来标识，虽然id不同，但是它们都是通过同一个用户信息组件进行显示，只不过填充了不同的内容，假设它们的地址为:`/user/:id`，这个地址根据id的不同，最终会产生不同的地址，这个便是 **动态路由**。\n\n**官方解释：**我们经常需要将 **某种模式** 匹配到的所有路由，全部映射到 **同一个组件**上，例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』（dynamic segment）来达到这个效果：\n\n```js\nconst User = {\n    template: '<div>User</div>'\n}\n\nconst router = new VueRouter({\n    routes: [\n    // 动态路由参数，以 冒号 开头\n        {path: \"/user/:id\", component: User}\n    ]\n})\n```\n现在，`/user/foo`和`/user/bar`都将映射到相同的路由上\n\n实例：\n```html  \n  <div id=\"app2\">\n    <h1>Hello router</h1>\n    <p>\n      <router-link to=\"/user/foo\">Go to Foo</router-link>\n      <router-link to=\"/user/bar\">Go to Bar</router-link>\n    </p>\n    \n    <router-view></router-view>\n  </div>\n```\n```js \n\nvar User = {\n  template: '<div> 我的参数是：{{ $route.params.id }} </div>'\n};\n\nvar router2 = new VueRouter({\n  routes: [\n    {path: '/user/:id', component: User}\n  ]\n})\n\nnew Vue({\n  el: '#app2',\n  router: router2\n})\n```\n\n一个 **路径参数** 以 **冒号** 标记。当匹配到一个路由时，参数值会被设置到`this.$route.params`中，可以在每个组件内使用\n\n**多段路径参数的配置**\n可以在路径中设置多段 **路径参数**， 对应的值会设置到 `$route.params`中\n|模式|路径参数|$route.params\n|----|--------|--------------\n|/user/:username|/user/evan/ `{username: evan}`\n|/user/:username/post/:post_id|user/evan/post/123| `{username: evan, post_id: 123}`\n\n除了`$route.params`外，`$route`对象还提供了其它有用的信息，例如：`$route.query`, `$route.hash` 等等，可以查看 [API 文档](https://router.vuejs.org/zh-cn/api/route-object.html)\n**注意**：\n- 动态路由是以 **冒号** 开头\n\n\n## 响应路由参数 的变化\n注意：当使用路由参数时，例如从`/user/foo`导航到`/user/bar`，**原来的组件会被复用**。因为两个路由渲染同一个组件，比起销毁再重建，更加高效。不过，**这也意味着组件的生命周期钩子不再被调用**。\n实例：\n```html  \n  <div id=\"app2\">\n    <h1>Hello router</h1>\n    <p>\n      <router-link to=\"/user/foo\">Go to Foo</router-link>\n      <router-link to=\"/user/bar\">Go to Bar</router-link>\n    </p>\n    \n    <router-view></router-view>\n  </div>\n```\n```js \n\nvar User = {\n  template: '<div> 我的参数是：{{ $route.params.id }} </div>',\n  created: function() {\n    console.log('a');       // 只会在第一次路由切换时被调用\n  }\n};\n\nvar router2 = new VueRouter({\n  routes: [\n    {path: '/user/:id', component: User}\n  ]\n})\n\nnew Vue({\n  el: '#app2',\n  router: router2\n})\n```\n上面代码中的User组件里面的`created`钩子只会被调用一次，当再进行路由切换时，不会被调用，这也就说明了路由的切换是复用同一个组件\n\n复用组件时，如果想要对 **路由参数的变化**做出响应的话，可以简单的通过`watch`监测`$route`对象的变化，如下：\n```js \n watch: {\n    $route(to, from){\n      console.log(to.path);\n      console.log(from.path)\n    }\n  }\n```\n\n## 匹配优先级\n有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：**谁先定义，谁的优先级就高**\n\n\n## 代码\n[实验代码](http://output.jsbin.com/tecupi#/user/posts)","source":"_posts/Vue-Router-基础.md","raw":"---\ntitle: Vue-Router-基础\ndate: 2017-09-27 10:51:40\ncategories:\ntags: Vue-Router\n---\n## 基础\n路由的使用需要在 **HTML**和 **JS**中进行处理\n### HTML部分\nHTML中主要需要处理 **路由的跳转** 和 **跳转后的显示**\n**路由的跳转**\n通过`<router-link></router-link>`来进行实现，可以将其理解为一个`<a></a>`标签\n通过`to`来指定跳转的位置(其实就是组件)，\n如: `<router-link to=\"/foo\">Go to Foo</router-link>`\n\n**跳转后的显示**\n通过`<router-view></router-view>`来显示跳转后的内容(其实就是组件的内容)\n\n完整的代码如下：\n```html \n<div id=\"app\">\n    <p>\n       <!-- to=\"/foo\"：表示跳转到 \"/foo\" 的地址，而这个地址是与相应的组件绑定的 -->\n        <router-link to=\"/foo\">Go to Foo</router-link>\n        <router-link to=\"/bar\">Go to Bar</router-link>\n    </p>\n    <router-view></router-view>\n</div>\n```\n\n### JS部分\n简单点说，js部分主要是为相应的组件匹配地址，主要分为以下几个步骤进行：\n- **创建组件**\n  该组件就是进行路由跳转的组件，就是`Vue组件`\n  如： `const Foo = { template: '<div>foo</div>' }`\n  当然，组件也可以是通过`import`导入的\n- **定义路由**\n  每个路由映射一个组件，如：\n  ```js \n        const routes = [\n            {path: '/foo', component: Foo},\n            {path: '/Bar', component: Bar}\n        ]\n  ```\n  **path**: 表示的是路由地址\n  **component**: 表示的是映射的组件\n\n- **创建router实例，然后传入 `routes` 配置**\n  ```js \n    const router = new VueRouter({\n        routes: routes;\n    })\n  ```\n\n- **将路由挂载到Vue根实例中**\n  ```js \n    new Vue({\n        el: '#app'\n        router: router\n    })\n  ```\n\njs部分主要包括以上四部分，完整代码：\n**html部分**\n```html\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n**js部分**\n```js\n// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义（路由）组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // （缩写）相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  el: \"#app\",\n  router: router\n})\n\n// 现在，应用已经启动了！\n\n```\n运行效果查看：[这里](http://output.jsbin.com/tecupi#/bar)\n\n## 动态路由匹配\n考虑这样一种场景：现在有一个用户信息界面，不同的用户，显示不同的个人信息，用户通过id来标识，虽然id不同，但是它们都是通过同一个用户信息组件进行显示，只不过填充了不同的内容，假设它们的地址为:`/user/:id`，这个地址根据id的不同，最终会产生不同的地址，这个便是 **动态路由**。\n\n**官方解释：**我们经常需要将 **某种模式** 匹配到的所有路由，全部映射到 **同一个组件**上，例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』（dynamic segment）来达到这个效果：\n\n```js\nconst User = {\n    template: '<div>User</div>'\n}\n\nconst router = new VueRouter({\n    routes: [\n    // 动态路由参数，以 冒号 开头\n        {path: \"/user/:id\", component: User}\n    ]\n})\n```\n现在，`/user/foo`和`/user/bar`都将映射到相同的路由上\n\n实例：\n```html  \n  <div id=\"app2\">\n    <h1>Hello router</h1>\n    <p>\n      <router-link to=\"/user/foo\">Go to Foo</router-link>\n      <router-link to=\"/user/bar\">Go to Bar</router-link>\n    </p>\n    \n    <router-view></router-view>\n  </div>\n```\n```js \n\nvar User = {\n  template: '<div> 我的参数是：{{ $route.params.id }} </div>'\n};\n\nvar router2 = new VueRouter({\n  routes: [\n    {path: '/user/:id', component: User}\n  ]\n})\n\nnew Vue({\n  el: '#app2',\n  router: router2\n})\n```\n\n一个 **路径参数** 以 **冒号** 标记。当匹配到一个路由时，参数值会被设置到`this.$route.params`中，可以在每个组件内使用\n\n**多段路径参数的配置**\n可以在路径中设置多段 **路径参数**， 对应的值会设置到 `$route.params`中\n|模式|路径参数|$route.params\n|----|--------|--------------\n|/user/:username|/user/evan/ `{username: evan}`\n|/user/:username/post/:post_id|user/evan/post/123| `{username: evan, post_id: 123}`\n\n除了`$route.params`外，`$route`对象还提供了其它有用的信息，例如：`$route.query`, `$route.hash` 等等，可以查看 [API 文档](https://router.vuejs.org/zh-cn/api/route-object.html)\n**注意**：\n- 动态路由是以 **冒号** 开头\n\n\n## 响应路由参数 的变化\n注意：当使用路由参数时，例如从`/user/foo`导航到`/user/bar`，**原来的组件会被复用**。因为两个路由渲染同一个组件，比起销毁再重建，更加高效。不过，**这也意味着组件的生命周期钩子不再被调用**。\n实例：\n```html  \n  <div id=\"app2\">\n    <h1>Hello router</h1>\n    <p>\n      <router-link to=\"/user/foo\">Go to Foo</router-link>\n      <router-link to=\"/user/bar\">Go to Bar</router-link>\n    </p>\n    \n    <router-view></router-view>\n  </div>\n```\n```js \n\nvar User = {\n  template: '<div> 我的参数是：{{ $route.params.id }} </div>',\n  created: function() {\n    console.log('a');       // 只会在第一次路由切换时被调用\n  }\n};\n\nvar router2 = new VueRouter({\n  routes: [\n    {path: '/user/:id', component: User}\n  ]\n})\n\nnew Vue({\n  el: '#app2',\n  router: router2\n})\n```\n上面代码中的User组件里面的`created`钩子只会被调用一次，当再进行路由切换时，不会被调用，这也就说明了路由的切换是复用同一个组件\n\n复用组件时，如果想要对 **路由参数的变化**做出响应的话，可以简单的通过`watch`监测`$route`对象的变化，如下：\n```js \n watch: {\n    $route(to, from){\n      console.log(to.path);\n      console.log(from.path)\n    }\n  }\n```\n\n## 匹配优先级\n有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：**谁先定义，谁的优先级就高**\n\n\n## 代码\n[实验代码](http://output.jsbin.com/tecupi#/user/posts)","slug":"Vue-Router-基础","published":1,"updated":"2017-09-27T09:39:22.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gesn0007ekri69aer27i","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>路由的使用需要在 <strong>HTML</strong>和 <strong>JS</strong>中进行处理</p>\n<h3 id=\"HTML部分\"><a href=\"#HTML部分\" class=\"headerlink\" title=\"HTML部分\"></a>HTML部分</h3><p>HTML中主要需要处理 <strong>路由的跳转</strong> 和 <strong>跳转后的显示</strong><br><strong>路由的跳转</strong><br>通过<code>&lt;router-link&gt;&lt;/router-link&gt;</code>来进行实现，可以将其理解为一个<code>&lt;a&gt;&lt;/a&gt;</code>标签<br>通过<code>to</code>来指定跳转的位置(其实就是组件)，<br>如: <code>&lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</code></p>\n<p><strong>跳转后的显示</strong><br>通过<code>&lt;router-view&gt;&lt;/router-view&gt;</code>来显示跳转后的内容(其实就是组件的内容)</p>\n<p>完整的代码如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">       <span class=\"comment\">&lt;!-- to=\"/foo\"：表示跳转到 \"/foo\" 的地址，而这个地址是与相应的组件绑定的 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/foo\"</span>&gt;</span>Go to Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bar\"</span>&gt;</span>Go to Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"JS部分\"><a href=\"#JS部分\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h3><p>简单点说，js部分主要是为相应的组件匹配地址，主要分为以下几个步骤进行：</p>\n<ul>\n<li><strong>创建组件</strong><br>该组件就是进行路由跳转的组件，就是<code>Vue组件</code><br>如： <code>const Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }</code><br>当然，组件也可以是通过<code>import</code>导入的</li>\n<li><p><strong>定义路由</strong><br>每个路由映射一个组件，如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> routes = [</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">component</span>: Foo&#125;,</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/Bar'</span>, <span class=\"attr\">component</span>: Bar&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p><strong>path</strong>: 表示的是路由地址<br><strong>component</strong>: 表示的是映射的组件</p>\n</li>\n<li><p><strong>创建router实例，然后传入 <code>routes</code> 配置</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">    routes: routes;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>将路由挂载到Vue根实例中</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    el: <span class=\"string\">'#app'</span></div><div class=\"line\">    router: router</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>js部分主要包括以上四部分，完整代码：<br><strong>html部分</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/vue/dist/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/vue-router/dist/vue-router.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello App!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/foo\"</span>&gt;</span>Go to Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bar\"</span>&gt;</span>Go to Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 路由出口 --&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><strong>js部分</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 1. 定义（路由）组件。</span></div><div class=\"line\"><span class=\"comment\">// 可以从其他文件 import 进来</span></div><div class=\"line\"><span class=\"keyword\">const</span> Foo = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;foo&lt;/div&gt;'</span> &#125;</div><div class=\"line\"><span class=\"keyword\">const</span> Bar = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;bar&lt;/div&gt;'</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2. 定义路由</span></div><div class=\"line\"><span class=\"comment\">// 每个路由应该映射一个组件。 其中\"component\" 可以是</span></div><div class=\"line\"><span class=\"comment\">// 通过 Vue.extend() 创建的组件构造器，</span></div><div class=\"line\"><span class=\"comment\">// 或者，只是一个组件配置对象。</span></div><div class=\"line\"><span class=\"comment\">// 我们晚点再讨论嵌套路由。</span></div><div class=\"line\"><span class=\"keyword\">const</span> routes = [</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">component</span>: Foo &#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/bar'</span>, <span class=\"attr\">component</span>: Bar &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 3. 创建 router 实例，然后传 `routes` 配置</span></div><div class=\"line\"><span class=\"comment\">// 你还可以传别的配置参数, 不过先这么简单着吧。</span></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  routes <span class=\"comment\">// （缩写）相当于 routes: routes</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 4. 创建和挂载根实例。</span></div><div class=\"line\"><span class=\"comment\">// 记得要通过 router 配置参数注入路由，</span></div><div class=\"line\"><span class=\"comment\">// 从而让整个应用都有路由功能</span></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  el: <span class=\"string\">\"#app\"</span>,</div><div class=\"line\">  router: router</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 现在，应用已经启动了！</span></div></pre></td></tr></table></figure></p>\n<p>运行效果查看：<a href=\"http://output.jsbin.com/tecupi#/bar\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h2 id=\"动态路由匹配\"><a href=\"#动态路由匹配\" class=\"headerlink\" title=\"动态路由匹配\"></a>动态路由匹配</h2><p>考虑这样一种场景：现在有一个用户信息界面，不同的用户，显示不同的个人信息，用户通过id来标识，虽然id不同，但是它们都是通过同一个用户信息组件进行显示，只不过填充了不同的内容，假设它们的地址为:<code>/user/:id</code>，这个地址根据id的不同，最终会产生不同的地址，这个便是 <strong>动态路由</strong>。</p>\n<p><strong>官方解释：</strong>我们经常需要将 <strong>某种模式</strong> 匹配到的所有路由，全部映射到 <strong>同一个组件</strong>上，例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』（dynamic segment）来达到这个效果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> User = &#123;</div><div class=\"line\">    template: <span class=\"string\">'&lt;div&gt;User&lt;/div&gt;'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">    routes: [</div><div class=\"line\">    <span class=\"comment\">// 动态路由参数，以 冒号 开头</span></div><div class=\"line\">        &#123;<span class=\"attr\">path</span>: <span class=\"string\">\"/user/:id\"</span>, <span class=\"attr\">component</span>: User&#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>现在，<code>/user/foo</code>和<code>/user/bar</code>都将映射到相同的路由上</p>\n<p>实例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello router<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/foo\"</span>&gt;</span>Go to Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/bar\"</span>&gt;</span>Go to Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> User = &#123;</div><div class=\"line\">  template: <span class=\"string\">'&lt;div&gt; 我的参数是：&#123;&#123; $route.params.id &#125;&#125; &lt;/div&gt;'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> router2 = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  routes: [</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/user/:id'</span>, <span class=\"attr\">component</span>: User&#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  el: <span class=\"string\">'#app2'</span>,</div><div class=\"line\">  router: router2</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>一个 <strong>路径参数</strong> 以 <strong>冒号</strong> 标记。当匹配到一个路由时，参数值会被设置到<code>this.$route.params</code>中，可以在每个组件内使用</p>\n<p><strong>多段路径参数的配置</strong><br>可以在路径中设置多段 <strong>路径参数</strong>， 对应的值会设置到 <code>$route.params</code>中<br>|模式|路径参数|$route.params<br>|—-|——–|————–<br>|/user/:username|/user/evan/ <code>{username: evan}</code><br>|/user/:username/post/:post_id|user/evan/post/123| <code>{username: evan, post_id: 123}</code></p>\n<p>除了<code>$route.params</code>外，<code>$route</code>对象还提供了其它有用的信息，例如：<code>$route.query</code>, <code>$route.hash</code> 等等，可以查看 <a href=\"https://router.vuejs.org/zh-cn/api/route-object.html\" target=\"_blank\" rel=\"external\">API 文档</a><br><strong>注意</strong>：</p>\n<ul>\n<li>动态路由是以 <strong>冒号</strong> 开头</li>\n</ul>\n<h2 id=\"响应路由参数-的变化\"><a href=\"#响应路由参数-的变化\" class=\"headerlink\" title=\"响应路由参数 的变化\"></a>响应路由参数 的变化</h2><p>注意：当使用路由参数时，例如从<code>/user/foo</code>导航到<code>/user/bar</code>，<strong>原来的组件会被复用</strong>。因为两个路由渲染同一个组件，比起销毁再重建，更加高效。不过，<strong>这也意味着组件的生命周期钩子不再被调用</strong>。<br>实例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello router<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/foo\"</span>&gt;</span>Go to Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/bar\"</span>&gt;</span>Go to Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> User = &#123;</div><div class=\"line\">  template: <span class=\"string\">'&lt;div&gt; 我的参数是：&#123;&#123; $route.params.id &#125;&#125; &lt;/div&gt;'</span>,</div><div class=\"line\">  created: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);       <span class=\"comment\">// 只会在第一次路由切换时被调用</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> router2 = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  routes: [</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/user/:id'</span>, <span class=\"attr\">component</span>: User&#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  el: <span class=\"string\">'#app2'</span>,</div><div class=\"line\">  router: router2</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>上面代码中的User组件里面的<code>created</code>钩子只会被调用一次，当再进行路由切换时，不会被调用，这也就说明了路由的切换是复用同一个组件</p>\n<p>复用组件时，如果想要对 <strong>路由参数的变化</strong>做出响应的话，可以简单的通过<code>watch</code>监测<code>$route</code>对象的变化，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">watch: &#123;</div><div class=\"line\">   $route(to, <span class=\"keyword\">from</span>)&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(to.path);</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">from</span>.path)</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"匹配优先级\"><a href=\"#匹配优先级\" class=\"headerlink\" title=\"匹配优先级\"></a>匹配优先级</h2><p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：<strong>谁先定义，谁的优先级就高</strong></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p><a href=\"http://output.jsbin.com/tecupi#/user/posts\" target=\"_blank\" rel=\"external\">实验代码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>路由的使用需要在 <strong>HTML</strong>和 <strong>JS</strong>中进行处理</p>\n<h3 id=\"HTML部分\"><a href=\"#HTML部分\" class=\"headerlink\" title=\"HTML部分\"></a>HTML部分</h3><p>HTML中主要需要处理 <strong>路由的跳转</strong> 和 <strong>跳转后的显示</strong><br><strong>路由的跳转</strong><br>通过<code>&lt;router-link&gt;&lt;/router-link&gt;</code>来进行实现，可以将其理解为一个<code>&lt;a&gt;&lt;/a&gt;</code>标签<br>通过<code>to</code>来指定跳转的位置(其实就是组件)，<br>如: <code>&lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</code></p>\n<p><strong>跳转后的显示</strong><br>通过<code>&lt;router-view&gt;&lt;/router-view&gt;</code>来显示跳转后的内容(其实就是组件的内容)</p>\n<p>完整的代码如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">       <span class=\"comment\">&lt;!-- to=\"/foo\"：表示跳转到 \"/foo\" 的地址，而这个地址是与相应的组件绑定的 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/foo\"</span>&gt;</span>Go to Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bar\"</span>&gt;</span>Go to Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"JS部分\"><a href=\"#JS部分\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h3><p>简单点说，js部分主要是为相应的组件匹配地址，主要分为以下几个步骤进行：</p>\n<ul>\n<li><strong>创建组件</strong><br>该组件就是进行路由跳转的组件，就是<code>Vue组件</code><br>如： <code>const Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }</code><br>当然，组件也可以是通过<code>import</code>导入的</li>\n<li><p><strong>定义路由</strong><br>每个路由映射一个组件，如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> routes = [</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">component</span>: Foo&#125;,</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/Bar'</span>, <span class=\"attr\">component</span>: Bar&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p><strong>path</strong>: 表示的是路由地址<br><strong>component</strong>: 表示的是映射的组件</p>\n</li>\n<li><p><strong>创建router实例，然后传入 <code>routes</code> 配置</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">    routes: routes;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>将路由挂载到Vue根实例中</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    el: <span class=\"string\">'#app'</span></div><div class=\"line\">    router: router</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>js部分主要包括以上四部分，完整代码：<br><strong>html部分</strong><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/vue/dist/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://unpkg.com/vue-router/dist/vue-router.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello App!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/foo\"</span>&gt;</span>Go to Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bar\"</span>&gt;</span>Go to Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 路由出口 --&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><strong>js部分</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 1. 定义（路由）组件。</span></div><div class=\"line\"><span class=\"comment\">// 可以从其他文件 import 进来</span></div><div class=\"line\"><span class=\"keyword\">const</span> Foo = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;foo&lt;/div&gt;'</span> &#125;</div><div class=\"line\"><span class=\"keyword\">const</span> Bar = &#123; <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;bar&lt;/div&gt;'</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2. 定义路由</span></div><div class=\"line\"><span class=\"comment\">// 每个路由应该映射一个组件。 其中\"component\" 可以是</span></div><div class=\"line\"><span class=\"comment\">// 通过 Vue.extend() 创建的组件构造器，</span></div><div class=\"line\"><span class=\"comment\">// 或者，只是一个组件配置对象。</span></div><div class=\"line\"><span class=\"comment\">// 我们晚点再讨论嵌套路由。</span></div><div class=\"line\"><span class=\"keyword\">const</span> routes = [</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">component</span>: Foo &#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/bar'</span>, <span class=\"attr\">component</span>: Bar &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 3. 创建 router 实例，然后传 `routes` 配置</span></div><div class=\"line\"><span class=\"comment\">// 你还可以传别的配置参数, 不过先这么简单着吧。</span></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  routes <span class=\"comment\">// （缩写）相当于 routes: routes</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 4. 创建和挂载根实例。</span></div><div class=\"line\"><span class=\"comment\">// 记得要通过 router 配置参数注入路由，</span></div><div class=\"line\"><span class=\"comment\">// 从而让整个应用都有路由功能</span></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  el: <span class=\"string\">\"#app\"</span>,</div><div class=\"line\">  router: router</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 现在，应用已经启动了！</span></div></pre></td></tr></table></figure></p>\n<p>运行效果查看：<a href=\"http://output.jsbin.com/tecupi#/bar\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h2 id=\"动态路由匹配\"><a href=\"#动态路由匹配\" class=\"headerlink\" title=\"动态路由匹配\"></a>动态路由匹配</h2><p>考虑这样一种场景：现在有一个用户信息界面，不同的用户，显示不同的个人信息，用户通过id来标识，虽然id不同，但是它们都是通过同一个用户信息组件进行显示，只不过填充了不同的内容，假设它们的地址为:<code>/user/:id</code>，这个地址根据id的不同，最终会产生不同的地址，这个便是 <strong>动态路由</strong>。</p>\n<p><strong>官方解释：</strong>我们经常需要将 <strong>某种模式</strong> 匹配到的所有路由，全部映射到 <strong>同一个组件</strong>上，例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用『动态路径参数』（dynamic segment）来达到这个效果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> User = &#123;</div><div class=\"line\">    template: <span class=\"string\">'&lt;div&gt;User&lt;/div&gt;'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">    routes: [</div><div class=\"line\">    <span class=\"comment\">// 动态路由参数，以 冒号 开头</span></div><div class=\"line\">        &#123;<span class=\"attr\">path</span>: <span class=\"string\">\"/user/:id\"</span>, <span class=\"attr\">component</span>: User&#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>现在，<code>/user/foo</code>和<code>/user/bar</code>都将映射到相同的路由上</p>\n<p>实例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello router<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/foo\"</span>&gt;</span>Go to Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/bar\"</span>&gt;</span>Go to Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> User = &#123;</div><div class=\"line\">  template: <span class=\"string\">'&lt;div&gt; 我的参数是：&#123;&#123; $route.params.id &#125;&#125; &lt;/div&gt;'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> router2 = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  routes: [</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/user/:id'</span>, <span class=\"attr\">component</span>: User&#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  el: <span class=\"string\">'#app2'</span>,</div><div class=\"line\">  router: router2</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>一个 <strong>路径参数</strong> 以 <strong>冒号</strong> 标记。当匹配到一个路由时，参数值会被设置到<code>this.$route.params</code>中，可以在每个组件内使用</p>\n<p><strong>多段路径参数的配置</strong><br>可以在路径中设置多段 <strong>路径参数</strong>， 对应的值会设置到 <code>$route.params</code>中<br>|模式|路径参数|$route.params<br>|—-|——–|————–<br>|/user/:username|/user/evan/ <code>{username: evan}</code><br>|/user/:username/post/:post_id|user/evan/post/123| <code>{username: evan, post_id: 123}</code></p>\n<p>除了<code>$route.params</code>外，<code>$route</code>对象还提供了其它有用的信息，例如：<code>$route.query</code>, <code>$route.hash</code> 等等，可以查看 <a href=\"https://router.vuejs.org/zh-cn/api/route-object.html\" target=\"_blank\" rel=\"external\">API 文档</a><br><strong>注意</strong>：</p>\n<ul>\n<li>动态路由是以 <strong>冒号</strong> 开头</li>\n</ul>\n<h2 id=\"响应路由参数-的变化\"><a href=\"#响应路由参数-的变化\" class=\"headerlink\" title=\"响应路由参数 的变化\"></a>响应路由参数 的变化</h2><p>注意：当使用路由参数时，例如从<code>/user/foo</code>导航到<code>/user/bar</code>，<strong>原来的组件会被复用</strong>。因为两个路由渲染同一个组件，比起销毁再重建，更加高效。不过，<strong>这也意味着组件的生命周期钩子不再被调用</strong>。<br>实例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello router<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/foo\"</span>&gt;</span>Go to Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/bar\"</span>&gt;</span>Go to Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> User = &#123;</div><div class=\"line\">  template: <span class=\"string\">'&lt;div&gt; 我的参数是：&#123;&#123; $route.params.id &#125;&#125; &lt;/div&gt;'</span>,</div><div class=\"line\">  created: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a'</span>);       <span class=\"comment\">// 只会在第一次路由切换时被调用</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> router2 = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  routes: [</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/user/:id'</span>, <span class=\"attr\">component</span>: User&#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  el: <span class=\"string\">'#app2'</span>,</div><div class=\"line\">  router: router2</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>上面代码中的User组件里面的<code>created</code>钩子只会被调用一次，当再进行路由切换时，不会被调用，这也就说明了路由的切换是复用同一个组件</p>\n<p>复用组件时，如果想要对 <strong>路由参数的变化</strong>做出响应的话，可以简单的通过<code>watch</code>监测<code>$route</code>对象的变化，如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">watch: &#123;</div><div class=\"line\">   $route(to, <span class=\"keyword\">from</span>)&#123;</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(to.path);</div><div class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"keyword\">from</span>.path)</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"匹配优先级\"><a href=\"#匹配优先级\" class=\"headerlink\" title=\"匹配优先级\"></a>匹配优先级</h2><p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：<strong>谁先定义，谁的优先级就高</strong></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p><a href=\"http://output.jsbin.com/tecupi#/user/posts\" target=\"_blank\" rel=\"external\">实验代码</a></p>\n"},{"title":"Webpack配置初探","date":"2017-09-25T08:23:22.000Z","_content":"","source":"_posts/Webpack配置初探.md","raw":"---\ntitle: Webpack配置初探\ndate: 2017-09-25 16:23:22\ncategories:\ntags:\n---\n","slug":"Webpack配置初探","published":1,"updated":"2017-09-25T08:23:22.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gesp000aekrie4wnsieq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Vue中使用Mixins","date":"2017-09-26T08:45:29.000Z","_content":"假设现在有这么一种情况：有两个组件，它们有很多相似之处，有相同的逻辑，同时，它们也有很多不同的点，那么是将其分割开来作为两个组件？还是作为一个组件，然后通过`props`来进行功能实现？\n\n不管选择哪种方案，都不是很完美。如果分为两个组件，那么当进行功能调整时，有可能每个组件都需要调整，增加工作量；如果合为一个组件，那么内部的逻辑会变得复杂， 不利于维护\n\n**Mixins** 是Vue中一个很有用的功能，可以让我们编写类似于函数式编程风格的代码。**Mixins**允许我们 **封装函数功能**，以便在很多不同的组件中可以使用。如果采用正确的方式编写，它们将会是 **纯函数**——也就是说，它们不会更改功能范围之外的内容。\n\n更加通俗的理解就是：**使用Mixins，可以将组件中公共的部分抽离出来，然后在需要使用的时候进行导入，可以精简代码，同时逻辑清晰**\n\n## Basic example\n现在有两个组件——*modal*和 *tooltip*，它们的主要功能是切换一个boolean类型的state，然后进行相应的显示，除了逻辑相似之外就没有什么相同点了\n\n**modal 组件**\n```js \nconst Modal = {\n    template: \"#modal\",\n    data() {\n        return {\n            isShowing: false\n        }\n    },\n    methods: {\n        toggleShow() {\n            this.isShowing = !this.isShowing;\n        }\n    },\n    components: {\n        appChild: Child\n    }\n}\n```\n\n**tooltip 组件**\n```js \nconst tooltip = {\n    template: \"#tooltip\",\n    data() {\n        return {\n            isShowing: false\n        }\n    },\n    methods: {\n        toggleShow() {\n            this.isShowing = !this.isShowing;\n        }\n    },\n    components: {\n        appChild: Child\n    }\n}\n```\n提取上面两个组件中的相同逻辑：\n```js \nconst toggle = {\n    data() {\n        return {\n            isShowing: false\n        }\n    },\n    methods: {\n        toggleShow() {\n            this.isShowing = !this.isShowing;\n        }\n    }\n}\n// Modal 组件\nconst Modal = {\n    template: \"#modal\",\n    // 使用混合\n    mixins: [toggle],\n    components: {\n        appChild；Child\n    }\n};\n\n// Tooltip组件\nconst Tooltip = {\n    template: \"#tooltip\",\n    // 使用混合\n    mixins: [toggle],\n    components: {\n        appChild: Child\n    }\n}\n```\n以上便是使用混合提取出相同的逻辑，然后在各个组件中使用的示例\n\n完整例子代码查看: [这里](https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/)\n\n## Usage\n在实际应用中，可以创建一个 **mixins** 的文件夹用于存放mixins对象，如下所示：\n![Vue mixins的文件结构](https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1496725448/toggle_ma4im5.jpg)\n\n在Modal.vue中，我们可以import mixins对象来使用它，代码如下：\n```js \nimport Child from './Child'\nimport { toggle } from './mixins/toggle'\n\nexport default {\n    name: 'modal',\n    mixins: [toggle],\n    components: {\n        appChild: Child\n    }\n}\n```\n有一点很重要：虽然mixins是一个对象，但是在里面我们仍然可以使用Vue组件的的钩子函数，例如：`mounted`, `created`。。。\n\n## 合并\n分为两种情况考虑：组件和混合对象的同名选项下的值 **不是对象** 和 **是对象**\n### 不是对象时\n**如果同名选项的值不是对象，则混合为一个数组，依次调用**\n\n当在组件中使用mixins对象，同时，组件中和mixins对象中有同名的钩子函数，这时同名的函数会被 **混合为一个数组**，在进行调用时，它们都会被调用，但是存在一个 **调用顺序**的问题：**mixins对象上的钩子函数会比对象自身的钩子函数先调用**：\n```js \nvar mixin = {\n    created: function() {\n        console.log('混合对象的钩子被调用')\n    }\n}\n\nnew Vue({\n    mixins: [mixin],\n    created: function() {\n        console.log('组件钩子被调用')\n    }\n})\n\n// => \"混合对象的钩子被调用\"\n// => \"组件钩子被调用\"\n```\n\n### 是对象\n**如果同名选项的值是对象，则混合为同一个对象，当其中两个对象键名冲突时，取组件对象的`键值对`**\n\n```js\nvar mixin = {\n    methods: {\n        foo: function() {\n            console.log('foo')\n        },\n        conflicting: function() {\n            console.log('from mixin')\n        }\n    }\n}\n\nvar vm = new Vue({\n    mixins: [mixin],\n    methods: {\n        foo: function() {\n            console.log('from self foo')\n        },\n        bar: function() {\n            console.log('bar')\n        },\n        conflicting: function() {\n            console.log('from self')\n        }\n    }\n})\n \nvm.foo()  // => 'from self foo'\nvm.bar()  // => bar\nvm.conflicting()  // => 'from self'\n```\n如上，`vm.foo()`调用的是组件对象自身的foo\n\n\n## 全局混合\n全局混合不推荐使用，具体查看参考部分的官方教程\n\n## 自定义选项合并策略\n查看官方教程了解\n\n## 结论\n混合可以让我们封装一些小的功能模块用于重复利用，当然，高阶组件也可以实现，具体使用哪种方式，根据实际情况进行考虑，避免滥用\n\n\n## 参考: \n- [Using Mixins in Vue.js](https://css-tricks.com/using-mixins-vue-js/)\n- [Vue 混合](https://cn.vuejs.org/v2/guide/mixins.html)","source":"_posts/Vue中使用Mixins.md","raw":"---\ntitle: Vue中使用Mixins\ndate: 2017-09-26 16:45:29\ncategories:\ntags: Vue\n---\n假设现在有这么一种情况：有两个组件，它们有很多相似之处，有相同的逻辑，同时，它们也有很多不同的点，那么是将其分割开来作为两个组件？还是作为一个组件，然后通过`props`来进行功能实现？\n\n不管选择哪种方案，都不是很完美。如果分为两个组件，那么当进行功能调整时，有可能每个组件都需要调整，增加工作量；如果合为一个组件，那么内部的逻辑会变得复杂， 不利于维护\n\n**Mixins** 是Vue中一个很有用的功能，可以让我们编写类似于函数式编程风格的代码。**Mixins**允许我们 **封装函数功能**，以便在很多不同的组件中可以使用。如果采用正确的方式编写，它们将会是 **纯函数**——也就是说，它们不会更改功能范围之外的内容。\n\n更加通俗的理解就是：**使用Mixins，可以将组件中公共的部分抽离出来，然后在需要使用的时候进行导入，可以精简代码，同时逻辑清晰**\n\n## Basic example\n现在有两个组件——*modal*和 *tooltip*，它们的主要功能是切换一个boolean类型的state，然后进行相应的显示，除了逻辑相似之外就没有什么相同点了\n\n**modal 组件**\n```js \nconst Modal = {\n    template: \"#modal\",\n    data() {\n        return {\n            isShowing: false\n        }\n    },\n    methods: {\n        toggleShow() {\n            this.isShowing = !this.isShowing;\n        }\n    },\n    components: {\n        appChild: Child\n    }\n}\n```\n\n**tooltip 组件**\n```js \nconst tooltip = {\n    template: \"#tooltip\",\n    data() {\n        return {\n            isShowing: false\n        }\n    },\n    methods: {\n        toggleShow() {\n            this.isShowing = !this.isShowing;\n        }\n    },\n    components: {\n        appChild: Child\n    }\n}\n```\n提取上面两个组件中的相同逻辑：\n```js \nconst toggle = {\n    data() {\n        return {\n            isShowing: false\n        }\n    },\n    methods: {\n        toggleShow() {\n            this.isShowing = !this.isShowing;\n        }\n    }\n}\n// Modal 组件\nconst Modal = {\n    template: \"#modal\",\n    // 使用混合\n    mixins: [toggle],\n    components: {\n        appChild；Child\n    }\n};\n\n// Tooltip组件\nconst Tooltip = {\n    template: \"#tooltip\",\n    // 使用混合\n    mixins: [toggle],\n    components: {\n        appChild: Child\n    }\n}\n```\n以上便是使用混合提取出相同的逻辑，然后在各个组件中使用的示例\n\n完整例子代码查看: [这里](https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/)\n\n## Usage\n在实际应用中，可以创建一个 **mixins** 的文件夹用于存放mixins对象，如下所示：\n![Vue mixins的文件结构](https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1496725448/toggle_ma4im5.jpg)\n\n在Modal.vue中，我们可以import mixins对象来使用它，代码如下：\n```js \nimport Child from './Child'\nimport { toggle } from './mixins/toggle'\n\nexport default {\n    name: 'modal',\n    mixins: [toggle],\n    components: {\n        appChild: Child\n    }\n}\n```\n有一点很重要：虽然mixins是一个对象，但是在里面我们仍然可以使用Vue组件的的钩子函数，例如：`mounted`, `created`。。。\n\n## 合并\n分为两种情况考虑：组件和混合对象的同名选项下的值 **不是对象** 和 **是对象**\n### 不是对象时\n**如果同名选项的值不是对象，则混合为一个数组，依次调用**\n\n当在组件中使用mixins对象，同时，组件中和mixins对象中有同名的钩子函数，这时同名的函数会被 **混合为一个数组**，在进行调用时，它们都会被调用，但是存在一个 **调用顺序**的问题：**mixins对象上的钩子函数会比对象自身的钩子函数先调用**：\n```js \nvar mixin = {\n    created: function() {\n        console.log('混合对象的钩子被调用')\n    }\n}\n\nnew Vue({\n    mixins: [mixin],\n    created: function() {\n        console.log('组件钩子被调用')\n    }\n})\n\n// => \"混合对象的钩子被调用\"\n// => \"组件钩子被调用\"\n```\n\n### 是对象\n**如果同名选项的值是对象，则混合为同一个对象，当其中两个对象键名冲突时，取组件对象的`键值对`**\n\n```js\nvar mixin = {\n    methods: {\n        foo: function() {\n            console.log('foo')\n        },\n        conflicting: function() {\n            console.log('from mixin')\n        }\n    }\n}\n\nvar vm = new Vue({\n    mixins: [mixin],\n    methods: {\n        foo: function() {\n            console.log('from self foo')\n        },\n        bar: function() {\n            console.log('bar')\n        },\n        conflicting: function() {\n            console.log('from self')\n        }\n    }\n})\n \nvm.foo()  // => 'from self foo'\nvm.bar()  // => bar\nvm.conflicting()  // => 'from self'\n```\n如上，`vm.foo()`调用的是组件对象自身的foo\n\n\n## 全局混合\n全局混合不推荐使用，具体查看参考部分的官方教程\n\n## 自定义选项合并策略\n查看官方教程了解\n\n## 结论\n混合可以让我们封装一些小的功能模块用于重复利用，当然，高阶组件也可以实现，具体使用哪种方式，根据实际情况进行考虑，避免滥用\n\n\n## 参考: \n- [Using Mixins in Vue.js](https://css-tricks.com/using-mixins-vue-js/)\n- [Vue 混合](https://cn.vuejs.org/v2/guide/mixins.html)","slug":"Vue中使用Mixins","published":1,"updated":"2017-09-27T00:55:49.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gesr000bekri93y2mt5i","content":"<p>假设现在有这么一种情况：有两个组件，它们有很多相似之处，有相同的逻辑，同时，它们也有很多不同的点，那么是将其分割开来作为两个组件？还是作为一个组件，然后通过<code>props</code>来进行功能实现？</p>\n<p>不管选择哪种方案，都不是很完美。如果分为两个组件，那么当进行功能调整时，有可能每个组件都需要调整，增加工作量；如果合为一个组件，那么内部的逻辑会变得复杂， 不利于维护</p>\n<p><strong>Mixins</strong> 是Vue中一个很有用的功能，可以让我们编写类似于函数式编程风格的代码。<strong>Mixins</strong>允许我们 <strong>封装函数功能</strong>，以便在很多不同的组件中可以使用。如果采用正确的方式编写，它们将会是 <strong>纯函数</strong>——也就是说，它们不会更改功能范围之外的内容。</p>\n<p>更加通俗的理解就是：<strong>使用Mixins，可以将组件中公共的部分抽离出来，然后在需要使用的时候进行导入，可以精简代码，同时逻辑清晰</strong></p>\n<h2 id=\"Basic-example\"><a href=\"#Basic-example\" class=\"headerlink\" title=\"Basic example\"></a>Basic example</h2><p>现在有两个组件——<em>modal</em>和 <em>tooltip</em>，它们的主要功能是切换一个boolean类型的state，然后进行相应的显示，除了逻辑相似之外就没有什么相同点了</p>\n<p><strong>modal 组件</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Modal = &#123;</div><div class=\"line\">    template: <span class=\"string\">\"#modal\"</span>,</div><div class=\"line\">    data() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            isShowing: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        toggleShow() &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.isShowing = !<span class=\"keyword\">this</span>.isShowing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild: Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>tooltip 组件</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> tooltip = &#123;</div><div class=\"line\">    template: <span class=\"string\">\"#tooltip\"</span>,</div><div class=\"line\">    data() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            isShowing: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        toggleShow() &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.isShowing = !<span class=\"keyword\">this</span>.isShowing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild: Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>提取上面两个组件中的相同逻辑：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> toggle = &#123;</div><div class=\"line\">    data() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            isShowing: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        toggleShow() &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.isShowing = !<span class=\"keyword\">this</span>.isShowing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Modal 组件</span></div><div class=\"line\"><span class=\"keyword\">const</span> Modal = &#123;</div><div class=\"line\">    template: <span class=\"string\">\"#modal\"</span>,</div><div class=\"line\">    <span class=\"comment\">// 使用混合</span></div><div class=\"line\">    mixins: [toggle],</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild；Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Tooltip组件</span></div><div class=\"line\"><span class=\"keyword\">const</span> Tooltip = &#123;</div><div class=\"line\">    template: <span class=\"string\">\"#tooltip\"</span>,</div><div class=\"line\">    <span class=\"comment\">// 使用混合</span></div><div class=\"line\">    mixins: [toggle],</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild: Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上便是使用混合提取出相同的逻辑，然后在各个组件中使用的示例</p>\n<p>完整例子代码查看: <a href=\"https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>在实际应用中，可以创建一个 <strong>mixins</strong> 的文件夹用于存放mixins对象，如下所示：<br><img src=\"https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1496725448/toggle_ma4im5.jpg\" alt=\"Vue mixins的文件结构\"></p>\n<p>在Modal.vue中，我们可以import mixins对象来使用它，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Child <span class=\"keyword\">from</span> <span class=\"string\">'./Child'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; toggle &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mixins/toggle'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    name: <span class=\"string\">'modal'</span>,</div><div class=\"line\">    mixins: [toggle],</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild: Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有一点很重要：虽然mixins是一个对象，但是在里面我们仍然可以使用Vue组件的的钩子函数，例如：<code>mounted</code>, <code>created</code>。。。</p>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>分为两种情况考虑：组件和混合对象的同名选项下的值 <strong>不是对象</strong> 和 <strong>是对象</strong></p>\n<h3 id=\"不是对象时\"><a href=\"#不是对象时\" class=\"headerlink\" title=\"不是对象时\"></a>不是对象时</h3><p><strong>如果同名选项的值不是对象，则混合为一个数组，依次调用</strong></p>\n<p>当在组件中使用mixins对象，同时，组件中和mixins对象中有同名的钩子函数，这时同名的函数会被 <strong>混合为一个数组</strong>，在进行调用时，它们都会被调用，但是存在一个 <strong>调用顺序</strong>的问题：<strong>mixins对象上的钩子函数会比对象自身的钩子函数先调用</strong>：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">    created: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'混合对象的钩子被调用'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    mixins: [mixin],</div><div class=\"line\">    created: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'组件钩子被调用'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// =&gt; \"混合对象的钩子被调用\"</span></div><div class=\"line\"><span class=\"comment\">// =&gt; \"组件钩子被调用\"</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"是对象\"><a href=\"#是对象\" class=\"headerlink\" title=\"是对象\"></a>是对象</h3><p><strong>如果同名选项的值是对象，则混合为同一个对象，当其中两个对象键名冲突时，取组件对象的<code>键值对</code></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>)</div><div class=\"line\">        &#125;,</div><div class=\"line\">        conflicting: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'from mixin'</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    mixins: [mixin],</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'from self foo'</span>)</div><div class=\"line\">        &#125;,</div><div class=\"line\">        bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>)</div><div class=\"line\">        &#125;,</div><div class=\"line\">        conflicting: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'from self'</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"> </div><div class=\"line\">vm.foo()  <span class=\"comment\">// =&gt; 'from self foo'</span></div><div class=\"line\">vm.bar()  <span class=\"comment\">// =&gt; bar</span></div><div class=\"line\">vm.conflicting()  <span class=\"comment\">// =&gt; 'from self'</span></div></pre></td></tr></table></figure>\n<p>如上，<code>vm.foo()</code>调用的是组件对象自身的foo</p>\n<h2 id=\"全局混合\"><a href=\"#全局混合\" class=\"headerlink\" title=\"全局混合\"></a>全局混合</h2><p>全局混合不推荐使用，具体查看参考部分的官方教程</p>\n<h2 id=\"自定义选项合并策略\"><a href=\"#自定义选项合并策略\" class=\"headerlink\" title=\"自定义选项合并策略\"></a>自定义选项合并策略</h2><p>查看官方教程了解</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>混合可以让我们封装一些小的功能模块用于重复利用，当然，高阶组件也可以实现，具体使用哪种方式，根据实际情况进行考虑，避免滥用</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h2><ul>\n<li><a href=\"https://css-tricks.com/using-mixins-vue-js/\" target=\"_blank\" rel=\"external\">Using Mixins in Vue.js</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/mixins.html\" target=\"_blank\" rel=\"external\">Vue 混合</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>假设现在有这么一种情况：有两个组件，它们有很多相似之处，有相同的逻辑，同时，它们也有很多不同的点，那么是将其分割开来作为两个组件？还是作为一个组件，然后通过<code>props</code>来进行功能实现？</p>\n<p>不管选择哪种方案，都不是很完美。如果分为两个组件，那么当进行功能调整时，有可能每个组件都需要调整，增加工作量；如果合为一个组件，那么内部的逻辑会变得复杂， 不利于维护</p>\n<p><strong>Mixins</strong> 是Vue中一个很有用的功能，可以让我们编写类似于函数式编程风格的代码。<strong>Mixins</strong>允许我们 <strong>封装函数功能</strong>，以便在很多不同的组件中可以使用。如果采用正确的方式编写，它们将会是 <strong>纯函数</strong>——也就是说，它们不会更改功能范围之外的内容。</p>\n<p>更加通俗的理解就是：<strong>使用Mixins，可以将组件中公共的部分抽离出来，然后在需要使用的时候进行导入，可以精简代码，同时逻辑清晰</strong></p>\n<h2 id=\"Basic-example\"><a href=\"#Basic-example\" class=\"headerlink\" title=\"Basic example\"></a>Basic example</h2><p>现在有两个组件——<em>modal</em>和 <em>tooltip</em>，它们的主要功能是切换一个boolean类型的state，然后进行相应的显示，除了逻辑相似之外就没有什么相同点了</p>\n<p><strong>modal 组件</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Modal = &#123;</div><div class=\"line\">    template: <span class=\"string\">\"#modal\"</span>,</div><div class=\"line\">    data() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            isShowing: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        toggleShow() &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.isShowing = !<span class=\"keyword\">this</span>.isShowing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild: Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>tooltip 组件</strong><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> tooltip = &#123;</div><div class=\"line\">    template: <span class=\"string\">\"#tooltip\"</span>,</div><div class=\"line\">    data() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            isShowing: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        toggleShow() &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.isShowing = !<span class=\"keyword\">this</span>.isShowing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild: Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>提取上面两个组件中的相同逻辑：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> toggle = &#123;</div><div class=\"line\">    data() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            isShowing: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        toggleShow() &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.isShowing = !<span class=\"keyword\">this</span>.isShowing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Modal 组件</span></div><div class=\"line\"><span class=\"keyword\">const</span> Modal = &#123;</div><div class=\"line\">    template: <span class=\"string\">\"#modal\"</span>,</div><div class=\"line\">    <span class=\"comment\">// 使用混合</span></div><div class=\"line\">    mixins: [toggle],</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild；Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Tooltip组件</span></div><div class=\"line\"><span class=\"keyword\">const</span> Tooltip = &#123;</div><div class=\"line\">    template: <span class=\"string\">\"#tooltip\"</span>,</div><div class=\"line\">    <span class=\"comment\">// 使用混合</span></div><div class=\"line\">    mixins: [toggle],</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild: Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上便是使用混合提取出相同的逻辑，然后在各个组件中使用的示例</p>\n<p>完整例子代码查看: <a href=\"https://codepen.io/sdras/pen/101a5d737b31591e5801c60b666013db/\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>在实际应用中，可以创建一个 <strong>mixins</strong> 的文件夹用于存放mixins对象，如下所示：<br><img src=\"https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1496725448/toggle_ma4im5.jpg\" alt=\"Vue mixins的文件结构\"></p>\n<p>在Modal.vue中，我们可以import mixins对象来使用它，代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Child <span class=\"keyword\">from</span> <span class=\"string\">'./Child'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; toggle &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mixins/toggle'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    name: <span class=\"string\">'modal'</span>,</div><div class=\"line\">    mixins: [toggle],</div><div class=\"line\">    components: &#123;</div><div class=\"line\">        appChild: Child</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有一点很重要：虽然mixins是一个对象，但是在里面我们仍然可以使用Vue组件的的钩子函数，例如：<code>mounted</code>, <code>created</code>。。。</p>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>分为两种情况考虑：组件和混合对象的同名选项下的值 <strong>不是对象</strong> 和 <strong>是对象</strong></p>\n<h3 id=\"不是对象时\"><a href=\"#不是对象时\" class=\"headerlink\" title=\"不是对象时\"></a>不是对象时</h3><p><strong>如果同名选项的值不是对象，则混合为一个数组，依次调用</strong></p>\n<p>当在组件中使用mixins对象，同时，组件中和mixins对象中有同名的钩子函数，这时同名的函数会被 <strong>混合为一个数组</strong>，在进行调用时，它们都会被调用，但是存在一个 <strong>调用顺序</strong>的问题：<strong>mixins对象上的钩子函数会比对象自身的钩子函数先调用</strong>：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">    created: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'混合对象的钩子被调用'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    mixins: [mixin],</div><div class=\"line\">    created: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'组件钩子被调用'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// =&gt; \"混合对象的钩子被调用\"</span></div><div class=\"line\"><span class=\"comment\">// =&gt; \"组件钩子被调用\"</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"是对象\"><a href=\"#是对象\" class=\"headerlink\" title=\"是对象\"></a>是对象</h3><p><strong>如果同名选项的值是对象，则混合为同一个对象，当其中两个对象键名冲突时，取组件对象的<code>键值对</code></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mixin = &#123;</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>)</div><div class=\"line\">        &#125;,</div><div class=\"line\">        conflicting: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'from mixin'</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    mixins: [mixin],</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'from self foo'</span>)</div><div class=\"line\">        &#125;,</div><div class=\"line\">        bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>)</div><div class=\"line\">        &#125;,</div><div class=\"line\">        conflicting: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'from self'</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"> </div><div class=\"line\">vm.foo()  <span class=\"comment\">// =&gt; 'from self foo'</span></div><div class=\"line\">vm.bar()  <span class=\"comment\">// =&gt; bar</span></div><div class=\"line\">vm.conflicting()  <span class=\"comment\">// =&gt; 'from self'</span></div></pre></td></tr></table></figure>\n<p>如上，<code>vm.foo()</code>调用的是组件对象自身的foo</p>\n<h2 id=\"全局混合\"><a href=\"#全局混合\" class=\"headerlink\" title=\"全局混合\"></a>全局混合</h2><p>全局混合不推荐使用，具体查看参考部分的官方教程</p>\n<h2 id=\"自定义选项合并策略\"><a href=\"#自定义选项合并策略\" class=\"headerlink\" title=\"自定义选项合并策略\"></a>自定义选项合并策略</h2><p>查看官方教程了解</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>混合可以让我们封装一些小的功能模块用于重复利用，当然，高阶组件也可以实现，具体使用哪种方式，根据实际情况进行考虑，避免滥用</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考:\"></a>参考:</h2><ul>\n<li><a href=\"https://css-tricks.com/using-mixins-vue-js/\" target=\"_blank\" rel=\"external\">Using Mixins in Vue.js</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/guide/mixins.html\" target=\"_blank\" rel=\"external\">Vue 混合</a></li>\n</ul>\n"},{"title":"Vue-Router-进阶","date":"2017-09-27T09:40:12.000Z","_content":"## 导航钩子\n导航钩子主要作用就是可以让我们跟踪导航跳转的每一个步骤，可以类比于Vue组件的钩子函数。\n官方说明：`Vue-Router`提供的导航钩子主要用来 **拦截导航**，让它 **完成或取消**。 有多种方式可以在 **路由导航发生时**执行钩子：**全局的**、**单个路由独享的**，或者 **组件级的**。\n\n\n### 导航的过程\n一个导航的发生，主要经过如下步骤：\n1. Navigation triggered (导航触发)\n2. Call leave guards in deactive components (调用将要离开的路由组件上的`beforeRouteLeave`方法)\n3. Call global **beforeEach** guards (调用全局钩子：`beforeEach`)\n4. Call **beforeRouteUpdate** guards in reused components(2.2+) (如果跳转的是同一个组件上，也就是进行组件更新，那么就调用`beforeRouteUpdate`方法)\n5. Call **beforeEnter** in **route config** (调用将要进入的路由对象中的`beforeEnter`方法)\n6. Resolve async route components\n7. Call **beforeRouteEnter** in activated components\n8. Call global **beforeResolve** guards(2.5+)\n9. Navigation confirmed.\n10. Call global **afterEach** hooks.\n11. DOM updates triggered.\n12. Call callbacks passed to next in **beforeRouteEnter** guards with instantiated instances.\n\n### 钩子类型\n#### 全局钩子\n- **beforeEach()**\n- **afterEach()**\n- **beforeResolve()**\n这些钩子函数是在 `router`对象上使用的\n\n#### 路由对象的钩子\n- **beforeEnter()**\n该钩子函数是在被定义的路由对象上使用的\n\n#### 组件内的钩子\n也就是说你可以在Vue组件内使用的路由钩子\n- **beforeRouteEnter()**\n- **beforeRouteUpdate()**\n- **beforeRouteLeave()**\n\n```js \nconst Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当钩子执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n```\n\n需要注意的是：**`beforeRouteEnter`钩子不能访问`this`，因为钩子在导航确认前被调用，因此，因此即将登场的`新组件`还没有被创建**\n\n不过，你可以通过传一个回调给 `next`来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。\n```js \nbeforeRouteEnter(to, from, next) {\n    next(vm => {\n        // 通过 `vm` 访问组件实例\n    })\n} \n```\n\n**注意：**可以在`beforeRouteLeave`中直接访问`this`。该钩子通常用来**阻止用户在还没有保存修改前突然离开。可以通过`next(false)`来取消导航\n\n### 实例代码\n```html \n<div id=\"app\">\n  <h1>Vue的导航钩子</h1>\n  <nav class=\"mainNav\">\n    <router-link :to=\"{ name: 'home'}\">Home</router-link>\n    \n    <router-link :to=\"{ name: 'user', params: { userId: 123, userName: 'Test User 1'}}\">User 123</router-link>\n    \n    <router-link :to=\"{ name: 'user', params: { userId: 456, userName: 'Test User 2'}}\">User 456</router-link>\n    \n    <router-link :to=\"{ name: 'user', params: { userId: 789, userName: 'Test User3'}}\">User 789</router-link>\n    \n    <router-link to=\"/bar\">Bar</router-link>\n    \n    <router-link to=\"/foo\">Foo</router-link>\n    \n    <router-link to=\"/error\">Error</router-link>\n  </nav>\n  \n  <section class=\"mainBody\">\n    <router-view></router-view>\n  </section>\n</div>\n```\n\n```css \n#app {\n  max-width: 800px;\n  margin: auto;\n}\n\ncode {\n  background: #f2f2f2;\n  padding: 0 0.5rem;\n}\n\n.mainBody {\n  border-top: 1px solid #ddd;\n  border-bottom: 1px solid #ddd;\n  margin: 1rem 0;\n  padding: 1rem 0;\n}\n\nnav.mainNav {\n  > * {\n    padding: 0 0.75rem;\n    text-decoration: none;\n  }\n  \n  > *:nth-last-child(n+2) {\n    border-right: 1px solid #aaa;\n  }\n}\n```\n\n```js \nconst Home = {\n  template: `\n    <section>This is the home screen.</section>\n  `\n} \n\nconst Foo = {\n  template: `\n    <section>You will not see this template when Foo is redirected to Home.</section>\n  `\n} \n\nconst Err = {\n  template: `\n    <section>\n      You will not see this template. The error is passed to our error handler.\n    </section>\n  `\n} \n\nconst Bar = {\n  template: `\n    <section>\n      <div>Bar</div>\n    </section>\n  `,\n  beforeRouteEnter(to, from, next) {\n    console.log('Entering Bar');\n    \n    next(vm => {\n      vm.testFunc('Some Message');\n      console.log('Fully Entered Bar')\n    })\n  },\n  \n  beforeRouteLeave( to, from, next) {\n    console.log('leaving Bar');\n    next()\n  },\n  methods: {\n    testFunc(msg) {\n      console.log(msg)\n    }\n  }\n}\n\nconst User = {\n  props: ['userId', 'userName'],\n  template: `\n    <div>\n      User - {{userName}}({{userId}})\n    </div>\n  `,\n  \n  beforeRouteLeave( to, from, next) {\n    console.log('Leaving User')\n    next()\n  },\n  \n  beforeRouteUpdate( to, from, next) {\n    console.log('Reusing this component.')\n    next()\n  }\n};\n\nconst routes = [\n  {path: '/', name: 'home', component: Home},\n  {path: '/bar', name: 'bar', component: Bar},\n  {path: '/foo', name: 'foo', component: Foo},\n  {path: '/error', name: 'error', component: Err},\n  {\n    path: '/user/:userId',\n    name: 'user',\n    component: User,\n    props: true,\n    beforeEnter: (to, from, next)=>{\n      console.log('Entering User')\n      next()\n    }\n  }\n]\n\nconst router = new VueRouter({\n  routes\n})\n\nrouter.beforeEach(( to, from , next) => {\n  console.log('beforeEach')\n  // re-route\n  if (to.path === '/foo') {\n    next('/')\n  } else if (to.path === '/user/123') {\n    next(false)\n  } else if (to.path === '/error') {\n    const err = new Error('My Error Message')\n    next(err)\n  } else {\n    next()\n  }\n})\n\nrouter.afterEach((to, from) => {\n  console.log(`Just moved from '${from.path}' to '${to.path}' `)\n})\n\nrouter.beforeResolve(() => {\n  console.log('beforeResolve')\n})\nrouter.onError(err => {\n  console.log('Handing this error', err)\n})\n\nconst app = new Vue({\n  router \n}).$mount('#app')\n\n```\n\n**最主要的是理解导航的全过程，以及在各个阶段被调用钩子函数，再根据实际情况进行应用就可以了，类似于Vue组件的钩子函数(如：`created()`, `mounted()`等等)，其中`next()`方法非常重要，需要注意下**\n \n\n\n### 参考\n- [Vue Router Navigation Guards Explained](http://patrickwho.me/learn-vue-router-navigation-guards-quickly/)\n- [Vue-Router 导航钩子](https://router.vuejs.org/zh-cn/advanced/navigation-guards.html)\n[实验代码](http://js.jirengu.com/picuy/1#/)","source":"_posts/Vue-Router-进阶.md","raw":"---\ntitle: Vue-Router-进阶\ndate: 2017-09-27 17:40:12\ncategories:\ntags: Vue-Router\n---\n## 导航钩子\n导航钩子主要作用就是可以让我们跟踪导航跳转的每一个步骤，可以类比于Vue组件的钩子函数。\n官方说明：`Vue-Router`提供的导航钩子主要用来 **拦截导航**，让它 **完成或取消**。 有多种方式可以在 **路由导航发生时**执行钩子：**全局的**、**单个路由独享的**，或者 **组件级的**。\n\n\n### 导航的过程\n一个导航的发生，主要经过如下步骤：\n1. Navigation triggered (导航触发)\n2. Call leave guards in deactive components (调用将要离开的路由组件上的`beforeRouteLeave`方法)\n3. Call global **beforeEach** guards (调用全局钩子：`beforeEach`)\n4. Call **beforeRouteUpdate** guards in reused components(2.2+) (如果跳转的是同一个组件上，也就是进行组件更新，那么就调用`beforeRouteUpdate`方法)\n5. Call **beforeEnter** in **route config** (调用将要进入的路由对象中的`beforeEnter`方法)\n6. Resolve async route components\n7. Call **beforeRouteEnter** in activated components\n8. Call global **beforeResolve** guards(2.5+)\n9. Navigation confirmed.\n10. Call global **afterEach** hooks.\n11. DOM updates triggered.\n12. Call callbacks passed to next in **beforeRouteEnter** guards with instantiated instances.\n\n### 钩子类型\n#### 全局钩子\n- **beforeEach()**\n- **afterEach()**\n- **beforeResolve()**\n这些钩子函数是在 `router`对象上使用的\n\n#### 路由对象的钩子\n- **beforeEnter()**\n该钩子函数是在被定义的路由对象上使用的\n\n#### 组件内的钩子\n也就是说你可以在Vue组件内使用的路由钩子\n- **beforeRouteEnter()**\n- **beforeRouteUpdate()**\n- **beforeRouteLeave()**\n\n```js \nconst Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当钩子执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n```\n\n需要注意的是：**`beforeRouteEnter`钩子不能访问`this`，因为钩子在导航确认前被调用，因此，因此即将登场的`新组件`还没有被创建**\n\n不过，你可以通过传一个回调给 `next`来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。\n```js \nbeforeRouteEnter(to, from, next) {\n    next(vm => {\n        // 通过 `vm` 访问组件实例\n    })\n} \n```\n\n**注意：**可以在`beforeRouteLeave`中直接访问`this`。该钩子通常用来**阻止用户在还没有保存修改前突然离开。可以通过`next(false)`来取消导航\n\n### 实例代码\n```html \n<div id=\"app\">\n  <h1>Vue的导航钩子</h1>\n  <nav class=\"mainNav\">\n    <router-link :to=\"{ name: 'home'}\">Home</router-link>\n    \n    <router-link :to=\"{ name: 'user', params: { userId: 123, userName: 'Test User 1'}}\">User 123</router-link>\n    \n    <router-link :to=\"{ name: 'user', params: { userId: 456, userName: 'Test User 2'}}\">User 456</router-link>\n    \n    <router-link :to=\"{ name: 'user', params: { userId: 789, userName: 'Test User3'}}\">User 789</router-link>\n    \n    <router-link to=\"/bar\">Bar</router-link>\n    \n    <router-link to=\"/foo\">Foo</router-link>\n    \n    <router-link to=\"/error\">Error</router-link>\n  </nav>\n  \n  <section class=\"mainBody\">\n    <router-view></router-view>\n  </section>\n</div>\n```\n\n```css \n#app {\n  max-width: 800px;\n  margin: auto;\n}\n\ncode {\n  background: #f2f2f2;\n  padding: 0 0.5rem;\n}\n\n.mainBody {\n  border-top: 1px solid #ddd;\n  border-bottom: 1px solid #ddd;\n  margin: 1rem 0;\n  padding: 1rem 0;\n}\n\nnav.mainNav {\n  > * {\n    padding: 0 0.75rem;\n    text-decoration: none;\n  }\n  \n  > *:nth-last-child(n+2) {\n    border-right: 1px solid #aaa;\n  }\n}\n```\n\n```js \nconst Home = {\n  template: `\n    <section>This is the home screen.</section>\n  `\n} \n\nconst Foo = {\n  template: `\n    <section>You will not see this template when Foo is redirected to Home.</section>\n  `\n} \n\nconst Err = {\n  template: `\n    <section>\n      You will not see this template. The error is passed to our error handler.\n    </section>\n  `\n} \n\nconst Bar = {\n  template: `\n    <section>\n      <div>Bar</div>\n    </section>\n  `,\n  beforeRouteEnter(to, from, next) {\n    console.log('Entering Bar');\n    \n    next(vm => {\n      vm.testFunc('Some Message');\n      console.log('Fully Entered Bar')\n    })\n  },\n  \n  beforeRouteLeave( to, from, next) {\n    console.log('leaving Bar');\n    next()\n  },\n  methods: {\n    testFunc(msg) {\n      console.log(msg)\n    }\n  }\n}\n\nconst User = {\n  props: ['userId', 'userName'],\n  template: `\n    <div>\n      User - {{userName}}({{userId}})\n    </div>\n  `,\n  \n  beforeRouteLeave( to, from, next) {\n    console.log('Leaving User')\n    next()\n  },\n  \n  beforeRouteUpdate( to, from, next) {\n    console.log('Reusing this component.')\n    next()\n  }\n};\n\nconst routes = [\n  {path: '/', name: 'home', component: Home},\n  {path: '/bar', name: 'bar', component: Bar},\n  {path: '/foo', name: 'foo', component: Foo},\n  {path: '/error', name: 'error', component: Err},\n  {\n    path: '/user/:userId',\n    name: 'user',\n    component: User,\n    props: true,\n    beforeEnter: (to, from, next)=>{\n      console.log('Entering User')\n      next()\n    }\n  }\n]\n\nconst router = new VueRouter({\n  routes\n})\n\nrouter.beforeEach(( to, from , next) => {\n  console.log('beforeEach')\n  // re-route\n  if (to.path === '/foo') {\n    next('/')\n  } else if (to.path === '/user/123') {\n    next(false)\n  } else if (to.path === '/error') {\n    const err = new Error('My Error Message')\n    next(err)\n  } else {\n    next()\n  }\n})\n\nrouter.afterEach((to, from) => {\n  console.log(`Just moved from '${from.path}' to '${to.path}' `)\n})\n\nrouter.beforeResolve(() => {\n  console.log('beforeResolve')\n})\nrouter.onError(err => {\n  console.log('Handing this error', err)\n})\n\nconst app = new Vue({\n  router \n}).$mount('#app')\n\n```\n\n**最主要的是理解导航的全过程，以及在各个阶段被调用钩子函数，再根据实际情况进行应用就可以了，类似于Vue组件的钩子函数(如：`created()`, `mounted()`等等)，其中`next()`方法非常重要，需要注意下**\n \n\n\n### 参考\n- [Vue Router Navigation Guards Explained](http://patrickwho.me/learn-vue-router-navigation-guards-quickly/)\n- [Vue-Router 导航钩子](https://router.vuejs.org/zh-cn/advanced/navigation-guards.html)\n[实验代码](http://js.jirengu.com/picuy/1#/)","slug":"Vue-Router-进阶","published":1,"updated":"2017-09-27T11:41:58.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gesu000dekrigd05qr8s","content":"<h2 id=\"导航钩子\"><a href=\"#导航钩子\" class=\"headerlink\" title=\"导航钩子\"></a>导航钩子</h2><p>导航钩子主要作用就是可以让我们跟踪导航跳转的每一个步骤，可以类比于Vue组件的钩子函数。<br>官方说明：<code>Vue-Router</code>提供的导航钩子主要用来 <strong>拦截导航</strong>，让它 <strong>完成或取消</strong>。 有多种方式可以在 <strong>路由导航发生时</strong>执行钩子：<strong>全局的</strong>、<strong>单个路由独享的</strong>，或者 <strong>组件级的</strong>。</p>\n<h3 id=\"导航的过程\"><a href=\"#导航的过程\" class=\"headerlink\" title=\"导航的过程\"></a>导航的过程</h3><p>一个导航的发生，主要经过如下步骤：</p>\n<ol>\n<li>Navigation triggered (导航触发)</li>\n<li>Call leave guards in deactive components (调用将要离开的路由组件上的<code>beforeRouteLeave</code>方法)</li>\n<li>Call global <strong>beforeEach</strong> guards (调用全局钩子：<code>beforeEach</code>)</li>\n<li>Call <strong>beforeRouteUpdate</strong> guards in reused components(2.2+) (如果跳转的是同一个组件上，也就是进行组件更新，那么就调用<code>beforeRouteUpdate</code>方法)</li>\n<li>Call <strong>beforeEnter</strong> in <strong>route config</strong> (调用将要进入的路由对象中的<code>beforeEnter</code>方法)</li>\n<li>Resolve async route components</li>\n<li>Call <strong>beforeRouteEnter</strong> in activated components</li>\n<li>Call global <strong>beforeResolve</strong> guards(2.5+)</li>\n<li>Navigation confirmed.</li>\n<li>Call global <strong>afterEach</strong> hooks.</li>\n<li>DOM updates triggered.</li>\n<li>Call callbacks passed to next in <strong>beforeRouteEnter</strong> guards with instantiated instances.</li>\n</ol>\n<h3 id=\"钩子类型\"><a href=\"#钩子类型\" class=\"headerlink\" title=\"钩子类型\"></a>钩子类型</h3><h4 id=\"全局钩子\"><a href=\"#全局钩子\" class=\"headerlink\" title=\"全局钩子\"></a>全局钩子</h4><ul>\n<li><strong>beforeEach()</strong></li>\n<li><strong>afterEach()</strong></li>\n<li><strong>beforeResolve()</strong><br>这些钩子函数是在 <code>router</code>对象上使用的</li>\n</ul>\n<h4 id=\"路由对象的钩子\"><a href=\"#路由对象的钩子\" class=\"headerlink\" title=\"路由对象的钩子\"></a>路由对象的钩子</h4><ul>\n<li><strong>beforeEnter()</strong><br>该钩子函数是在被定义的路由对象上使用的</li>\n</ul>\n<h4 id=\"组件内的钩子\"><a href=\"#组件内的钩子\" class=\"headerlink\" title=\"组件内的钩子\"></a>组件内的钩子</h4><p>也就是说你可以在Vue组件内使用的路由钩子</p>\n<ul>\n<li><strong>beforeRouteEnter()</strong></li>\n<li><strong>beforeRouteUpdate()</strong></li>\n<li><strong>beforeRouteLeave()</strong></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Foo = &#123;</div><div class=\"line\">  template: <span class=\"string\">`...`</span>,</div><div class=\"line\">  beforeRouteEnter (to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"comment\">// 在渲染该组件的对应路由被 confirm 前调用</span></div><div class=\"line\">    <span class=\"comment\">// 不！能！获取组件实例 `this`</span></div><div class=\"line\">    <span class=\"comment\">// 因为当钩子执行前，组件实例还没被创建</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  beforeRouteUpdate (to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"comment\">// 在当前路由改变，但是该组件被复用时调用</span></div><div class=\"line\">    <span class=\"comment\">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></div><div class=\"line\">    <span class=\"comment\">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></div><div class=\"line\">    <span class=\"comment\">// 可以访问组件实例 `this`</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  beforeRouteLeave (to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"comment\">// 导航离开该组件的对应路由时调用</span></div><div class=\"line\">    <span class=\"comment\">// 可以访问组件实例 `this`</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是：<strong><code>beforeRouteEnter</code>钩子不能访问<code>this</code>，因为钩子在导航确认前被调用，因此，因此即将登场的<code>新组件</code>还没有被创建</strong></p>\n<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">beforeRouteEnter(to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    next(<span class=\"function\"><span class=\"params\">vm</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 通过 `vm` 访问组件实例</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong>可以在<code>beforeRouteLeave</code>中直接访问<code>this</code>。该钩子通常用来**阻止用户在还没有保存修改前突然离开。可以通过<code>next(false)</code>来取消导航</p>\n<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Vue的导航钩子<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mainNav\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'home'&#125;\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'user', params: &#123; userId: 123, userName: 'Test User 1'&#125;&#125;\"</span>&gt;</span>User 123<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'user', params: &#123; userId: 456, userName: 'Test User 2'&#125;&#125;\"</span>&gt;</span>User 456<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'user', params: &#123; userId: 789, userName: 'Test User3'&#125;&#125;\"</span>&gt;</span>User 789<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bar\"</span>&gt;</span>Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/foo\"</span>&gt;</span>Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/error\"</span>&gt;</span>Error<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mainBody\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#app</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">800px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: auto;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">code</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f2f2f2</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">0.5rem</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.mainBody</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ddd</span>;</div><div class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ddd</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">1rem</span> <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1rem</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">nav</span><span class=\"selector-class\">.mainNav</span> &#123;</div><div class=\"line\">  &gt; * &#123;</div><div class=\"line\">    <span class=\"selector-tag\">padding</span>: 0 0<span class=\"selector-class\">.75rem</span>;</div><div class=\"line\">    <span class=\"selector-tag\">text-decoration</span>: <span class=\"selector-tag\">none</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  &gt; *<span class=\"selector-pseudo\">:nth-last-child(n+2)</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#aaa</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Home = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;section&gt;This is the home screen.&lt;/section&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Foo = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;section&gt;You will not see this template when Foo is redirected to Home.&lt;/section&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Err = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;section&gt;</span></div><div class=\"line\"><span class=\"string\">      You will not see this template. The error is passed to our error handler.</span></div><div class=\"line\"><span class=\"string\">    &lt;/section&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Bar = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;section&gt;</span></div><div class=\"line\"><span class=\"string\">      &lt;div&gt;Bar&lt;/div&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;/section&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span>,</div><div class=\"line\">  beforeRouteEnter(to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Entering Bar'</span>);</div><div class=\"line\">    </div><div class=\"line\">    next(<span class=\"function\"><span class=\"params\">vm</span> =&gt;</span> &#123;</div><div class=\"line\">      vm.testFunc(<span class=\"string\">'Some Message'</span>);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Fully Entered Bar'</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  beforeRouteLeave( to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'leaving Bar'</span>);</div><div class=\"line\">    next()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    testFunc(msg) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(msg)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> User = &#123;</div><div class=\"line\">  props: [<span class=\"string\">'userId'</span>, <span class=\"string\">'userName'</span>],</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;div&gt;</span></div><div class=\"line\"><span class=\"string\">      User - &#123;&#123;userName&#125;&#125;(&#123;&#123;userId&#125;&#125;)</span></div><div class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span>,</div><div class=\"line\">  </div><div class=\"line\">  beforeRouteLeave( to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Leaving User'</span>)</div><div class=\"line\">    next()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  beforeRouteUpdate( to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Reusing this component.'</span>)</div><div class=\"line\">    next()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> routes = [</div><div class=\"line\">  &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'home'</span>, <span class=\"attr\">component</span>: Home&#125;,</div><div class=\"line\">  &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/bar'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">component</span>: Bar&#125;,</div><div class=\"line\">  &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">component</span>: Foo&#125;,</div><div class=\"line\">  &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/error'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'error'</span>, <span class=\"attr\">component</span>: Err&#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    path: <span class=\"string\">'/user/:userId'</span>,</div><div class=\"line\">    name: <span class=\"string\">'user'</span>,</div><div class=\"line\">    component: User,</div><div class=\"line\">    props: <span class=\"literal\">true</span>,</div><div class=\"line\">    beforeEnter: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>)=&gt;</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Entering User'</span>)</div><div class=\"line\">      next()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  routes</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">router.beforeEach(<span class=\"function\">(<span class=\"params\"> to, <span class=\"keyword\">from</span> , next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'beforeEach'</span>)</div><div class=\"line\">  <span class=\"comment\">// re-route</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (to.path === <span class=\"string\">'/foo'</span>) &#123;</div><div class=\"line\">    next(<span class=\"string\">'/'</span>)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (to.path === <span class=\"string\">'/user/123'</span>) &#123;</div><div class=\"line\">    next(<span class=\"literal\">false</span>)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (to.path === <span class=\"string\">'/error'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'My Error Message'</span>)</div><div class=\"line\">    next(err)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    next()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">router.afterEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span></span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Just moved from '<span class=\"subst\">$&#123;<span class=\"keyword\">from</span>.path&#125;</span>' to '<span class=\"subst\">$&#123;to.path&#125;</span>' `</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">router.beforeResolve(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'beforeResolve'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\">router.onError(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Handing this error'</span>, err)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  router </div><div class=\"line\">&#125;).$mount(<span class=\"string\">'#app'</span>)</div></pre></td></tr></table></figure>\n<p><strong>最主要的是理解导航的全过程，以及在各个阶段被调用钩子函数，再根据实际情况进行应用就可以了，类似于Vue组件的钩子函数(如：<code>created()</code>, <code>mounted()</code>等等)，其中<code>next()</code>方法非常重要，需要注意下</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://patrickwho.me/learn-vue-router-navigation-guards-quickly/\" target=\"_blank\" rel=\"external\">Vue Router Navigation Guards Explained</a></li>\n<li><a href=\"https://router.vuejs.org/zh-cn/advanced/navigation-guards.html\" target=\"_blank\" rel=\"external\">Vue-Router 导航钩子</a><br><a href=\"http://js.jirengu.com/picuy/1#/\" target=\"_blank\" rel=\"external\">实验代码</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"导航钩子\"><a href=\"#导航钩子\" class=\"headerlink\" title=\"导航钩子\"></a>导航钩子</h2><p>导航钩子主要作用就是可以让我们跟踪导航跳转的每一个步骤，可以类比于Vue组件的钩子函数。<br>官方说明：<code>Vue-Router</code>提供的导航钩子主要用来 <strong>拦截导航</strong>，让它 <strong>完成或取消</strong>。 有多种方式可以在 <strong>路由导航发生时</strong>执行钩子：<strong>全局的</strong>、<strong>单个路由独享的</strong>，或者 <strong>组件级的</strong>。</p>\n<h3 id=\"导航的过程\"><a href=\"#导航的过程\" class=\"headerlink\" title=\"导航的过程\"></a>导航的过程</h3><p>一个导航的发生，主要经过如下步骤：</p>\n<ol>\n<li>Navigation triggered (导航触发)</li>\n<li>Call leave guards in deactive components (调用将要离开的路由组件上的<code>beforeRouteLeave</code>方法)</li>\n<li>Call global <strong>beforeEach</strong> guards (调用全局钩子：<code>beforeEach</code>)</li>\n<li>Call <strong>beforeRouteUpdate</strong> guards in reused components(2.2+) (如果跳转的是同一个组件上，也就是进行组件更新，那么就调用<code>beforeRouteUpdate</code>方法)</li>\n<li>Call <strong>beforeEnter</strong> in <strong>route config</strong> (调用将要进入的路由对象中的<code>beforeEnter</code>方法)</li>\n<li>Resolve async route components</li>\n<li>Call <strong>beforeRouteEnter</strong> in activated components</li>\n<li>Call global <strong>beforeResolve</strong> guards(2.5+)</li>\n<li>Navigation confirmed.</li>\n<li>Call global <strong>afterEach</strong> hooks.</li>\n<li>DOM updates triggered.</li>\n<li>Call callbacks passed to next in <strong>beforeRouteEnter</strong> guards with instantiated instances.</li>\n</ol>\n<h3 id=\"钩子类型\"><a href=\"#钩子类型\" class=\"headerlink\" title=\"钩子类型\"></a>钩子类型</h3><h4 id=\"全局钩子\"><a href=\"#全局钩子\" class=\"headerlink\" title=\"全局钩子\"></a>全局钩子</h4><ul>\n<li><strong>beforeEach()</strong></li>\n<li><strong>afterEach()</strong></li>\n<li><strong>beforeResolve()</strong><br>这些钩子函数是在 <code>router</code>对象上使用的</li>\n</ul>\n<h4 id=\"路由对象的钩子\"><a href=\"#路由对象的钩子\" class=\"headerlink\" title=\"路由对象的钩子\"></a>路由对象的钩子</h4><ul>\n<li><strong>beforeEnter()</strong><br>该钩子函数是在被定义的路由对象上使用的</li>\n</ul>\n<h4 id=\"组件内的钩子\"><a href=\"#组件内的钩子\" class=\"headerlink\" title=\"组件内的钩子\"></a>组件内的钩子</h4><p>也就是说你可以在Vue组件内使用的路由钩子</p>\n<ul>\n<li><strong>beforeRouteEnter()</strong></li>\n<li><strong>beforeRouteUpdate()</strong></li>\n<li><strong>beforeRouteLeave()</strong></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Foo = &#123;</div><div class=\"line\">  template: <span class=\"string\">`...`</span>,</div><div class=\"line\">  beforeRouteEnter (to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"comment\">// 在渲染该组件的对应路由被 confirm 前调用</span></div><div class=\"line\">    <span class=\"comment\">// 不！能！获取组件实例 `this`</span></div><div class=\"line\">    <span class=\"comment\">// 因为当钩子执行前，组件实例还没被创建</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  beforeRouteUpdate (to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"comment\">// 在当前路由改变，但是该组件被复用时调用</span></div><div class=\"line\">    <span class=\"comment\">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></div><div class=\"line\">    <span class=\"comment\">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></div><div class=\"line\">    <span class=\"comment\">// 可以访问组件实例 `this`</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  beforeRouteLeave (to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"comment\">// 导航离开该组件的对应路由时调用</span></div><div class=\"line\">    <span class=\"comment\">// 可以访问组件实例 `this`</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是：<strong><code>beforeRouteEnter</code>钩子不能访问<code>this</code>，因为钩子在导航确认前被调用，因此，因此即将登场的<code>新组件</code>还没有被创建</strong></p>\n<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">beforeRouteEnter(to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    next(<span class=\"function\"><span class=\"params\">vm</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 通过 `vm` 访问组件实例</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong>可以在<code>beforeRouteLeave</code>中直接访问<code>this</code>。该钩子通常用来**阻止用户在还没有保存修改前突然离开。可以通过<code>next(false)</code>来取消导航</p>\n<h3 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Vue的导航钩子<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mainNav\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'home'&#125;\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'user', params: &#123; userId: 123, userName: 'Test User 1'&#125;&#125;\"</span>&gt;</span>User 123<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'user', params: &#123; userId: 456, userName: 'Test User 2'&#125;&#125;\"</span>&gt;</span>User 456<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123; name: 'user', params: &#123; userId: 789, userName: 'Test User3'&#125;&#125;\"</span>&gt;</span>User 789<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bar\"</span>&gt;</span>Bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/foo\"</span>&gt;</span>Foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/error\"</span>&gt;</span>Error<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">section</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mainBody\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#app</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">max-width</span>: <span class=\"number\">800px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: auto;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">code</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f2f2f2</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">0.5rem</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.mainBody</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ddd</span>;</div><div class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ddd</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">1rem</span> <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1rem</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">nav</span><span class=\"selector-class\">.mainNav</span> &#123;</div><div class=\"line\">  &gt; * &#123;</div><div class=\"line\">    <span class=\"selector-tag\">padding</span>: 0 0<span class=\"selector-class\">.75rem</span>;</div><div class=\"line\">    <span class=\"selector-tag\">text-decoration</span>: <span class=\"selector-tag\">none</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  &gt; *<span class=\"selector-pseudo\">:nth-last-child(n+2)</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#aaa</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Home = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;section&gt;This is the home screen.&lt;/section&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Foo = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;section&gt;You will not see this template when Foo is redirected to Home.&lt;/section&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Err = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;section&gt;</span></div><div class=\"line\"><span class=\"string\">      You will not see this template. The error is passed to our error handler.</span></div><div class=\"line\"><span class=\"string\">    &lt;/section&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Bar = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;section&gt;</span></div><div class=\"line\"><span class=\"string\">      &lt;div&gt;Bar&lt;/div&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;/section&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span>,</div><div class=\"line\">  beforeRouteEnter(to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Entering Bar'</span>);</div><div class=\"line\">    </div><div class=\"line\">    next(<span class=\"function\"><span class=\"params\">vm</span> =&gt;</span> &#123;</div><div class=\"line\">      vm.testFunc(<span class=\"string\">'Some Message'</span>);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Fully Entered Bar'</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  beforeRouteLeave( to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'leaving Bar'</span>);</div><div class=\"line\">    next()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    testFunc(msg) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(msg)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> User = &#123;</div><div class=\"line\">  props: [<span class=\"string\">'userId'</span>, <span class=\"string\">'userName'</span>],</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;div&gt;</span></div><div class=\"line\"><span class=\"string\">      User - &#123;&#123;userName&#125;&#125;(&#123;&#123;userId&#125;&#125;)</span></div><div class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span>,</div><div class=\"line\">  </div><div class=\"line\">  beforeRouteLeave( to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Leaving User'</span>)</div><div class=\"line\">    next()</div><div class=\"line\">  &#125;,</div><div class=\"line\">  </div><div class=\"line\">  beforeRouteUpdate( to, <span class=\"keyword\">from</span>, next) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Reusing this component.'</span>)</div><div class=\"line\">    next()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> routes = [</div><div class=\"line\">  &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'home'</span>, <span class=\"attr\">component</span>: Home&#125;,</div><div class=\"line\">  &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/bar'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">component</span>: Bar&#125;,</div><div class=\"line\">  &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">component</span>: Foo&#125;,</div><div class=\"line\">  &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/error'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'error'</span>, <span class=\"attr\">component</span>: Err&#125;,</div><div class=\"line\">  &#123;</div><div class=\"line\">    path: <span class=\"string\">'/user/:userId'</span>,</div><div class=\"line\">    name: <span class=\"string\">'user'</span>,</div><div class=\"line\">    component: User,</div><div class=\"line\">    props: <span class=\"literal\">true</span>,</div><div class=\"line\">    beforeEnter: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>)=&gt;</span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Entering User'</span>)</div><div class=\"line\">      next()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</div><div class=\"line\">  routes</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">router.beforeEach(<span class=\"function\">(<span class=\"params\"> to, <span class=\"keyword\">from</span> , next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'beforeEach'</span>)</div><div class=\"line\">  <span class=\"comment\">// re-route</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (to.path === <span class=\"string\">'/foo'</span>) &#123;</div><div class=\"line\">    next(<span class=\"string\">'/'</span>)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (to.path === <span class=\"string\">'/user/123'</span>) &#123;</div><div class=\"line\">    next(<span class=\"literal\">false</span>)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (to.path === <span class=\"string\">'/error'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> err = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'My Error Message'</span>)</div><div class=\"line\">    next(err)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    next()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">router.afterEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span></span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Just moved from '<span class=\"subst\">$&#123;<span class=\"keyword\">from</span>.path&#125;</span>' to '<span class=\"subst\">$&#123;to.path&#125;</span>' `</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">router.beforeResolve(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'beforeResolve'</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\">router.onError(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Handing this error'</span>, err)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  router </div><div class=\"line\">&#125;).$mount(<span class=\"string\">'#app'</span>)</div></pre></td></tr></table></figure>\n<p><strong>最主要的是理解导航的全过程，以及在各个阶段被调用钩子函数，再根据实际情况进行应用就可以了，类似于Vue组件的钩子函数(如：<code>created()</code>, <code>mounted()</code>等等)，其中<code>next()</code>方法非常重要，需要注意下</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://patrickwho.me/learn-vue-router-navigation-guards-quickly/\" target=\"_blank\" rel=\"external\">Vue Router Navigation Guards Explained</a></li>\n<li><a href=\"https://router.vuejs.org/zh-cn/advanced/navigation-guards.html\" target=\"_blank\" rel=\"external\">Vue-Router 导航钩子</a><br><a href=\"http://js.jirengu.com/picuy/1#/\" target=\"_blank\" rel=\"external\">实验代码</a></li>\n</ul>\n"},{"title":"Vue组件通信","date":"2017-09-25T15:01:15.000Z","_content":"Vue组件通信大致可以分为三种情况：**父→子通信**、**子→父通信**和 **非父子组件通信**\n\n## 父子通信\n**父组件通过props传递数据到子组件**\n代码如下：\n```js \nVue.component('child', {\n  template: '<p>{{ message }}</p>',\n  props: ['message']\n});\n\n```\n父组件中使用子组件，通过props输数据到子组件\n```js\n<child message=\"hello\"></child>\n```\n\n## 子组件向父组件传递数据\n**通过`v-on`绑定自定义事件来实现**，每个Vue实例都实现了 **事件接口**，即：\n- 使用`$on(eventName)`监听事件\n- 使用`$emit(eventName)`触发事件\n\n父组件可以在使用子组件的地方直接使用`v-on`来监听子组件触发的事件，**不能使用`$on`监听子组件触发的事件**\n\n例子如下：\n\n```js\n// 子组件\nVue.component('button-counter', {\n  template: '<button @click=\"incrementCounter\">{{ counter }}</button>',\n  data: function() {\n    return {\n        counter: 0\n    }\n  },\n  methods: {\n    incrementCounter: function() {\n        this.counter += 1;\n        // 触发 'increment' 事件\n        this.$emit('increment');\n    }\n  }\n});\n\nnew Vue({\n    el: \"#counter-event-example\",\n    data: {\n        total: 0\n    },\n    methods: {\n        incrementTotal: function() {\n            this.total += 1;\n        }\n    }\n})\n\n// 父组件\n<div id=\"counter-event-example\">\n    <p> {{ total }}</p>\n    // 在父组件中通过 v-on 监听increment事件，当事件触发后，调用incrementTotal方法\n    <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n    <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n```\n上面代码实现的流程：子组件要往父组件 **主动**传递消息，那么必须在子组件中调用`$emit(eventName)`触发事件，然后在父组件上通过`v-on:eventName`监听事件，当父组件监听到数据后调用相应的方法响应子组件，这样便实现了子组件向父组件传递消息\n\n参考: [使用v-on绑定自定义事件](https://cn.vuejs.org/v2/guide/components.html#使用-v-on-绑定自定义事件)\n\n## 非父子组件通信\n**原理**：通过定义一个公共的Vue实例，然后在该实例上绑定事件即可\n代码如下：\n```js\n// 全局Vue实例，通过在该实例上绑定事件，\nvar box = new Vue();\n\n// 子组件1\nvar childOne = {\n    name: 'childOne',\n    props: ['childMsg'],\n    template: '<div v-text=\"childMsg\" @click=\"commit\" class=\"msg1\"></div>',\n    data: function() {\n        return {\n            msg: \"component1\"\n        }\n    },\n    methods: {\n        commit: function() {\n            // 触发 'oneToTwo' 事件，并传递一个对象数据，childTwo订阅了该事件，因此会接收到\n            box.$emit('oneToTwo', {\n                msg: 'i am component1'\n            });\n        }\n    },\n    // 组件被挂载就定于twoToOne事件\n    mounted() {\n        // 订阅 'twoToOne' 事件，当twoToOne事件触发时，调用回调函数，twoToOne的触发事件会传递一个参数过来，将其存放在data中\n        box.$on('twoToOne', (data) => {\n            this.msg = data.msg\n         })\n    }\n};\n\n// 子组件2\nvar childTwo = {\n    name: 'childTwo',\n    props: ['childMsg'],\n    template: '<div v-text=\"msg\" @click=\"btnClick\" class=\"msg2\"></div>',\n    data: function() {\n        return {\n            msg: 'component2'\n        }\n    },\n    mounted() {\n        bus.$on('oneToTwo', (data) => {\n            this.msg = data.msg;\n        })\n    },\n    methods: {\n        btnClick: function() {\n            this.$emit('twoToOne');\n        }\n    }\n} \n```","source":"_posts/Vue组件通信.md","raw":"---\ntitle: Vue组件通信\ndate: 2017-09-25 23:01:15\ncategories:\ntags: Vue\n---\nVue组件通信大致可以分为三种情况：**父→子通信**、**子→父通信**和 **非父子组件通信**\n\n## 父子通信\n**父组件通过props传递数据到子组件**\n代码如下：\n```js \nVue.component('child', {\n  template: '<p>{{ message }}</p>',\n  props: ['message']\n});\n\n```\n父组件中使用子组件，通过props输数据到子组件\n```js\n<child message=\"hello\"></child>\n```\n\n## 子组件向父组件传递数据\n**通过`v-on`绑定自定义事件来实现**，每个Vue实例都实现了 **事件接口**，即：\n- 使用`$on(eventName)`监听事件\n- 使用`$emit(eventName)`触发事件\n\n父组件可以在使用子组件的地方直接使用`v-on`来监听子组件触发的事件，**不能使用`$on`监听子组件触发的事件**\n\n例子如下：\n\n```js\n// 子组件\nVue.component('button-counter', {\n  template: '<button @click=\"incrementCounter\">{{ counter }}</button>',\n  data: function() {\n    return {\n        counter: 0\n    }\n  },\n  methods: {\n    incrementCounter: function() {\n        this.counter += 1;\n        // 触发 'increment' 事件\n        this.$emit('increment');\n    }\n  }\n});\n\nnew Vue({\n    el: \"#counter-event-example\",\n    data: {\n        total: 0\n    },\n    methods: {\n        incrementTotal: function() {\n            this.total += 1;\n        }\n    }\n})\n\n// 父组件\n<div id=\"counter-event-example\">\n    <p> {{ total }}</p>\n    // 在父组件中通过 v-on 监听increment事件，当事件触发后，调用incrementTotal方法\n    <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n    <button-counter v-on:increment=\"incrementTotal\"></button-counter>\n</div>\n```\n上面代码实现的流程：子组件要往父组件 **主动**传递消息，那么必须在子组件中调用`$emit(eventName)`触发事件，然后在父组件上通过`v-on:eventName`监听事件，当父组件监听到数据后调用相应的方法响应子组件，这样便实现了子组件向父组件传递消息\n\n参考: [使用v-on绑定自定义事件](https://cn.vuejs.org/v2/guide/components.html#使用-v-on-绑定自定义事件)\n\n## 非父子组件通信\n**原理**：通过定义一个公共的Vue实例，然后在该实例上绑定事件即可\n代码如下：\n```js\n// 全局Vue实例，通过在该实例上绑定事件，\nvar box = new Vue();\n\n// 子组件1\nvar childOne = {\n    name: 'childOne',\n    props: ['childMsg'],\n    template: '<div v-text=\"childMsg\" @click=\"commit\" class=\"msg1\"></div>',\n    data: function() {\n        return {\n            msg: \"component1\"\n        }\n    },\n    methods: {\n        commit: function() {\n            // 触发 'oneToTwo' 事件，并传递一个对象数据，childTwo订阅了该事件，因此会接收到\n            box.$emit('oneToTwo', {\n                msg: 'i am component1'\n            });\n        }\n    },\n    // 组件被挂载就定于twoToOne事件\n    mounted() {\n        // 订阅 'twoToOne' 事件，当twoToOne事件触发时，调用回调函数，twoToOne的触发事件会传递一个参数过来，将其存放在data中\n        box.$on('twoToOne', (data) => {\n            this.msg = data.msg\n         })\n    }\n};\n\n// 子组件2\nvar childTwo = {\n    name: 'childTwo',\n    props: ['childMsg'],\n    template: '<div v-text=\"msg\" @click=\"btnClick\" class=\"msg2\"></div>',\n    data: function() {\n        return {\n            msg: 'component2'\n        }\n    },\n    mounted() {\n        bus.$on('oneToTwo', (data) => {\n            this.msg = data.msg;\n        })\n    },\n    methods: {\n        btnClick: function() {\n            this.$emit('twoToOne');\n        }\n    }\n} \n```","slug":"Vue组件通信","published":1,"updated":"2017-09-27T00:57:29.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gesx000fekrifolb11nz","content":"<p>Vue组件通信大致可以分为三种情况：<strong>父→子通信</strong>、<strong>子→父通信</strong>和 <strong>非父子组件通信</strong></p>\n<h2 id=\"父子通信\"><a href=\"#父子通信\" class=\"headerlink\" title=\"父子通信\"></a>父子通信</h2><p><strong>父组件通过props传递数据到子组件</strong><br>代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'child'</span>, &#123;</div><div class=\"line\">  template: <span class=\"string\">'&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;'</span>,</div><div class=\"line\">  props: [<span class=\"string\">'message'</span>]</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>父组件中使用子组件，通过props输数据到子组件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;child message=<span class=\"string\">\"hello\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span></div></pre></td></tr></table></figure></p>\n<h2 id=\"子组件向父组件传递数据\"><a href=\"#子组件向父组件传递数据\" class=\"headerlink\" title=\"子组件向父组件传递数据\"></a>子组件向父组件传递数据</h2><p><strong>通过<code>v-on</code>绑定自定义事件来实现</strong>，每个Vue实例都实现了 <strong>事件接口</strong>，即：</p>\n<ul>\n<li>使用<code>$on(eventName)</code>监听事件</li>\n<li>使用<code>$emit(eventName)</code>触发事件</li>\n</ul>\n<p>父组件可以在使用子组件的地方直接使用<code>v-on</code>来监听子组件触发的事件，<strong>不能使用<code>$on</code>监听子组件触发的事件</strong></p>\n<p>例子如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 子组件</span></div><div class=\"line\">Vue.component(<span class=\"string\">'button-counter'</span>, &#123;</div><div class=\"line\">  template: <span class=\"string\">'&lt;button @click=\"incrementCounter\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class=\"line\">  data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        counter: <span class=\"number\">0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    incrementCounter: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.counter += <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"comment\">// 触发 'increment' 事件</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'increment'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    el: <span class=\"string\">\"#counter-event-example\"</span>,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        total: <span class=\"number\">0</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        incrementTotal: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.total += <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 父组件</span></div><div class=\"line\">&lt;div id=<span class=\"string\">\"counter-event-example\"</span>&gt;</div><div class=\"line\">    &lt;p&gt; &#123;&#123; total &#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></div><div class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 在父组件中通过 v-on 监听increment事件，当事件触发后，调用incrementTotal方法</span></div><div class=\"line\"><span class=\"regexp\">    &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/</span>button-counter&gt;</div><div class=\"line\">    &lt;button-counter v-on:increment=<span class=\"string\">\"incrementTotal\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span></span></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>上面代码实现的流程：子组件要往父组件 <strong>主动</strong>传递消息，那么必须在子组件中调用<code>$emit(eventName)</code>触发事件，然后在父组件上通过<code>v-on:eventName</code>监听事件，当父组件监听到数据后调用相应的方法响应子组件，这样便实现了子组件向父组件传递消息</p>\n<p>参考: <a href=\"https://cn.vuejs.org/v2/guide/components.html#使用-v-on-绑定自定义事件\" target=\"_blank\" rel=\"external\">使用v-on绑定自定义事件</a></p>\n<h2 id=\"非父子组件通信\"><a href=\"#非父子组件通信\" class=\"headerlink\" title=\"非父子组件通信\"></a>非父子组件通信</h2><p><strong>原理</strong>：通过定义一个公共的Vue实例，然后在该实例上绑定事件即可<br>代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全局Vue实例，通过在该实例上绑定事件，</span></div><div class=\"line\"><span class=\"keyword\">var</span> box = <span class=\"keyword\">new</span> Vue();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 子组件1</span></div><div class=\"line\"><span class=\"keyword\">var</span> childOne = &#123;</div><div class=\"line\">    name: <span class=\"string\">'childOne'</span>,</div><div class=\"line\">    props: [<span class=\"string\">'childMsg'</span>],</div><div class=\"line\">    template: <span class=\"string\">'&lt;div v-text=\"childMsg\" @click=\"commit\" class=\"msg1\"&gt;&lt;/div&gt;'</span>,</div><div class=\"line\">    data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            msg: <span class=\"string\">\"component1\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        commit: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 触发 'oneToTwo' 事件，并传递一个对象数据，childTwo订阅了该事件，因此会接收到</span></div><div class=\"line\">            box.$emit(<span class=\"string\">'oneToTwo'</span>, &#123;</div><div class=\"line\">                msg: <span class=\"string\">'i am component1'</span></div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 组件被挂载就定于twoToOne事件</span></div><div class=\"line\">    mounted() &#123;</div><div class=\"line\">        <span class=\"comment\">// 订阅 'twoToOne' 事件，当twoToOne事件触发时，调用回调函数，twoToOne的触发事件会传递一个参数过来，将其存放在data中</span></div><div class=\"line\">        box.$on(<span class=\"string\">'twoToOne'</span>, (data) =&gt; &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.msg = data.msg</div><div class=\"line\">         &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 子组件2</span></div><div class=\"line\"><span class=\"keyword\">var</span> childTwo = &#123;</div><div class=\"line\">    name: <span class=\"string\">'childTwo'</span>,</div><div class=\"line\">    props: [<span class=\"string\">'childMsg'</span>],</div><div class=\"line\">    template: <span class=\"string\">'&lt;div v-text=\"msg\" @click=\"btnClick\" class=\"msg2\"&gt;&lt;/div&gt;'</span>,</div><div class=\"line\">    data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            msg: <span class=\"string\">'component2'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    mounted() &#123;</div><div class=\"line\">        bus.$on(<span class=\"string\">'oneToTwo'</span>, (data) =&gt; &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.msg = data.msg;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        btnClick: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'twoToOne'</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Vue组件通信大致可以分为三种情况：<strong>父→子通信</strong>、<strong>子→父通信</strong>和 <strong>非父子组件通信</strong></p>\n<h2 id=\"父子通信\"><a href=\"#父子通信\" class=\"headerlink\" title=\"父子通信\"></a>父子通信</h2><p><strong>父组件通过props传递数据到子组件</strong><br>代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.component(<span class=\"string\">'child'</span>, &#123;</div><div class=\"line\">  template: <span class=\"string\">'&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;'</span>,</div><div class=\"line\">  props: [<span class=\"string\">'message'</span>]</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>父组件中使用子组件，通过props输数据到子组件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;child message=<span class=\"string\">\"hello\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span></div></pre></td></tr></table></figure></p>\n<h2 id=\"子组件向父组件传递数据\"><a href=\"#子组件向父组件传递数据\" class=\"headerlink\" title=\"子组件向父组件传递数据\"></a>子组件向父组件传递数据</h2><p><strong>通过<code>v-on</code>绑定自定义事件来实现</strong>，每个Vue实例都实现了 <strong>事件接口</strong>，即：</p>\n<ul>\n<li>使用<code>$on(eventName)</code>监听事件</li>\n<li>使用<code>$emit(eventName)</code>触发事件</li>\n</ul>\n<p>父组件可以在使用子组件的地方直接使用<code>v-on</code>来监听子组件触发的事件，<strong>不能使用<code>$on</code>监听子组件触发的事件</strong></p>\n<p>例子如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 子组件</span></div><div class=\"line\">Vue.component(<span class=\"string\">'button-counter'</span>, &#123;</div><div class=\"line\">  template: <span class=\"string\">'&lt;button @click=\"incrementCounter\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class=\"line\">  data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        counter: <span class=\"number\">0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  methods: &#123;</div><div class=\"line\">    incrementCounter: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.counter += <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"comment\">// 触发 'increment' 事件</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'increment'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">    el: <span class=\"string\">\"#counter-event-example\"</span>,</div><div class=\"line\">    data: &#123;</div><div class=\"line\">        total: <span class=\"number\">0</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        incrementTotal: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.total += <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 父组件</span></div><div class=\"line\">&lt;div id=<span class=\"string\">\"counter-event-example\"</span>&gt;</div><div class=\"line\">    &lt;p&gt; &#123;&#123; total &#125;&#125;&lt;<span class=\"regexp\">/p&gt;</span></div><div class=\"line\"><span class=\"regexp\">    /</span><span class=\"regexp\">/ 在父组件中通过 v-on 监听increment事件，当事件触发后，调用incrementTotal方法</span></div><div class=\"line\"><span class=\"regexp\">    &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/</span>button-counter&gt;</div><div class=\"line\">    &lt;button-counter v-on:increment=<span class=\"string\">\"incrementTotal\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">button-counter</span>&gt;</span></span></div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div></pre></td></tr></table></figure>\n<p>上面代码实现的流程：子组件要往父组件 <strong>主动</strong>传递消息，那么必须在子组件中调用<code>$emit(eventName)</code>触发事件，然后在父组件上通过<code>v-on:eventName</code>监听事件，当父组件监听到数据后调用相应的方法响应子组件，这样便实现了子组件向父组件传递消息</p>\n<p>参考: <a href=\"https://cn.vuejs.org/v2/guide/components.html#使用-v-on-绑定自定义事件\" target=\"_blank\" rel=\"external\">使用v-on绑定自定义事件</a></p>\n<h2 id=\"非父子组件通信\"><a href=\"#非父子组件通信\" class=\"headerlink\" title=\"非父子组件通信\"></a>非父子组件通信</h2><p><strong>原理</strong>：通过定义一个公共的Vue实例，然后在该实例上绑定事件即可<br>代码如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全局Vue实例，通过在该实例上绑定事件，</span></div><div class=\"line\"><span class=\"keyword\">var</span> box = <span class=\"keyword\">new</span> Vue();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 子组件1</span></div><div class=\"line\"><span class=\"keyword\">var</span> childOne = &#123;</div><div class=\"line\">    name: <span class=\"string\">'childOne'</span>,</div><div class=\"line\">    props: [<span class=\"string\">'childMsg'</span>],</div><div class=\"line\">    template: <span class=\"string\">'&lt;div v-text=\"childMsg\" @click=\"commit\" class=\"msg1\"&gt;&lt;/div&gt;'</span>,</div><div class=\"line\">    data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            msg: <span class=\"string\">\"component1\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        commit: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// 触发 'oneToTwo' 事件，并传递一个对象数据，childTwo订阅了该事件，因此会接收到</span></div><div class=\"line\">            box.$emit(<span class=\"string\">'oneToTwo'</span>, &#123;</div><div class=\"line\">                msg: <span class=\"string\">'i am component1'</span></div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// 组件被挂载就定于twoToOne事件</span></div><div class=\"line\">    mounted() &#123;</div><div class=\"line\">        <span class=\"comment\">// 订阅 'twoToOne' 事件，当twoToOne事件触发时，调用回调函数，twoToOne的触发事件会传递一个参数过来，将其存放在data中</span></div><div class=\"line\">        box.$on(<span class=\"string\">'twoToOne'</span>, (data) =&gt; &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.msg = data.msg</div><div class=\"line\">         &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 子组件2</span></div><div class=\"line\"><span class=\"keyword\">var</span> childTwo = &#123;</div><div class=\"line\">    name: <span class=\"string\">'childTwo'</span>,</div><div class=\"line\">    props: [<span class=\"string\">'childMsg'</span>],</div><div class=\"line\">    template: <span class=\"string\">'&lt;div v-text=\"msg\" @click=\"btnClick\" class=\"msg2\"&gt;&lt;/div&gt;'</span>,</div><div class=\"line\">    data: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            msg: <span class=\"string\">'component2'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    mounted() &#123;</div><div class=\"line\">        bus.$on(<span class=\"string\">'oneToTwo'</span>, (data) =&gt; &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.msg = data.msg;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    methods: &#123;</div><div class=\"line\">        btnClick: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'twoToOne'</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"Vue组件","date":"2017-09-25T08:24:03.000Z","_content":"","source":"_posts/Vue组件.md","raw":"---\ntitle: Vue组件\ndate: 2017-09-25 16:24:03\ncategories:\ntags:\n---\n","slug":"Vue组件","published":1,"updated":"2017-09-25T08:24:03.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7get2000iekrij5tckshj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"webpack使用过程","date":"2017-09-28T08:45:47.000Z","_content":"## 加载scss文件 \nwebpack.config.js配置\n```js \nmodule: {\n    rules: [\n      {\n        test: /\\.scss$/,\n        //webpack 进行解析时，是从后往前进行解析，也就是先执行sass-loader\n        use: [\"style-loader\", \"css-loader\", \"sass-loader\"]\n      }\n    ]\n  },\n```\n需要安装：`npm i -D style-loader css-loader sass-loader node-sass`","source":"_posts/webpack使用过程.md","raw":"---\ntitle: webpack使用过程\ndate: 2017-09-28 16:45:47\ncategories:\ntags: Webpack\n---\n## 加载scss文件 \nwebpack.config.js配置\n```js \nmodule: {\n    rules: [\n      {\n        test: /\\.scss$/,\n        //webpack 进行解析时，是从后往前进行解析，也就是先执行sass-loader\n        use: [\"style-loader\", \"css-loader\", \"sass-loader\"]\n      }\n    ]\n  },\n```\n需要安装：`npm i -D style-loader css-loader sass-loader node-sass`","slug":"webpack使用过程","published":1,"updated":"2017-09-28T09:10:58.372Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7get6000kekriemvlvr63","content":"<h2 id=\"加载scss文件\"><a href=\"#加载scss文件\" class=\"headerlink\" title=\"加载scss文件\"></a>加载scss文件</h2><p>webpack.config.js配置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">    rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: <span class=\"regexp\">/\\.scss$/</span>,</div><div class=\"line\">        <span class=\"comment\">//webpack 进行解析时，是从后往前进行解析，也就是先执行sass-loader</span></div><div class=\"line\">        use: [<span class=\"string\">\"style-loader\"</span>, <span class=\"string\">\"css-loader\"</span>, <span class=\"string\">\"sass-loader\"</span>]</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>需要安装：<code>npm i -D style-loader css-loader sass-loader node-sass</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"加载scss文件\"><a href=\"#加载scss文件\" class=\"headerlink\" title=\"加载scss文件\"></a>加载scss文件</h2><p>webpack.config.js配置<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">    rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: <span class=\"regexp\">/\\.scss$/</span>,</div><div class=\"line\">        <span class=\"comment\">//webpack 进行解析时，是从后往前进行解析，也就是先执行sass-loader</span></div><div class=\"line\">        use: [<span class=\"string\">\"style-loader\"</span>, <span class=\"string\">\"css-loader\"</span>, <span class=\"string\">\"sass-loader\"</span>]</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>需要安装：<code>npm i -D style-loader css-loader sass-loader node-sass</code></p>\n"},{"title":"WebSocket学习","date":"2017-09-18T00:47:32.000Z","_content":"WebSocket是一种网络通信协议\n\n## 为什么需要WebSocket\n因为HTTP协议有一个缺陷：**通信只能由客户端发起**；如果需要获取到服务器端的数据更新，只能由客户端轮询服务器端，这样 **效率极低且浪费资源**。\n基于以上原因，WebSocket就出现了\n\n## 简介\nWebSocket协议2008年诞生，2011年成为国际标准。\n\n最大特点：**服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话**\n\n其他特点包括：\n- 建立在TCP协议之上，服务器端的实现比较容易\n- 与HTTP协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器\n- 数据格式比较轻量，性能开销小，通信高效\n- 可发送文本，也可以发送二进制数据\n- 没有同源限制，客户端可以与任意服务器通信\n- 协议标识符是`ws`(如果加密，则为`wss`)，服务器网址就是URL\n\n```\nws://example.com:80/some/path\n```\n![对比图](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051503.jpg)\n\n## 客户端的简单示例\nWebSocket的用法很简单\n例子如下：\n```\nvar ws = new WebSocket(\"wss://echo.websocket.org\");\n\nws.onopen = function(evt) {\n  console.log(\"Connection open ...\");\n  ws.send(\"Hello WebSocket!\");\n}\n\nws.onmessage = function(evt) {\n  console.log(\"Received Message: \" + evt.data);\n  ws.close();\n}\n\nws.onclose = function(evt) {\n  console.log(\"Connection closed.\");\n}\n```\n\n## 客户端的API\n### WebSocket构造函数\nWebSocket 对象作为一个构造函数，用于新建WebSocket实例。\n```\nvar ws = new WebSocket('ws://localhost:8080');\n```\n执行上面语句之后，客户端就会与服务器进行连接。\n实例对象的所有属性和方法清单，参见[WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n\n### WebSocket.readyState\n`readyState`属性返回实例对象的当前状态，共有四种。\n\n```\n  - CONNETCTION: 值为0，表示正在连接\n  - OPEN: 值为1，表示连接成功，可以通信了\n  - CLOSING: 值为2，表示连接正在关闭\n  - CLOSED: 值为3，表示连接已经关闭，或者打开连接失败\n```\n\n\n\n\n### 参考\n- [WebSocket教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html)\n\n","source":"_posts/WebSocket学习.md","raw":"---\ntitle: WebSocket学习\ndate: 2017-09-18 08:47:32\ncategories:\ntags: WEB\n---\nWebSocket是一种网络通信协议\n\n## 为什么需要WebSocket\n因为HTTP协议有一个缺陷：**通信只能由客户端发起**；如果需要获取到服务器端的数据更新，只能由客户端轮询服务器端，这样 **效率极低且浪费资源**。\n基于以上原因，WebSocket就出现了\n\n## 简介\nWebSocket协议2008年诞生，2011年成为国际标准。\n\n最大特点：**服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话**\n\n其他特点包括：\n- 建立在TCP协议之上，服务器端的实现比较容易\n- 与HTTP协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器\n- 数据格式比较轻量，性能开销小，通信高效\n- 可发送文本，也可以发送二进制数据\n- 没有同源限制，客户端可以与任意服务器通信\n- 协议标识符是`ws`(如果加密，则为`wss`)，服务器网址就是URL\n\n```\nws://example.com:80/some/path\n```\n![对比图](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051503.jpg)\n\n## 客户端的简单示例\nWebSocket的用法很简单\n例子如下：\n```\nvar ws = new WebSocket(\"wss://echo.websocket.org\");\n\nws.onopen = function(evt) {\n  console.log(\"Connection open ...\");\n  ws.send(\"Hello WebSocket!\");\n}\n\nws.onmessage = function(evt) {\n  console.log(\"Received Message: \" + evt.data);\n  ws.close();\n}\n\nws.onclose = function(evt) {\n  console.log(\"Connection closed.\");\n}\n```\n\n## 客户端的API\n### WebSocket构造函数\nWebSocket 对象作为一个构造函数，用于新建WebSocket实例。\n```\nvar ws = new WebSocket('ws://localhost:8080');\n```\n执行上面语句之后，客户端就会与服务器进行连接。\n实例对象的所有属性和方法清单，参见[WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n\n### WebSocket.readyState\n`readyState`属性返回实例对象的当前状态，共有四种。\n\n```\n  - CONNETCTION: 值为0，表示正在连接\n  - OPEN: 值为1，表示连接成功，可以通信了\n  - CLOSING: 值为2，表示连接正在关闭\n  - CLOSED: 值为3，表示连接已经关闭，或者打开连接失败\n```\n\n\n\n\n### 参考\n- [WebSocket教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html)\n\n","slug":"WebSocket学习","published":1,"updated":"2017-09-18T03:19:51.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7geta000nekri0p5a3bkk","content":"<p>WebSocket是一种网络通信协议</p>\n<h2 id=\"为什么需要WebSocket\"><a href=\"#为什么需要WebSocket\" class=\"headerlink\" title=\"为什么需要WebSocket\"></a>为什么需要WebSocket</h2><p>因为HTTP协议有一个缺陷：<strong>通信只能由客户端发起</strong>；如果需要获取到服务器端的数据更新，只能由客户端轮询服务器端，这样 <strong>效率极低且浪费资源</strong>。<br>基于以上原因，WebSocket就出现了</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>WebSocket协议2008年诞生，2011年成为国际标准。</p>\n<p>最大特点：<strong>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话</strong></p>\n<p>其他特点包括：</p>\n<ul>\n<li>建立在TCP协议之上，服务器端的实现比较容易</li>\n<li>与HTTP协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器</li>\n<li>数据格式比较轻量，性能开销小，通信高效</li>\n<li>可发送文本，也可以发送二进制数据</li>\n<li>没有同源限制，客户端可以与任意服务器通信</li>\n<li>协议标识符是<code>ws</code>(如果加密，则为<code>wss</code>)，服务器网址就是URL</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ws://example.com:80/some/path</div></pre></td></tr></table></figure>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051503.jpg\" alt=\"对比图\"></p>\n<h2 id=\"客户端的简单示例\"><a href=\"#客户端的简单示例\" class=\"headerlink\" title=\"客户端的简单示例\"></a>客户端的简单示例</h2><p>WebSocket的用法很简单<br>例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);</div><div class=\"line\"></div><div class=\"line\">ws.onopen = function(evt) &#123;</div><div class=\"line\">  console.log(&quot;Connection open ...&quot;);</div><div class=\"line\">  ws.send(&quot;Hello WebSocket!&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ws.onmessage = function(evt) &#123;</div><div class=\"line\">  console.log(&quot;Received Message: &quot; + evt.data);</div><div class=\"line\">  ws.close();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ws.onclose = function(evt) &#123;</div><div class=\"line\">  console.log(&quot;Connection closed.&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"客户端的API\"><a href=\"#客户端的API\" class=\"headerlink\" title=\"客户端的API\"></a>客户端的API</h2><h3 id=\"WebSocket构造函数\"><a href=\"#WebSocket构造函数\" class=\"headerlink\" title=\"WebSocket构造函数\"></a>WebSocket构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建WebSocket实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ws = new WebSocket(&apos;ws://localhost:8080&apos;);</div></pre></td></tr></table></figure></p>\n<p>执行上面语句之后，客户端就会与服务器进行连接。<br>实例对象的所有属性和方法清单，参见<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\" target=\"_blank\" rel=\"external\">WebSocket</a></p>\n<h3 id=\"WebSocket-readyState\"><a href=\"#WebSocket-readyState\" class=\"headerlink\" title=\"WebSocket.readyState\"></a>WebSocket.readyState</h3><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- CONNETCTION: 值为0，表示正在连接</div><div class=\"line\">- OPEN: 值为1，表示连接成功，可以通信了</div><div class=\"line\">- CLOSING: 值为2，表示连接正在关闭</div><div class=\"line\">- CLOSED: 值为3，表示连接已经关闭，或者打开连接失败</div></pre></td></tr></table></figure>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">WebSocket教程</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>WebSocket是一种网络通信协议</p>\n<h2 id=\"为什么需要WebSocket\"><a href=\"#为什么需要WebSocket\" class=\"headerlink\" title=\"为什么需要WebSocket\"></a>为什么需要WebSocket</h2><p>因为HTTP协议有一个缺陷：<strong>通信只能由客户端发起</strong>；如果需要获取到服务器端的数据更新，只能由客户端轮询服务器端，这样 <strong>效率极低且浪费资源</strong>。<br>基于以上原因，WebSocket就出现了</p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>WebSocket协议2008年诞生，2011年成为国际标准。</p>\n<p>最大特点：<strong>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话</strong></p>\n<p>其他特点包括：</p>\n<ul>\n<li>建立在TCP协议之上，服务器端的实现比较容易</li>\n<li>与HTTP协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器</li>\n<li>数据格式比较轻量，性能开销小，通信高效</li>\n<li>可发送文本，也可以发送二进制数据</li>\n<li>没有同源限制，客户端可以与任意服务器通信</li>\n<li>协议标识符是<code>ws</code>(如果加密，则为<code>wss</code>)，服务器网址就是URL</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ws://example.com:80/some/path</div></pre></td></tr></table></figure>\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051503.jpg\" alt=\"对比图\"></p>\n<h2 id=\"客户端的简单示例\"><a href=\"#客户端的简单示例\" class=\"headerlink\" title=\"客户端的简单示例\"></a>客户端的简单示例</h2><p>WebSocket的用法很简单<br>例子如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);</div><div class=\"line\"></div><div class=\"line\">ws.onopen = function(evt) &#123;</div><div class=\"line\">  console.log(&quot;Connection open ...&quot;);</div><div class=\"line\">  ws.send(&quot;Hello WebSocket!&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ws.onmessage = function(evt) &#123;</div><div class=\"line\">  console.log(&quot;Received Message: &quot; + evt.data);</div><div class=\"line\">  ws.close();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ws.onclose = function(evt) &#123;</div><div class=\"line\">  console.log(&quot;Connection closed.&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"客户端的API\"><a href=\"#客户端的API\" class=\"headerlink\" title=\"客户端的API\"></a>客户端的API</h2><h3 id=\"WebSocket构造函数\"><a href=\"#WebSocket构造函数\" class=\"headerlink\" title=\"WebSocket构造函数\"></a>WebSocket构造函数</h3><p>WebSocket 对象作为一个构造函数，用于新建WebSocket实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ws = new WebSocket(&apos;ws://localhost:8080&apos;);</div></pre></td></tr></table></figure></p>\n<p>执行上面语句之后，客户端就会与服务器进行连接。<br>实例对象的所有属性和方法清单，参见<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\" target=\"_blank\" rel=\"external\">WebSocket</a></p>\n<h3 id=\"WebSocket-readyState\"><a href=\"#WebSocket-readyState\" class=\"headerlink\" title=\"WebSocket.readyState\"></a>WebSocket.readyState</h3><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- CONNETCTION: 值为0，表示正在连接</div><div class=\"line\">- OPEN: 值为1，表示连接成功，可以通信了</div><div class=\"line\">- CLOSING: 值为2，表示连接正在关闭</div><div class=\"line\">- CLOSED: 值为3，表示连接已经关闭，或者打开连接失败</div></pre></td></tr></table></figure>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">WebSocket教程</a></li>\n</ul>\n"},{"title":"Web前端面试提问","date":"2017-09-06T08:24:45.000Z","_content":"## React 与 Vue的区别\n** 语法不同 **\n- React使用的是JSX语法\n- Vue使用的是模板语法\n\n** 架构模式不同 **\n- React是MVC架构\n- Vue是MVVM架构\n\n** 对state的管理不同 **\n- React不能对state直接进行修改，必须通过`this.setState`进行修改\n- Vue可以直接对state进行修改，修改后的数据会直接渲染到页面上\n\n** 对移动端的支持 **\n- React有React Native，支持移动端APP开发\n- Vue没有\n\n** 生态 **\n- React 的生态比 Vue要大 \n\n** 学习难度 **\n- React 大部分是英文资料，而Vue中文教程支持完善\n\n参考文章：[React还是Vue？](https://segmentfault.com/a/1190000009268926)\n\n## Webpack 和 gulp的区别\n从前端工程化的发展历程说起：\n- 第一阶段\n  在没有gulp等工具之前，开发人员一般通过工具将代码进行压缩，然后上线\n- 第二阶段 gulp 出现\n  gulp出现之后，文件的压缩、生成base64 就都交给gulp处理了，不需要我们自己手动通过工具来做这些事，但是gulp没有解决js模块化的问题\n\n- 第三阶段 requirejs出现\n  requirejs 主要用于js模块化编程，它基于AMD规范，现在的操作流程是，requirejs实现js的模块化编程并打包，然后通过gulp压缩处理\n\n- 第四阶段 webpack出现\n  webpack将所有的资源都看成一个模块，并通过loader进行引入，且同时支持commonjs、AMD和CMD等规范，所以，很多人就选择webpack进行js的模块化编程并打包，然后使用gulp进行压缩\n\n- 第五阶段 webpack的plugins\n  最后人们发现可以使用webpack的plugins，通过编写一些插件，来完成文件的压缩及其他很多gulp做的事情，同时，还可以利用npm中package.json的scripts来自定义命令，实现自动化，因此，很多人转向了webpack\n\n**注意**：gulp一直没解决的问题是js模块化编程的文件依赖问题，这也是导致它的市场慢慢的被webpack抢占的原因\n\n**关于webpack和gulp的选择**\n当用webpack无法解决你的问题时，再考虑gulp是否能够实现\n\n## CommonJS、AMD和CMD的区别\n** CommonJS **\nCommonJS是同步加载，表示必须要等到模块加载完成之后，才执行后面的操作，所以它只适用于服务器端编程，因为对于服务器，其模块文件一般存放在本地硬盘上，加载起来比较快，不用考虑非同步加载的情况；\n\n** AMD **\nAMD规范则是非同步加载模块，允许指定回调函数，所以它比较适合；\n```\ndefine (['package/lib'], function(lib) {\n    function foo() {\n        lib.log('hello world');\n    }\n\n    return {\n        foo: foo\n    };\n});\n```\n\n而对于浏览器端而言，程序文件都存放在服务器端，其加载速度取决于网速， \n参考：[http://javascript.ruanyifeng.com/nodejs/module.html]\n\n\n## http协议\n\n## 快速排序\n\n## 前端通信接口\n\n## 各设计模式的应用场景\n\n## 当代码更新后发布，如何解决重复访问时，访问的是缓存信息？\n当更新代码时，给代码添加版本号\n\n## ajax的优缺点？\n**什么是ajax**\n  ajax是通过JavaScript异步获取数据，进行局部页面刷新的技术\n\n**优点**\n- 提高用户体验\n- 较少带宽并增加速度\n- 提高工作效率\n  因为有很多封装好的ajax类库，很方便就可以与服务器进行通信\n- 支持异步操作\n\n**缺点**\n- 浏览器兼容性问题\n  因为ajax高度依赖JavaScript，而不同的浏览器对于JavaScript的支持程度不同，因此存在有兼容性问题\n- 增加web服务器的负载 \n  例如：增加一个自动更新的功能，每隔几秒钟就发送一次请求，那么就会增加服务器的负担\n- 不安全性\n  因为是异步获取数据，所以导致调试不便\n\n","source":"_posts/Web前端整理.md","raw":"---\ntitle: Web前端面试提问\ndate: 2017-09-06 16:24:45\ncategories: Web\ntags: WEB\n---\n## React 与 Vue的区别\n** 语法不同 **\n- React使用的是JSX语法\n- Vue使用的是模板语法\n\n** 架构模式不同 **\n- React是MVC架构\n- Vue是MVVM架构\n\n** 对state的管理不同 **\n- React不能对state直接进行修改，必须通过`this.setState`进行修改\n- Vue可以直接对state进行修改，修改后的数据会直接渲染到页面上\n\n** 对移动端的支持 **\n- React有React Native，支持移动端APP开发\n- Vue没有\n\n** 生态 **\n- React 的生态比 Vue要大 \n\n** 学习难度 **\n- React 大部分是英文资料，而Vue中文教程支持完善\n\n参考文章：[React还是Vue？](https://segmentfault.com/a/1190000009268926)\n\n## Webpack 和 gulp的区别\n从前端工程化的发展历程说起：\n- 第一阶段\n  在没有gulp等工具之前，开发人员一般通过工具将代码进行压缩，然后上线\n- 第二阶段 gulp 出现\n  gulp出现之后，文件的压缩、生成base64 就都交给gulp处理了，不需要我们自己手动通过工具来做这些事，但是gulp没有解决js模块化的问题\n\n- 第三阶段 requirejs出现\n  requirejs 主要用于js模块化编程，它基于AMD规范，现在的操作流程是，requirejs实现js的模块化编程并打包，然后通过gulp压缩处理\n\n- 第四阶段 webpack出现\n  webpack将所有的资源都看成一个模块，并通过loader进行引入，且同时支持commonjs、AMD和CMD等规范，所以，很多人就选择webpack进行js的模块化编程并打包，然后使用gulp进行压缩\n\n- 第五阶段 webpack的plugins\n  最后人们发现可以使用webpack的plugins，通过编写一些插件，来完成文件的压缩及其他很多gulp做的事情，同时，还可以利用npm中package.json的scripts来自定义命令，实现自动化，因此，很多人转向了webpack\n\n**注意**：gulp一直没解决的问题是js模块化编程的文件依赖问题，这也是导致它的市场慢慢的被webpack抢占的原因\n\n**关于webpack和gulp的选择**\n当用webpack无法解决你的问题时，再考虑gulp是否能够实现\n\n## CommonJS、AMD和CMD的区别\n** CommonJS **\nCommonJS是同步加载，表示必须要等到模块加载完成之后，才执行后面的操作，所以它只适用于服务器端编程，因为对于服务器，其模块文件一般存放在本地硬盘上，加载起来比较快，不用考虑非同步加载的情况；\n\n** AMD **\nAMD规范则是非同步加载模块，允许指定回调函数，所以它比较适合；\n```\ndefine (['package/lib'], function(lib) {\n    function foo() {\n        lib.log('hello world');\n    }\n\n    return {\n        foo: foo\n    };\n});\n```\n\n而对于浏览器端而言，程序文件都存放在服务器端，其加载速度取决于网速， \n参考：[http://javascript.ruanyifeng.com/nodejs/module.html]\n\n\n## http协议\n\n## 快速排序\n\n## 前端通信接口\n\n## 各设计模式的应用场景\n\n## 当代码更新后发布，如何解决重复访问时，访问的是缓存信息？\n当更新代码时，给代码添加版本号\n\n## ajax的优缺点？\n**什么是ajax**\n  ajax是通过JavaScript异步获取数据，进行局部页面刷新的技术\n\n**优点**\n- 提高用户体验\n- 较少带宽并增加速度\n- 提高工作效率\n  因为有很多封装好的ajax类库，很方便就可以与服务器进行通信\n- 支持异步操作\n\n**缺点**\n- 浏览器兼容性问题\n  因为ajax高度依赖JavaScript，而不同的浏览器对于JavaScript的支持程度不同，因此存在有兼容性问题\n- 增加web服务器的负载 \n  例如：增加一个自动更新的功能，每隔几秒钟就发送一次请求，那么就会增加服务器的负担\n- 不安全性\n  因为是异步获取数据，所以导致调试不便\n\n","slug":"Web前端整理","published":1,"updated":"2017-09-25T08:19:46.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7gete000pekrip0jbi4xo","content":"<h2 id=\"React-与-Vue的区别\"><a href=\"#React-与-Vue的区别\" class=\"headerlink\" title=\"React 与 Vue的区别\"></a>React 与 Vue的区别</h2><p><strong> 语法不同 </strong></p>\n<ul>\n<li>React使用的是JSX语法</li>\n<li>Vue使用的是模板语法</li>\n</ul>\n<p><strong> 架构模式不同 </strong></p>\n<ul>\n<li>React是MVC架构</li>\n<li>Vue是MVVM架构</li>\n</ul>\n<p><strong> 对state的管理不同 </strong></p>\n<ul>\n<li>React不能对state直接进行修改，必须通过<code>this.setState</code>进行修改</li>\n<li>Vue可以直接对state进行修改，修改后的数据会直接渲染到页面上</li>\n</ul>\n<p><strong> 对移动端的支持 </strong></p>\n<ul>\n<li>React有React Native，支持移动端APP开发</li>\n<li>Vue没有</li>\n</ul>\n<p><strong> 生态 </strong></p>\n<ul>\n<li>React 的生态比 Vue要大 </li>\n</ul>\n<p><strong> 学习难度 </strong></p>\n<ul>\n<li>React 大部分是英文资料，而Vue中文教程支持完善</li>\n</ul>\n<p>参考文章：<a href=\"https://segmentfault.com/a/1190000009268926\" target=\"_blank\" rel=\"external\">React还是Vue？</a></p>\n<h2 id=\"Webpack-和-gulp的区别\"><a href=\"#Webpack-和-gulp的区别\" class=\"headerlink\" title=\"Webpack 和 gulp的区别\"></a>Webpack 和 gulp的区别</h2><p>从前端工程化的发展历程说起：</p>\n<ul>\n<li>第一阶段<br>在没有gulp等工具之前，开发人员一般通过工具将代码进行压缩，然后上线</li>\n<li><p>第二阶段 gulp 出现<br>gulp出现之后，文件的压缩、生成base64 就都交给gulp处理了，不需要我们自己手动通过工具来做这些事，但是gulp没有解决js模块化的问题</p>\n</li>\n<li><p>第三阶段 requirejs出现<br>requirejs 主要用于js模块化编程，它基于AMD规范，现在的操作流程是，requirejs实现js的模块化编程并打包，然后通过gulp压缩处理</p>\n</li>\n<li><p>第四阶段 webpack出现<br>webpack将所有的资源都看成一个模块，并通过loader进行引入，且同时支持commonjs、AMD和CMD等规范，所以，很多人就选择webpack进行js的模块化编程并打包，然后使用gulp进行压缩</p>\n</li>\n<li><p>第五阶段 webpack的plugins<br>最后人们发现可以使用webpack的plugins，通过编写一些插件，来完成文件的压缩及其他很多gulp做的事情，同时，还可以利用npm中package.json的scripts来自定义命令，实现自动化，因此，很多人转向了webpack</p>\n</li>\n</ul>\n<p><strong>注意</strong>：gulp一直没解决的问题是js模块化编程的文件依赖问题，这也是导致它的市场慢慢的被webpack抢占的原因</p>\n<p><strong>关于webpack和gulp的选择</strong><br>当用webpack无法解决你的问题时，再考虑gulp是否能够实现</p>\n<h2 id=\"CommonJS、AMD和CMD的区别\"><a href=\"#CommonJS、AMD和CMD的区别\" class=\"headerlink\" title=\"CommonJS、AMD和CMD的区别\"></a>CommonJS、AMD和CMD的区别</h2><p><strong> CommonJS </strong><br>CommonJS是同步加载，表示必须要等到模块加载完成之后，才执行后面的操作，所以它只适用于服务器端编程，因为对于服务器，其模块文件一般存放在本地硬盘上，加载起来比较快，不用考虑非同步加载的情况；</p>\n<p><strong> AMD </strong><br>AMD规范则是非同步加载模块，允许指定回调函数，所以它比较适合；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">define ([&apos;package/lib&apos;], function(lib) &#123;</div><div class=\"line\">    function foo() &#123;</div><div class=\"line\">        lib.log(&apos;hello world&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return &#123;</div><div class=\"line\">        foo: foo</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>而对于浏览器端而言，程序文件都存放在服务器端，其加载速度取决于网速，<br>参考：[<a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\" target=\"_blank\" rel=\"external\">http://javascript.ruanyifeng.com/nodejs/module.html</a>]</p>\n<h2 id=\"http协议\"><a href=\"#http协议\" class=\"headerlink\" title=\"http协议\"></a>http协议</h2><h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><h2 id=\"前端通信接口\"><a href=\"#前端通信接口\" class=\"headerlink\" title=\"前端通信接口\"></a>前端通信接口</h2><h2 id=\"各设计模式的应用场景\"><a href=\"#各设计模式的应用场景\" class=\"headerlink\" title=\"各设计模式的应用场景\"></a>各设计模式的应用场景</h2><h2 id=\"当代码更新后发布，如何解决重复访问时，访问的是缓存信息？\"><a href=\"#当代码更新后发布，如何解决重复访问时，访问的是缓存信息？\" class=\"headerlink\" title=\"当代码更新后发布，如何解决重复访问时，访问的是缓存信息？\"></a>当代码更新后发布，如何解决重复访问时，访问的是缓存信息？</h2><p>当更新代码时，给代码添加版本号</p>\n<h2 id=\"ajax的优缺点？\"><a href=\"#ajax的优缺点？\" class=\"headerlink\" title=\"ajax的优缺点？\"></a>ajax的优缺点？</h2><p><strong>什么是ajax</strong><br>  ajax是通过JavaScript异步获取数据，进行局部页面刷新的技术</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>提高用户体验</li>\n<li>较少带宽并增加速度</li>\n<li>提高工作效率<br>因为有很多封装好的ajax类库，很方便就可以与服务器进行通信</li>\n<li>支持异步操作</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>浏览器兼容性问题<br>因为ajax高度依赖JavaScript，而不同的浏览器对于JavaScript的支持程度不同，因此存在有兼容性问题</li>\n<li>增加web服务器的负载<br>例如：增加一个自动更新的功能，每隔几秒钟就发送一次请求，那么就会增加服务器的负担</li>\n<li>不安全性<br>因为是异步获取数据，所以导致调试不便</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React-与-Vue的区别\"><a href=\"#React-与-Vue的区别\" class=\"headerlink\" title=\"React 与 Vue的区别\"></a>React 与 Vue的区别</h2><p><strong> 语法不同 </strong></p>\n<ul>\n<li>React使用的是JSX语法</li>\n<li>Vue使用的是模板语法</li>\n</ul>\n<p><strong> 架构模式不同 </strong></p>\n<ul>\n<li>React是MVC架构</li>\n<li>Vue是MVVM架构</li>\n</ul>\n<p><strong> 对state的管理不同 </strong></p>\n<ul>\n<li>React不能对state直接进行修改，必须通过<code>this.setState</code>进行修改</li>\n<li>Vue可以直接对state进行修改，修改后的数据会直接渲染到页面上</li>\n</ul>\n<p><strong> 对移动端的支持 </strong></p>\n<ul>\n<li>React有React Native，支持移动端APP开发</li>\n<li>Vue没有</li>\n</ul>\n<p><strong> 生态 </strong></p>\n<ul>\n<li>React 的生态比 Vue要大 </li>\n</ul>\n<p><strong> 学习难度 </strong></p>\n<ul>\n<li>React 大部分是英文资料，而Vue中文教程支持完善</li>\n</ul>\n<p>参考文章：<a href=\"https://segmentfault.com/a/1190000009268926\" target=\"_blank\" rel=\"external\">React还是Vue？</a></p>\n<h2 id=\"Webpack-和-gulp的区别\"><a href=\"#Webpack-和-gulp的区别\" class=\"headerlink\" title=\"Webpack 和 gulp的区别\"></a>Webpack 和 gulp的区别</h2><p>从前端工程化的发展历程说起：</p>\n<ul>\n<li>第一阶段<br>在没有gulp等工具之前，开发人员一般通过工具将代码进行压缩，然后上线</li>\n<li><p>第二阶段 gulp 出现<br>gulp出现之后，文件的压缩、生成base64 就都交给gulp处理了，不需要我们自己手动通过工具来做这些事，但是gulp没有解决js模块化的问题</p>\n</li>\n<li><p>第三阶段 requirejs出现<br>requirejs 主要用于js模块化编程，它基于AMD规范，现在的操作流程是，requirejs实现js的模块化编程并打包，然后通过gulp压缩处理</p>\n</li>\n<li><p>第四阶段 webpack出现<br>webpack将所有的资源都看成一个模块，并通过loader进行引入，且同时支持commonjs、AMD和CMD等规范，所以，很多人就选择webpack进行js的模块化编程并打包，然后使用gulp进行压缩</p>\n</li>\n<li><p>第五阶段 webpack的plugins<br>最后人们发现可以使用webpack的plugins，通过编写一些插件，来完成文件的压缩及其他很多gulp做的事情，同时，还可以利用npm中package.json的scripts来自定义命令，实现自动化，因此，很多人转向了webpack</p>\n</li>\n</ul>\n<p><strong>注意</strong>：gulp一直没解决的问题是js模块化编程的文件依赖问题，这也是导致它的市场慢慢的被webpack抢占的原因</p>\n<p><strong>关于webpack和gulp的选择</strong><br>当用webpack无法解决你的问题时，再考虑gulp是否能够实现</p>\n<h2 id=\"CommonJS、AMD和CMD的区别\"><a href=\"#CommonJS、AMD和CMD的区别\" class=\"headerlink\" title=\"CommonJS、AMD和CMD的区别\"></a>CommonJS、AMD和CMD的区别</h2><p><strong> CommonJS </strong><br>CommonJS是同步加载，表示必须要等到模块加载完成之后，才执行后面的操作，所以它只适用于服务器端编程，因为对于服务器，其模块文件一般存放在本地硬盘上，加载起来比较快，不用考虑非同步加载的情况；</p>\n<p><strong> AMD </strong><br>AMD规范则是非同步加载模块，允许指定回调函数，所以它比较适合；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">define ([&apos;package/lib&apos;], function(lib) &#123;</div><div class=\"line\">    function foo() &#123;</div><div class=\"line\">        lib.log(&apos;hello world&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return &#123;</div><div class=\"line\">        foo: foo</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>而对于浏览器端而言，程序文件都存放在服务器端，其加载速度取决于网速，<br>参考：[<a href=\"http://javascript.ruanyifeng.com/nodejs/module.html\" target=\"_blank\" rel=\"external\">http://javascript.ruanyifeng.com/nodejs/module.html</a>]</p>\n<h2 id=\"http协议\"><a href=\"#http协议\" class=\"headerlink\" title=\"http协议\"></a>http协议</h2><h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><h2 id=\"前端通信接口\"><a href=\"#前端通信接口\" class=\"headerlink\" title=\"前端通信接口\"></a>前端通信接口</h2><h2 id=\"各设计模式的应用场景\"><a href=\"#各设计模式的应用场景\" class=\"headerlink\" title=\"各设计模式的应用场景\"></a>各设计模式的应用场景</h2><h2 id=\"当代码更新后发布，如何解决重复访问时，访问的是缓存信息？\"><a href=\"#当代码更新后发布，如何解决重复访问时，访问的是缓存信息？\" class=\"headerlink\" title=\"当代码更新后发布，如何解决重复访问时，访问的是缓存信息？\"></a>当代码更新后发布，如何解决重复访问时，访问的是缓存信息？</h2><p>当更新代码时，给代码添加版本号</p>\n<h2 id=\"ajax的优缺点？\"><a href=\"#ajax的优缺点？\" class=\"headerlink\" title=\"ajax的优缺点？\"></a>ajax的优缺点？</h2><p><strong>什么是ajax</strong><br>  ajax是通过JavaScript异步获取数据，进行局部页面刷新的技术</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>提高用户体验</li>\n<li>较少带宽并增加速度</li>\n<li>提高工作效率<br>因为有很多封装好的ajax类库，很方便就可以与服务器进行通信</li>\n<li>支持异步操作</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>浏览器兼容性问题<br>因为ajax高度依赖JavaScript，而不同的浏览器对于JavaScript的支持程度不同，因此存在有兼容性问题</li>\n<li>增加web服务器的负载<br>例如：增加一个自动更新的功能，每隔几秒钟就发送一次请求，那么就会增加服务器的负担</li>\n<li>不安全性<br>因为是异步获取数据，所以导致调试不便</li>\n</ul>\n"},{"title":"leetcode1-10","date":"2017-09-10T09:30:38.000Z","_content":"## two sum \n**description**:\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n**example**:\n```\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1]\n```\n\n**my solution**\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nfunction sort(nums) {\n    let newArr = nums.concat();\n    for(let i = 1, len = nums.length; i < len; i++) {\n        let temp = newArr[i];\n        for (let j = i; j >=0; j--) {\n            if (newArr[j - 1] > temp) {\n                newArr[j] = newArr[j - 1];\n            } else {\n                newArr[j] = temp;\n                break;\n            }\n        }\n    }    \n    return newArr;\n}\nvar twoSum = function(nums, target) {\n    let newArr = sort(nums);\n    let result = [];\n    let index = function() {\n        for (let i = 0, len = newArr.length; i < len; i++) {\n            if (newArr[i] >= target) {\n                return i;\n            }  \n        }\n        return newArr.length;\n    }();\n    for (let i = 0, len = index; i <= len; i++) {\n        let temp = newArr[i];\n        let goal = target - temp;\n        for (let j = i + 1; j <= index; j++) {\n            if (newArr[j] === goal) {\n                result[0] = nums.indexOf(temp);\n                result[1] = nums.indexOf(goal);\n                return result;\n            }\n        }\n    }\n    return result;\n};\n```\n\n**recommend solution**\n方法1：\n```\nvar twoSum = function(nums, target) {\n    let len = nums.length;\n    for (let i = 0; i < len; i++) {\n        for (let j = i + 1; j < len; j++) {\n            if (nums[j] === (target - nums[i])) {\n                return [i, j];\n            }\n        }\n    }\n};\n```\n","source":"_posts/leetcode1-10.md","raw":"\n---\ntitle: leetcode1-10\ndate: 2017-09-10 17:30:38\ncategories:\ntags: leetcode\n---\n## two sum \n**description**:\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n**example**:\n```\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1]\n```\n\n**my solution**\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nfunction sort(nums) {\n    let newArr = nums.concat();\n    for(let i = 1, len = nums.length; i < len; i++) {\n        let temp = newArr[i];\n        for (let j = i; j >=0; j--) {\n            if (newArr[j - 1] > temp) {\n                newArr[j] = newArr[j - 1];\n            } else {\n                newArr[j] = temp;\n                break;\n            }\n        }\n    }    \n    return newArr;\n}\nvar twoSum = function(nums, target) {\n    let newArr = sort(nums);\n    let result = [];\n    let index = function() {\n        for (let i = 0, len = newArr.length; i < len; i++) {\n            if (newArr[i] >= target) {\n                return i;\n            }  \n        }\n        return newArr.length;\n    }();\n    for (let i = 0, len = index; i <= len; i++) {\n        let temp = newArr[i];\n        let goal = target - temp;\n        for (let j = i + 1; j <= index; j++) {\n            if (newArr[j] === goal) {\n                result[0] = nums.indexOf(temp);\n                result[1] = nums.indexOf(goal);\n                return result;\n            }\n        }\n    }\n    return result;\n};\n```\n\n**recommend solution**\n方法1：\n```\nvar twoSum = function(nums, target) {\n    let len = nums.length;\n    for (let i = 0; i < len; i++) {\n        for (let j = i + 1; j < len; j++) {\n            if (nums[j] === (target - nums[i])) {\n                return [i, j];\n            }\n        }\n    }\n};\n```\n","slug":"leetcode1-10","published":1,"updated":"2017-09-10T13:07:32.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7getj000rekriw3j0dqw7","content":"<h2 id=\"two-sum\"><a href=\"#two-sum\" class=\"headerlink\" title=\"two sum\"></a>two sum</h2><p><strong>description</strong>:<br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br><strong>example</strong>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given nums = [2, 7, 11, 15], target = 9,</div><div class=\"line\"></div><div class=\"line\">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class=\"line\">return [0, 1]</div></pre></td></tr></table></figure></p>\n<p><strong>my solution</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number[]&#125; nums</div><div class=\"line\"> * @param &#123;number&#125; target</div><div class=\"line\"> * @return &#123;number[]&#125;</div><div class=\"line\"> */</div><div class=\"line\">function sort(nums) &#123;</div><div class=\"line\">    let newArr = nums.concat();</div><div class=\"line\">    for(let i = 1, len = nums.length; i &lt; len; i++) &#123;</div><div class=\"line\">        let temp = newArr[i];</div><div class=\"line\">        for (let j = i; j &gt;=0; j--) &#123;</div><div class=\"line\">            if (newArr[j - 1] &gt; temp) &#123;</div><div class=\"line\">                newArr[j] = newArr[j - 1];</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                newArr[j] = temp;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;    </div><div class=\"line\">    return newArr;</div><div class=\"line\">&#125;</div><div class=\"line\">var twoSum = function(nums, target) &#123;</div><div class=\"line\">    let newArr = sort(nums);</div><div class=\"line\">    let result = [];</div><div class=\"line\">    let index = function() &#123;</div><div class=\"line\">        for (let i = 0, len = newArr.length; i &lt; len; i++) &#123;</div><div class=\"line\">            if (newArr[i] &gt;= target) &#123;</div><div class=\"line\">                return i;</div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;</div><div class=\"line\">        return newArr.length;</div><div class=\"line\">    &#125;();</div><div class=\"line\">    for (let i = 0, len = index; i &lt;= len; i++) &#123;</div><div class=\"line\">        let temp = newArr[i];</div><div class=\"line\">        let goal = target - temp;</div><div class=\"line\">        for (let j = i + 1; j &lt;= index; j++) &#123;</div><div class=\"line\">            if (newArr[j] === goal) &#123;</div><div class=\"line\">                result[0] = nums.indexOf(temp);</div><div class=\"line\">                result[1] = nums.indexOf(goal);</div><div class=\"line\">                return result;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p><strong>recommend solution</strong><br>方法1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var twoSum = function(nums, target) &#123;</div><div class=\"line\">    let len = nums.length;</div><div class=\"line\">    for (let i = 0; i &lt; len; i++) &#123;</div><div class=\"line\">        for (let j = i + 1; j &lt; len; j++) &#123;</div><div class=\"line\">            if (nums[j] === (target - nums[i])) &#123;</div><div class=\"line\">                return [i, j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"two-sum\"><a href=\"#two-sum\" class=\"headerlink\" title=\"two sum\"></a>two sum</h2><p><strong>description</strong>:<br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br><strong>example</strong>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given nums = [2, 7, 11, 15], target = 9,</div><div class=\"line\"></div><div class=\"line\">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class=\"line\">return [0, 1]</div></pre></td></tr></table></figure></p>\n<p><strong>my solution</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number[]&#125; nums</div><div class=\"line\"> * @param &#123;number&#125; target</div><div class=\"line\"> * @return &#123;number[]&#125;</div><div class=\"line\"> */</div><div class=\"line\">function sort(nums) &#123;</div><div class=\"line\">    let newArr = nums.concat();</div><div class=\"line\">    for(let i = 1, len = nums.length; i &lt; len; i++) &#123;</div><div class=\"line\">        let temp = newArr[i];</div><div class=\"line\">        for (let j = i; j &gt;=0; j--) &#123;</div><div class=\"line\">            if (newArr[j - 1] &gt; temp) &#123;</div><div class=\"line\">                newArr[j] = newArr[j - 1];</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                newArr[j] = temp;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;    </div><div class=\"line\">    return newArr;</div><div class=\"line\">&#125;</div><div class=\"line\">var twoSum = function(nums, target) &#123;</div><div class=\"line\">    let newArr = sort(nums);</div><div class=\"line\">    let result = [];</div><div class=\"line\">    let index = function() &#123;</div><div class=\"line\">        for (let i = 0, len = newArr.length; i &lt; len; i++) &#123;</div><div class=\"line\">            if (newArr[i] &gt;= target) &#123;</div><div class=\"line\">                return i;</div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;</div><div class=\"line\">        return newArr.length;</div><div class=\"line\">    &#125;();</div><div class=\"line\">    for (let i = 0, len = index; i &lt;= len; i++) &#123;</div><div class=\"line\">        let temp = newArr[i];</div><div class=\"line\">        let goal = target - temp;</div><div class=\"line\">        for (let j = i + 1; j &lt;= index; j++) &#123;</div><div class=\"line\">            if (newArr[j] === goal) &#123;</div><div class=\"line\">                result[0] = nums.indexOf(temp);</div><div class=\"line\">                result[1] = nums.indexOf(goal);</div><div class=\"line\">                return result;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p><strong>recommend solution</strong><br>方法1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var twoSum = function(nums, target) &#123;</div><div class=\"line\">    let len = nums.length;</div><div class=\"line\">    for (let i = 0; i &lt; len; i++) &#123;</div><div class=\"line\">        for (let j = i + 1; j &lt; len; j++) &#123;</div><div class=\"line\">            if (nums[j] === (target - nums[i])) &#123;</div><div class=\"line\">                return [i, j];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n"},{"title":"前端基本排序算法","date":"2017-09-09T03:37:34.000Z","_content":"\n## 快速排序\n\n## 插入排序\n![插入排序](http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFW1QYtRqUIhtiaqibFbaXWx1ial15e56XmkIiaGYSxwl1D4MDnpdTlG9DVA/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n算法描述：\n1. 从第一个元素开始，该元素可以认为已经排好序\n2. 取出第二个元素，在 *已排序*的元素（假设是：b）序列中从后向前扫描\n3. 如果已排序的元素大于将要排序的元素b，就将已排序的元素向后移动一个位置\n4. 重复 步骤3 ，直到找到已排序的元素 *小于或等于* 将要排序的元素b的位置\n5. 然后将元素b插入到该位置\n6. 重复步骤2 ~ 5\n\n现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]\n\n```\n[5] 6 3 1 8 7 2 4 //第一个元素被认为已经被排序\n\n\n[5,6] 3 1 8 7 2 4 //6与5比较，放在5的右边\n\n\n[3，5，6] 1 8 7 2 4 //3与6和5比较，都小，则放入数组头部\n\n\n[1,3,5,6] 8 7 2 4 //1与3,5,6比较，则放入头部\n\n\n[1,3，5，6，8] 7 2 4\n\n\n[1,3，5，6,7，8] 2 4\n\n\n[1，2,3，5，6,7，8] 4\n\n\n[1，2,3，4，5，6,7，8]\n```\n**编程思路**：双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将 **未排序元素设为标杆**，与已排序的元素进行比较，小于则交换位置，大于则位置不动\n\n```\nfunction insertSort(arr) {\n  let newArr = arr.slice();\n  for (var i = 1, len = newArr.length; i < len; i++) {\n    let temp = newArr[i];\n    for (var j = i; j >= 0; j--) {\n      if (newArr[j-1] > temp) {\n        newArr[j] = newArr[j-1];\n      } else {\n        newArr[j] = temp;\n        break;\n      }\n    }\n  }\n  return newArr;\n}\n\nlet a = [4,6,5,10,0, 9 ,12, 1];\nconsole.log(insertSort(a));\n```\n\n**时间复杂度**： O(n^2)\n\n## 选择排序\n![选择排序](http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFV66ibu7Kvno8snmxmPdg9wegDjvGUU7dOFtb9DEaia2cxTiaATXzEMVVw/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n**算法描述**: 假设第一个元素是最小(或最大)的数字，然后从第二个元素开始遍历，与第一个元素进行比较，如果比第一个元素小(或大)，则将该元素更新最小(或最大)的元素，如此重复。\n\n**编程思路**：先假设第一个元素为最小的，然后通过循环找出最小元素，然后同第一个元素交换，接着假设第二个元素，重复上述操作即可\n\n```\n\n\nfunction selectSort(arr) {\n  let newArr = arr.concat();\n  let minIndex = 0,\n      minValue,\n      temp,\n      len = newArr.length;\n  \n  for (var i = 0; i < len; i++) {\n    minIndex = i;\n    minValue = newArr[i];\n    for (var j = i+1; j < len; j++) {\n      if (newArr[j] < minValue) {\n        minIndex = j;\n        minValue = newArr[j];\n      }\n    }\n    temp = newArr[i]\n    newArr[i] = newArr[minIndex];\n    newArr[minIndex] = temp;\n  }\n  return newArr;\n}\n\n\nlet a = [4,6,5,10,0, 9 ,12, 1];\nconsole.log(selectSort(a));\n```\n**时间复杂度**： O(n^2)\n\n## 冒泡排序\n![冒泡排序](http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFXbGWaUmqfohzt8562kGicOibo5sKFDZe7pzataVgibmqfokib2S6LxuXyw/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n**算法描述：**\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n```\n\nfunction bubbleSort(arr) {\n  let newArr = arr.concat(),\n      len = newArr.length;\n  \n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < len - i; j++) {\n      \n      if (newArr[j] > newArr[j+1]) {\n    \n        let temp = newArr[j+1];\n        newArr[j+1] = newArr[j];\n        newArr[j] = temp;\n        \n      }\n    }\n  }\n  return newArr;\n}\n\nlet a = [4,6,5,10,0, 9 ,12, 1];\nconsole.log(bubbleSort(a));\n```\n**时间复杂度**： O(n^2)\n","source":"_posts/前端基本排序算法.md","raw":"---\ntitle: 前端基本排序算法\ndate: 2017-09-09 11:37:34\ncategories:\ntags: 算法\n---\n\n## 快速排序\n\n## 插入排序\n![插入排序](http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFW1QYtRqUIhtiaqibFbaXWx1ial15e56XmkIiaGYSxwl1D4MDnpdTlG9DVA/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n算法描述：\n1. 从第一个元素开始，该元素可以认为已经排好序\n2. 取出第二个元素，在 *已排序*的元素（假设是：b）序列中从后向前扫描\n3. 如果已排序的元素大于将要排序的元素b，就将已排序的元素向后移动一个位置\n4. 重复 步骤3 ，直到找到已排序的元素 *小于或等于* 将要排序的元素b的位置\n5. 然后将元素b插入到该位置\n6. 重复步骤2 ~ 5\n\n现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]\n\n```\n[5] 6 3 1 8 7 2 4 //第一个元素被认为已经被排序\n\n\n[5,6] 3 1 8 7 2 4 //6与5比较，放在5的右边\n\n\n[3，5，6] 1 8 7 2 4 //3与6和5比较，都小，则放入数组头部\n\n\n[1,3,5,6] 8 7 2 4 //1与3,5,6比较，则放入头部\n\n\n[1,3，5，6，8] 7 2 4\n\n\n[1,3，5，6,7，8] 2 4\n\n\n[1，2,3，5，6,7，8] 4\n\n\n[1，2,3，4，5，6,7，8]\n```\n**编程思路**：双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将 **未排序元素设为标杆**，与已排序的元素进行比较，小于则交换位置，大于则位置不动\n\n```\nfunction insertSort(arr) {\n  let newArr = arr.slice();\n  for (var i = 1, len = newArr.length; i < len; i++) {\n    let temp = newArr[i];\n    for (var j = i; j >= 0; j--) {\n      if (newArr[j-1] > temp) {\n        newArr[j] = newArr[j-1];\n      } else {\n        newArr[j] = temp;\n        break;\n      }\n    }\n  }\n  return newArr;\n}\n\nlet a = [4,6,5,10,0, 9 ,12, 1];\nconsole.log(insertSort(a));\n```\n\n**时间复杂度**： O(n^2)\n\n## 选择排序\n![选择排序](http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFV66ibu7Kvno8snmxmPdg9wegDjvGUU7dOFtb9DEaia2cxTiaATXzEMVVw/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n**算法描述**: 假设第一个元素是最小(或最大)的数字，然后从第二个元素开始遍历，与第一个元素进行比较，如果比第一个元素小(或大)，则将该元素更新最小(或最大)的元素，如此重复。\n\n**编程思路**：先假设第一个元素为最小的，然后通过循环找出最小元素，然后同第一个元素交换，接着假设第二个元素，重复上述操作即可\n\n```\n\n\nfunction selectSort(arr) {\n  let newArr = arr.concat();\n  let minIndex = 0,\n      minValue,\n      temp,\n      len = newArr.length;\n  \n  for (var i = 0; i < len; i++) {\n    minIndex = i;\n    minValue = newArr[i];\n    for (var j = i+1; j < len; j++) {\n      if (newArr[j] < minValue) {\n        minIndex = j;\n        minValue = newArr[j];\n      }\n    }\n    temp = newArr[i]\n    newArr[i] = newArr[minIndex];\n    newArr[minIndex] = temp;\n  }\n  return newArr;\n}\n\n\nlet a = [4,6,5,10,0, 9 ,12, 1];\nconsole.log(selectSort(a));\n```\n**时间复杂度**： O(n^2)\n\n## 冒泡排序\n![冒泡排序](http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFXbGWaUmqfohzt8562kGicOibo5sKFDZe7pzataVgibmqfokib2S6LxuXyw/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)\n\n**算法描述：**\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n```\n\nfunction bubbleSort(arr) {\n  let newArr = arr.concat(),\n      len = newArr.length;\n  \n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < len - i; j++) {\n      \n      if (newArr[j] > newArr[j+1]) {\n    \n        let temp = newArr[j+1];\n        newArr[j+1] = newArr[j];\n        newArr[j] = temp;\n        \n      }\n    }\n  }\n  return newArr;\n}\n\nlet a = [4,6,5,10,0, 9 ,12, 1];\nconsole.log(bubbleSort(a));\n```\n**时间复杂度**： O(n^2)\n","slug":"前端基本排序算法","published":1,"updated":"2017-09-09T05:58:40.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7geto000uekrik6dy189y","content":"<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFW1QYtRqUIhtiaqibFbaXWx1ial15e56XmkIiaGYSxwl1D4MDnpdTlG9DVA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"插入排序\"></p>\n<p>算法描述：</p>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经排好序</li>\n<li>取出第二个元素，在 <em>已排序</em>的元素（假设是：b）序列中从后向前扫描</li>\n<li>如果已排序的元素大于将要排序的元素b，就将已排序的元素向后移动一个位置</li>\n<li>重复 步骤3 ，直到找到已排序的元素 <em>小于或等于</em> 将要排序的元素b的位置</li>\n<li>然后将元素b插入到该位置</li>\n<li>重复步骤2 ~ 5</li>\n</ol>\n<p>现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">[5] 6 3 1 8 7 2 4 //第一个元素被认为已经被排序</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[5,6] 3 1 8 7 2 4 //6与5比较，放在5的右边</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[3，5，6] 1 8 7 2 4 //3与6和5比较，都小，则放入数组头部</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1,3,5,6] 8 7 2 4 //1与3,5,6比较，则放入头部</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1,3，5，6，8] 7 2 4</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1,3，5，6,7，8] 2 4</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1，2,3，5，6,7，8] 4</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1，2,3，4，5，6,7，8]</div></pre></td></tr></table></figure>\n<p><strong>编程思路</strong>：双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将 <strong>未排序元素设为标杆</strong>，与已排序的元素进行比较，小于则交换位置，大于则位置不动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function insertSort(arr) &#123;</div><div class=\"line\">  let newArr = arr.slice();</div><div class=\"line\">  for (var i = 1, len = newArr.length; i &lt; len; i++) &#123;</div><div class=\"line\">    let temp = newArr[i];</div><div class=\"line\">    for (var j = i; j &gt;= 0; j--) &#123;</div><div class=\"line\">      if (newArr[j-1] &gt; temp) &#123;</div><div class=\"line\">        newArr[j] = newArr[j-1];</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        newArr[j] = temp;</div><div class=\"line\">        break;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return newArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let a = [4,6,5,10,0, 9 ,12, 1];</div><div class=\"line\">console.log(insertSort(a));</div></pre></td></tr></table></figure>\n<p><strong>时间复杂度</strong>： O(n^2)</p>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFV66ibu7Kvno8snmxmPdg9wegDjvGUU7dOFtb9DEaia2cxTiaATXzEMVVw/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"选择排序\"></p>\n<p><strong>算法描述</strong>: 假设第一个元素是最小(或最大)的数字，然后从第二个元素开始遍历，与第一个元素进行比较，如果比第一个元素小(或大)，则将该元素更新最小(或最大)的元素，如此重复。</p>\n<p><strong>编程思路</strong>：先假设第一个元素为最小的，然后通过循环找出最小元素，然后同第一个元素交换，接着假设第二个元素，重复上述操作即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">function selectSort(arr) &#123;</div><div class=\"line\">  let newArr = arr.concat();</div><div class=\"line\">  let minIndex = 0,</div><div class=\"line\">      minValue,</div><div class=\"line\">      temp,</div><div class=\"line\">      len = newArr.length;</div><div class=\"line\">  </div><div class=\"line\">  for (var i = 0; i &lt; len; i++) &#123;</div><div class=\"line\">    minIndex = i;</div><div class=\"line\">    minValue = newArr[i];</div><div class=\"line\">    for (var j = i+1; j &lt; len; j++) &#123;</div><div class=\"line\">      if (newArr[j] &lt; minValue) &#123;</div><div class=\"line\">        minIndex = j;</div><div class=\"line\">        minValue = newArr[j];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    temp = newArr[i]</div><div class=\"line\">    newArr[i] = newArr[minIndex];</div><div class=\"line\">    newArr[minIndex] = temp;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return newArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">let a = [4,6,5,10,0, 9 ,12, 1];</div><div class=\"line\">console.log(selectSort(a));</div></pre></td></tr></table></figure>\n<p><strong>时间复杂度</strong>： O(n^2)</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFXbGWaUmqfohzt8562kGicOibo5sKFDZe7pzataVgibmqfokib2S6LxuXyw/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"冒泡排序\"></p>\n<p><strong>算法描述：</strong></p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function bubbleSort(arr) &#123;</div><div class=\"line\">  let newArr = arr.concat(),</div><div class=\"line\">      len = newArr.length;</div><div class=\"line\">  </div><div class=\"line\">  for (let i = 0; i &lt; len; i++) &#123;</div><div class=\"line\">    for (let j = 0; j &lt; len - i; j++) &#123;</div><div class=\"line\">      </div><div class=\"line\">      if (newArr[j] &gt; newArr[j+1]) &#123;</div><div class=\"line\">    </div><div class=\"line\">        let temp = newArr[j+1];</div><div class=\"line\">        newArr[j+1] = newArr[j];</div><div class=\"line\">        newArr[j] = temp;</div><div class=\"line\">        </div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return newArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let a = [4,6,5,10,0, 9 ,12, 1];</div><div class=\"line\">console.log(bubbleSort(a));</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>时间复杂度</strong>： O(n^2)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFW1QYtRqUIhtiaqibFbaXWx1ial15e56XmkIiaGYSxwl1D4MDnpdTlG9DVA/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"插入排序\"></p>\n<p>算法描述：</p>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经排好序</li>\n<li>取出第二个元素，在 <em>已排序</em>的元素（假设是：b）序列中从后向前扫描</li>\n<li>如果已排序的元素大于将要排序的元素b，就将已排序的元素向后移动一个位置</li>\n<li>重复 步骤3 ，直到找到已排序的元素 <em>小于或等于</em> 将要排序的元素b的位置</li>\n<li>然后将元素b插入到该位置</li>\n<li>重复步骤2 ~ 5</li>\n</ol>\n<p>现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">[5] 6 3 1 8 7 2 4 //第一个元素被认为已经被排序</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[5,6] 3 1 8 7 2 4 //6与5比较，放在5的右边</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[3，5，6] 1 8 7 2 4 //3与6和5比较，都小，则放入数组头部</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1,3,5,6] 8 7 2 4 //1与3,5,6比较，则放入头部</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1,3，5，6，8] 7 2 4</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1,3，5，6,7，8] 2 4</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1，2,3，5，6,7，8] 4</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[1，2,3，4，5，6,7，8]</div></pre></td></tr></table></figure>\n<p><strong>编程思路</strong>：双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将 <strong>未排序元素设为标杆</strong>，与已排序的元素进行比较，小于则交换位置，大于则位置不动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function insertSort(arr) &#123;</div><div class=\"line\">  let newArr = arr.slice();</div><div class=\"line\">  for (var i = 1, len = newArr.length; i &lt; len; i++) &#123;</div><div class=\"line\">    let temp = newArr[i];</div><div class=\"line\">    for (var j = i; j &gt;= 0; j--) &#123;</div><div class=\"line\">      if (newArr[j-1] &gt; temp) &#123;</div><div class=\"line\">        newArr[j] = newArr[j-1];</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        newArr[j] = temp;</div><div class=\"line\">        break;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return newArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let a = [4,6,5,10,0, 9 ,12, 1];</div><div class=\"line\">console.log(insertSort(a));</div></pre></td></tr></table></figure>\n<p><strong>时间复杂度</strong>： O(n^2)</p>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFV66ibu7Kvno8snmxmPdg9wegDjvGUU7dOFtb9DEaia2cxTiaATXzEMVVw/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"选择排序\"></p>\n<p><strong>算法描述</strong>: 假设第一个元素是最小(或最大)的数字，然后从第二个元素开始遍历，与第一个元素进行比较，如果比第一个元素小(或大)，则将该元素更新最小(或最大)的元素，如此重复。</p>\n<p><strong>编程思路</strong>：先假设第一个元素为最小的，然后通过循环找出最小元素，然后同第一个元素交换，接着假设第二个元素，重复上述操作即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">function selectSort(arr) &#123;</div><div class=\"line\">  let newArr = arr.concat();</div><div class=\"line\">  let minIndex = 0,</div><div class=\"line\">      minValue,</div><div class=\"line\">      temp,</div><div class=\"line\">      len = newArr.length;</div><div class=\"line\">  </div><div class=\"line\">  for (var i = 0; i &lt; len; i++) &#123;</div><div class=\"line\">    minIndex = i;</div><div class=\"line\">    minValue = newArr[i];</div><div class=\"line\">    for (var j = i+1; j &lt; len; j++) &#123;</div><div class=\"line\">      if (newArr[j] &lt; minValue) &#123;</div><div class=\"line\">        minIndex = j;</div><div class=\"line\">        minValue = newArr[j];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    temp = newArr[i]</div><div class=\"line\">    newArr[i] = newArr[minIndex];</div><div class=\"line\">    newArr[minIndex] = temp;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return newArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">let a = [4,6,5,10,0, 9 ,12, 1];</div><div class=\"line\">console.log(selectSort(a));</div></pre></td></tr></table></figure>\n<p><strong>时间复杂度</strong>： O(n^2)</p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p><img src=\"http://mmbiz.qpic.cn/mmbiz_gif/d8tibSEfhMMpQtsgC9ZZw7VvOtmLPoJSFXbGWaUmqfohzt8562kGicOibo5sKFDZe7pzataVgibmqfokib2S6LxuXyw/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"冒泡排序\"></p>\n<p><strong>算法描述：</strong></p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function bubbleSort(arr) &#123;</div><div class=\"line\">  let newArr = arr.concat(),</div><div class=\"line\">      len = newArr.length;</div><div class=\"line\">  </div><div class=\"line\">  for (let i = 0; i &lt; len; i++) &#123;</div><div class=\"line\">    for (let j = 0; j &lt; len - i; j++) &#123;</div><div class=\"line\">      </div><div class=\"line\">      if (newArr[j] &gt; newArr[j+1]) &#123;</div><div class=\"line\">    </div><div class=\"line\">        let temp = newArr[j+1];</div><div class=\"line\">        newArr[j+1] = newArr[j];</div><div class=\"line\">        newArr[j] = temp;</div><div class=\"line\">        </div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return newArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let a = [4,6,5,10,0, 9 ,12, 1];</div><div class=\"line\">console.log(bubbleSort(a));</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>时间复杂度</strong>： O(n^2)</p>\n"},{"title":"在线便利贴项目记录","date":"2017-09-16T07:59:05.000Z","_content":"## 步骤\n### 包安装\n- express安装\n  `npm install express --save`\n- express 脚手架生成器安装\n  `npm install express-generator --save-dev`\n  作用：搭建一个网站应该有的框架\n- 使用`express-generator`在当前目录下生成应用\n  因为`express-generator`是安装在本地的，所以不能直接使用express生成，需要找到`express-generator`的安装目录下bin文件夹中的.js文件执行\n  可以通过`./node_modules/express-generator/bin/express-cli.js -h`查看该命令支持的参数，\n  执行命令：`./node_modules/express-generator/bin/express-cli.js . -f -e`\n  解释：\".\"： 表示在当前目录生成应用\n        \"-f\"：强制在非空的文件夹下执行命令\n\t\"-e\"：使用ejs引擎\n\n**注意**：包一般安装在本地\n\n### 运行express的测试代码\n\n### 新建项目文件及文件夹\n文件目录如下：\n```\nexpress-sticky-note\n  bin\n    www\n  public      // 发布上线的文件，也就是将src文件夹下的文件压缩打包后输出到该文件夹下\n    css\n    js\n    imgs\n    fonts\n  routes\n  src         // 前端源文件\n    imgs\n    js\n    scss\n    webpack.config.js   // webpack的配置文件，因为在该项目中，只在前端用到了webpack，所以将该文件放在src文件夹下，如果是后端也使用到了，那么就可以将其放在主目录下\n  views\n    error.ejs\n    index.ejs\n  app.js\n  package.json\n```\n\n### 配置工程化\n**对webpack进行配置**\n\n**重要：**在配置之前，先要明确需要的功能，然后再编写几个简单的文件对环境进行测试，确保配置没有错误后，再进行正式代码的编写\n\n- 测试webpack模块化功能配置\n  在mod文件夹下定义两个文件a.js和b.js，在b.js中引用a.js，然后在app的index.js中引入b.js，然后打印b.js中的内容，最后使用webpack打包输出到public/js文件夹下，代码如下：\n  ```\n    // a.js\n    'use strict';\n    // module.exports 导出的是一个对象\n    module.exports.a = '我是aaabbbbccc';\n  ```\n  ```\n    // b.js\n     'use strict';\n     var a = require('./a.js').a;\n     module.exports = {\n       b: 'bbb',\n       a: a\n     }\n  ```\n  ```\n    // index.js\n    'use strict';\n    var obj = require('../mod/b.js');\n    console.log(obj);\n  ```\n\n  webpack.config.js中的内容如下：\n  ```\n  var webpack = require('webpack');\n  var path = require('path');\n\n  module.exports = {\n    // 文件入口\n    entry: path.join(__dirname, \"js/app/index.js\"),\n    // 打包文件输出路径\n    output: {\n      path: path.join(__dirname, \"../public/js\"),\n      filename: \"index.js\"\n    },\n  };\n  ```\n- 实现文件更新后自动打包输出\n  通过`onchange`模块来对文件进行监控，然后执行响应的npm命令\n  安装`onchang`: `npm install onchange --save-dev`\n  通过`npm scripts`实现命令，如下：\n  ```\n    \"scripts\": {\n      \"start\": \"PORT=8080 node ./bin/www\",\n      \"webpack\": \"webpack --config=src/webpack.config.js\",\n      \"watch\": \"onchange \\\"src/**/*.js\\\" \\\"src/**/*.scss\\\" -- npm run webpack\"\n    },\n  ```\n  只需要执行`npm run watch` 就会对文件进行监控然后执行打包命令\n  **注意：** 在windows下 `\"onchange \\\"src/**/*.js\\\" \\\"src/**/*.scss\\\" -` 文件的路径需要使用双引号，并且通过\"\\\"反斜杠进行转义\n## Express\n### 什么是Express\n高度包容、快速而极简的Node.js Web框架\n\n### Express的特点\n\n### Express的用法\nExpress中最重要的三部分：**中间件**、**路由**和 **中间件**\n#### 中间件(Middleware)\n#### 路由\n#### 模板引擎\n#### 静态资源\n通过`app.use(express.static(path.join(__dirname, 'public')));`对静态资源进行拦截处理，也就是说当请求的是静态资源，则直接到当前目录下的public文件夹中去查找数据\n\n**注意**：\n  - 使用`PORT=8000 node ./bin/www` 来启动服务器时，不能指定端口为80，因为80端口一般是给管理员来使用的，需要使用sudo来运行该命令，这主要是针对linux服务器\n**参考**\n- [官方文档](http://expressjs.com/zh-cn/)\n\n\n\n\n## 一些知识点\n- 控制路由的跳转的就是MVC中的Controller；与数据库交互，向外界提供比较友好的数据接口就是Model；面向用户的展示就是View(试图)\n\n- 项目开发中文件的结构划分方式：**按应用划分** 和 **按功能划分**\n  按应用划分：例如一个网站中，有多个页面，那么可以将多个页面的js文件放到app的文件夹中，这就是按应用划分\n  按功能划分：将引用的库放在lib文件夹中，模块放在mod文件夹中，这就是按功能划分，也就是根据代码功能的不同，将其划分到不同的文件夹中\n  参考：[文件的划分方式](https://segmentfault.com/a/1190000010384268)\n","source":"_posts/在线便利贴项目记录.md","raw":"---\ntitle: 在线便利贴项目记录\ndate: 2017-09-16 15:59:05\ncategories:\ntags: 个人项目\n---\n## 步骤\n### 包安装\n- express安装\n  `npm install express --save`\n- express 脚手架生成器安装\n  `npm install express-generator --save-dev`\n  作用：搭建一个网站应该有的框架\n- 使用`express-generator`在当前目录下生成应用\n  因为`express-generator`是安装在本地的，所以不能直接使用express生成，需要找到`express-generator`的安装目录下bin文件夹中的.js文件执行\n  可以通过`./node_modules/express-generator/bin/express-cli.js -h`查看该命令支持的参数，\n  执行命令：`./node_modules/express-generator/bin/express-cli.js . -f -e`\n  解释：\".\"： 表示在当前目录生成应用\n        \"-f\"：强制在非空的文件夹下执行命令\n\t\"-e\"：使用ejs引擎\n\n**注意**：包一般安装在本地\n\n### 运行express的测试代码\n\n### 新建项目文件及文件夹\n文件目录如下：\n```\nexpress-sticky-note\n  bin\n    www\n  public      // 发布上线的文件，也就是将src文件夹下的文件压缩打包后输出到该文件夹下\n    css\n    js\n    imgs\n    fonts\n  routes\n  src         // 前端源文件\n    imgs\n    js\n    scss\n    webpack.config.js   // webpack的配置文件，因为在该项目中，只在前端用到了webpack，所以将该文件放在src文件夹下，如果是后端也使用到了，那么就可以将其放在主目录下\n  views\n    error.ejs\n    index.ejs\n  app.js\n  package.json\n```\n\n### 配置工程化\n**对webpack进行配置**\n\n**重要：**在配置之前，先要明确需要的功能，然后再编写几个简单的文件对环境进行测试，确保配置没有错误后，再进行正式代码的编写\n\n- 测试webpack模块化功能配置\n  在mod文件夹下定义两个文件a.js和b.js，在b.js中引用a.js，然后在app的index.js中引入b.js，然后打印b.js中的内容，最后使用webpack打包输出到public/js文件夹下，代码如下：\n  ```\n    // a.js\n    'use strict';\n    // module.exports 导出的是一个对象\n    module.exports.a = '我是aaabbbbccc';\n  ```\n  ```\n    // b.js\n     'use strict';\n     var a = require('./a.js').a;\n     module.exports = {\n       b: 'bbb',\n       a: a\n     }\n  ```\n  ```\n    // index.js\n    'use strict';\n    var obj = require('../mod/b.js');\n    console.log(obj);\n  ```\n\n  webpack.config.js中的内容如下：\n  ```\n  var webpack = require('webpack');\n  var path = require('path');\n\n  module.exports = {\n    // 文件入口\n    entry: path.join(__dirname, \"js/app/index.js\"),\n    // 打包文件输出路径\n    output: {\n      path: path.join(__dirname, \"../public/js\"),\n      filename: \"index.js\"\n    },\n  };\n  ```\n- 实现文件更新后自动打包输出\n  通过`onchange`模块来对文件进行监控，然后执行响应的npm命令\n  安装`onchang`: `npm install onchange --save-dev`\n  通过`npm scripts`实现命令，如下：\n  ```\n    \"scripts\": {\n      \"start\": \"PORT=8080 node ./bin/www\",\n      \"webpack\": \"webpack --config=src/webpack.config.js\",\n      \"watch\": \"onchange \\\"src/**/*.js\\\" \\\"src/**/*.scss\\\" -- npm run webpack\"\n    },\n  ```\n  只需要执行`npm run watch` 就会对文件进行监控然后执行打包命令\n  **注意：** 在windows下 `\"onchange \\\"src/**/*.js\\\" \\\"src/**/*.scss\\\" -` 文件的路径需要使用双引号，并且通过\"\\\"反斜杠进行转义\n## Express\n### 什么是Express\n高度包容、快速而极简的Node.js Web框架\n\n### Express的特点\n\n### Express的用法\nExpress中最重要的三部分：**中间件**、**路由**和 **中间件**\n#### 中间件(Middleware)\n#### 路由\n#### 模板引擎\n#### 静态资源\n通过`app.use(express.static(path.join(__dirname, 'public')));`对静态资源进行拦截处理，也就是说当请求的是静态资源，则直接到当前目录下的public文件夹中去查找数据\n\n**注意**：\n  - 使用`PORT=8000 node ./bin/www` 来启动服务器时，不能指定端口为80，因为80端口一般是给管理员来使用的，需要使用sudo来运行该命令，这主要是针对linux服务器\n**参考**\n- [官方文档](http://expressjs.com/zh-cn/)\n\n\n\n\n## 一些知识点\n- 控制路由的跳转的就是MVC中的Controller；与数据库交互，向外界提供比较友好的数据接口就是Model；面向用户的展示就是View(试图)\n\n- 项目开发中文件的结构划分方式：**按应用划分** 和 **按功能划分**\n  按应用划分：例如一个网站中，有多个页面，那么可以将多个页面的js文件放到app的文件夹中，这就是按应用划分\n  按功能划分：将引用的库放在lib文件夹中，模块放在mod文件夹中，这就是按功能划分，也就是根据代码功能的不同，将其划分到不同的文件夹中\n  参考：[文件的划分方式](https://segmentfault.com/a/1190000010384268)\n","slug":"在线便利贴项目记录","published":1,"updated":"2017-09-18T00:46:58.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7getv000wekri21cbfu2s","content":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"包安装\"><a href=\"#包安装\" class=\"headerlink\" title=\"包安装\"></a>包安装</h3><ul>\n<li>express安装<br><code>npm install express --save</code></li>\n<li>express 脚手架生成器安装<br><code>npm install express-generator --save-dev</code><br>作用：搭建一个网站应该有的框架</li>\n<li>使用<code>express-generator</code>在当前目录下生成应用<br>因为<code>express-generator</code>是安装在本地的，所以不能直接使用express生成，需要找到<code>express-generator</code>的安装目录下bin文件夹中的.js文件执行<br>可以通过<code>./node_modules/express-generator/bin/express-cli.js -h</code>查看该命令支持的参数，<br>执行命令：<code>./node_modules/express-generator/bin/express-cli.js . -f -e</code><br>解释：”.”： 表示在当前目录生成应用<pre><code>&quot;-f&quot;：强制在非空的文件夹下执行命令\n</code></pre>  “-e”：使用ejs引擎</li>\n</ul>\n<p><strong>注意</strong>：包一般安装在本地</p>\n<h3 id=\"运行express的测试代码\"><a href=\"#运行express的测试代码\" class=\"headerlink\" title=\"运行express的测试代码\"></a>运行express的测试代码</h3><h3 id=\"新建项目文件及文件夹\"><a href=\"#新建项目文件及文件夹\" class=\"headerlink\" title=\"新建项目文件及文件夹\"></a>新建项目文件及文件夹</h3><p>文件目录如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">express-sticky-note</div><div class=\"line\">  bin</div><div class=\"line\">    www</div><div class=\"line\">  public      // 发布上线的文件，也就是将src文件夹下的文件压缩打包后输出到该文件夹下</div><div class=\"line\">    css</div><div class=\"line\">    js</div><div class=\"line\">    imgs</div><div class=\"line\">    fonts</div><div class=\"line\">  routes</div><div class=\"line\">  src         // 前端源文件</div><div class=\"line\">    imgs</div><div class=\"line\">    js</div><div class=\"line\">    scss</div><div class=\"line\">    webpack.config.js   // webpack的配置文件，因为在该项目中，只在前端用到了webpack，所以将该文件放在src文件夹下，如果是后端也使用到了，那么就可以将其放在主目录下</div><div class=\"line\">  views</div><div class=\"line\">    error.ejs</div><div class=\"line\">    index.ejs</div><div class=\"line\">  app.js</div><div class=\"line\">  package.json</div></pre></td></tr></table></figure></p>\n<h3 id=\"配置工程化\"><a href=\"#配置工程化\" class=\"headerlink\" title=\"配置工程化\"></a>配置工程化</h3><p><strong>对webpack进行配置</strong></p>\n<p><strong>重要：</strong>在配置之前，先要明确需要的功能，然后再编写几个简单的文件对环境进行测试，确保配置没有错误后，再进行正式代码的编写</p>\n<ul>\n<li><p>测试webpack模块化功能配置<br>在mod文件夹下定义两个文件a.js和b.js，在b.js中引用a.js，然后在app的index.js中引入b.js，然后打印b.js中的内容，最后使用webpack打包输出到public/js文件夹下，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// a.js</div><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">// module.exports 导出的是一个对象</div><div class=\"line\">module.exports.a = &apos;我是aaabbbbccc&apos;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// b.js</div><div class=\"line\"> &apos;use strict&apos;;</div><div class=\"line\"> var a = require(&apos;./a.js&apos;).a;</div><div class=\"line\"> module.exports = &#123;</div><div class=\"line\">   b: &apos;bbb&apos;,</div><div class=\"line\">   a: a</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// index.js</div><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">var obj = require(&apos;../mod/b.js&apos;);</div><div class=\"line\">console.log(obj);</div></pre></td></tr></table></figure>\n<p>webpack.config.js中的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">var path = require(&apos;path&apos;);</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  // 文件入口</div><div class=\"line\">  entry: path.join(__dirname, &quot;js/app/index.js&quot;),</div><div class=\"line\">  // 打包文件输出路径</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.join(__dirname, &quot;../public/js&quot;),</div><div class=\"line\">    filename: &quot;index.js&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>实现文件更新后自动打包输出<br>通过<code>onchange</code>模块来对文件进行监控，然后执行响应的npm命令<br>安装<code>onchang</code>: <code>npm install onchange --save-dev</code><br>通过<code>npm scripts</code>实现命令，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;scripts&quot;: &#123;</div><div class=\"line\">  &quot;start&quot;: &quot;PORT=8080 node ./bin/www&quot;,</div><div class=\"line\">  &quot;webpack&quot;: &quot;webpack --config=src/webpack.config.js&quot;,</div><div class=\"line\">  &quot;watch&quot;: &quot;onchange \\&quot;src/**/*.js\\&quot; \\&quot;src/**/*.scss\\&quot; -- npm run webpack&quot;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>只需要执行<code>npm run watch</code> 就会对文件进行监控然后执行打包命令<br><strong>注意：</strong> 在windows下 <code>&quot;onchange \\&quot;src/**/*.js\\&quot; \\&quot;src/**/*.scss\\&quot; -</code> 文件的路径需要使用双引号，并且通过”\\”反斜杠进行转义</p>\n<h2 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h2><h3 id=\"什么是Express\"><a href=\"#什么是Express\" class=\"headerlink\" title=\"什么是Express\"></a>什么是Express</h3><p>高度包容、快速而极简的Node.js Web框架</p>\n</li>\n</ul>\n<h3 id=\"Express的特点\"><a href=\"#Express的特点\" class=\"headerlink\" title=\"Express的特点\"></a>Express的特点</h3><h3 id=\"Express的用法\"><a href=\"#Express的用法\" class=\"headerlink\" title=\"Express的用法\"></a>Express的用法</h3><p>Express中最重要的三部分：<strong>中间件</strong>、<strong>路由</strong>和 <strong>中间件</strong></p>\n<h4 id=\"中间件-Middleware\"><a href=\"#中间件-Middleware\" class=\"headerlink\" title=\"中间件(Middleware)\"></a>中间件(Middleware)</h4><h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><h4 id=\"模板引擎\"><a href=\"#模板引擎\" class=\"headerlink\" title=\"模板引擎\"></a>模板引擎</h4><h4 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h4><p>通过<code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));</code>对静态资源进行拦截处理，也就是说当请求的是静态资源，则直接到当前目录下的public文件夹中去查找数据</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>使用<code>PORT=8000 node ./bin/www</code> 来启动服务器时，不能指定端口为80，因为80端口一般是给管理员来使用的，需要使用sudo来运行该命令，这主要是针对linux服务器<br><strong>参考</strong><ul>\n<li><a href=\"http://expressjs.com/zh-cn/\" target=\"_blank\" rel=\"external\">官方文档</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一些知识点\"><a href=\"#一些知识点\" class=\"headerlink\" title=\"一些知识点\"></a>一些知识点</h2><ul>\n<li><p>控制路由的跳转的就是MVC中的Controller；与数据库交互，向外界提供比较友好的数据接口就是Model；面向用户的展示就是View(试图)</p>\n</li>\n<li><p>项目开发中文件的结构划分方式：<strong>按应用划分</strong> 和 <strong>按功能划分</strong><br>按应用划分：例如一个网站中，有多个页面，那么可以将多个页面的js文件放到app的文件夹中，这就是按应用划分<br>按功能划分：将引用的库放在lib文件夹中，模块放在mod文件夹中，这就是按功能划分，也就是根据代码功能的不同，将其划分到不同的文件夹中<br>参考：<a href=\"https://segmentfault.com/a/1190000010384268\" target=\"_blank\" rel=\"external\">文件的划分方式</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"包安装\"><a href=\"#包安装\" class=\"headerlink\" title=\"包安装\"></a>包安装</h3><ul>\n<li>express安装<br><code>npm install express --save</code></li>\n<li>express 脚手架生成器安装<br><code>npm install express-generator --save-dev</code><br>作用：搭建一个网站应该有的框架</li>\n<li>使用<code>express-generator</code>在当前目录下生成应用<br>因为<code>express-generator</code>是安装在本地的，所以不能直接使用express生成，需要找到<code>express-generator</code>的安装目录下bin文件夹中的.js文件执行<br>可以通过<code>./node_modules/express-generator/bin/express-cli.js -h</code>查看该命令支持的参数，<br>执行命令：<code>./node_modules/express-generator/bin/express-cli.js . -f -e</code><br>解释：”.”： 表示在当前目录生成应用<pre><code>&quot;-f&quot;：强制在非空的文件夹下执行命令\n</code></pre>  “-e”：使用ejs引擎</li>\n</ul>\n<p><strong>注意</strong>：包一般安装在本地</p>\n<h3 id=\"运行express的测试代码\"><a href=\"#运行express的测试代码\" class=\"headerlink\" title=\"运行express的测试代码\"></a>运行express的测试代码</h3><h3 id=\"新建项目文件及文件夹\"><a href=\"#新建项目文件及文件夹\" class=\"headerlink\" title=\"新建项目文件及文件夹\"></a>新建项目文件及文件夹</h3><p>文件目录如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">express-sticky-note</div><div class=\"line\">  bin</div><div class=\"line\">    www</div><div class=\"line\">  public      // 发布上线的文件，也就是将src文件夹下的文件压缩打包后输出到该文件夹下</div><div class=\"line\">    css</div><div class=\"line\">    js</div><div class=\"line\">    imgs</div><div class=\"line\">    fonts</div><div class=\"line\">  routes</div><div class=\"line\">  src         // 前端源文件</div><div class=\"line\">    imgs</div><div class=\"line\">    js</div><div class=\"line\">    scss</div><div class=\"line\">    webpack.config.js   // webpack的配置文件，因为在该项目中，只在前端用到了webpack，所以将该文件放在src文件夹下，如果是后端也使用到了，那么就可以将其放在主目录下</div><div class=\"line\">  views</div><div class=\"line\">    error.ejs</div><div class=\"line\">    index.ejs</div><div class=\"line\">  app.js</div><div class=\"line\">  package.json</div></pre></td></tr></table></figure></p>\n<h3 id=\"配置工程化\"><a href=\"#配置工程化\" class=\"headerlink\" title=\"配置工程化\"></a>配置工程化</h3><p><strong>对webpack进行配置</strong></p>\n<p><strong>重要：</strong>在配置之前，先要明确需要的功能，然后再编写几个简单的文件对环境进行测试，确保配置没有错误后，再进行正式代码的编写</p>\n<ul>\n<li><p>测试webpack模块化功能配置<br>在mod文件夹下定义两个文件a.js和b.js，在b.js中引用a.js，然后在app的index.js中引入b.js，然后打印b.js中的内容，最后使用webpack打包输出到public/js文件夹下，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// a.js</div><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">// module.exports 导出的是一个对象</div><div class=\"line\">module.exports.a = &apos;我是aaabbbbccc&apos;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// b.js</div><div class=\"line\"> &apos;use strict&apos;;</div><div class=\"line\"> var a = require(&apos;./a.js&apos;).a;</div><div class=\"line\"> module.exports = &#123;</div><div class=\"line\">   b: &apos;bbb&apos;,</div><div class=\"line\">   a: a</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// index.js</div><div class=\"line\">&apos;use strict&apos;;</div><div class=\"line\">var obj = require(&apos;../mod/b.js&apos;);</div><div class=\"line\">console.log(obj);</div></pre></td></tr></table></figure>\n<p>webpack.config.js中的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">var webpack = require(&apos;webpack&apos;);</div><div class=\"line\">var path = require(&apos;path&apos;);</div><div class=\"line\"></div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  // 文件入口</div><div class=\"line\">  entry: path.join(__dirname, &quot;js/app/index.js&quot;),</div><div class=\"line\">  // 打包文件输出路径</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.join(__dirname, &quot;../public/js&quot;),</div><div class=\"line\">    filename: &quot;index.js&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>实现文件更新后自动打包输出<br>通过<code>onchange</code>模块来对文件进行监控，然后执行响应的npm命令<br>安装<code>onchang</code>: <code>npm install onchange --save-dev</code><br>通过<code>npm scripts</code>实现命令，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;scripts&quot;: &#123;</div><div class=\"line\">  &quot;start&quot;: &quot;PORT=8080 node ./bin/www&quot;,</div><div class=\"line\">  &quot;webpack&quot;: &quot;webpack --config=src/webpack.config.js&quot;,</div><div class=\"line\">  &quot;watch&quot;: &quot;onchange \\&quot;src/**/*.js\\&quot; \\&quot;src/**/*.scss\\&quot; -- npm run webpack&quot;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>只需要执行<code>npm run watch</code> 就会对文件进行监控然后执行打包命令<br><strong>注意：</strong> 在windows下 <code>&quot;onchange \\&quot;src/**/*.js\\&quot; \\&quot;src/**/*.scss\\&quot; -</code> 文件的路径需要使用双引号，并且通过”\\”反斜杠进行转义</p>\n<h2 id=\"Express\"><a href=\"#Express\" class=\"headerlink\" title=\"Express\"></a>Express</h2><h3 id=\"什么是Express\"><a href=\"#什么是Express\" class=\"headerlink\" title=\"什么是Express\"></a>什么是Express</h3><p>高度包容、快速而极简的Node.js Web框架</p>\n</li>\n</ul>\n<h3 id=\"Express的特点\"><a href=\"#Express的特点\" class=\"headerlink\" title=\"Express的特点\"></a>Express的特点</h3><h3 id=\"Express的用法\"><a href=\"#Express的用法\" class=\"headerlink\" title=\"Express的用法\"></a>Express的用法</h3><p>Express中最重要的三部分：<strong>中间件</strong>、<strong>路由</strong>和 <strong>中间件</strong></p>\n<h4 id=\"中间件-Middleware\"><a href=\"#中间件-Middleware\" class=\"headerlink\" title=\"中间件(Middleware)\"></a>中间件(Middleware)</h4><h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><h4 id=\"模板引擎\"><a href=\"#模板引擎\" class=\"headerlink\" title=\"模板引擎\"></a>模板引擎</h4><h4 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h4><p>通过<code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));</code>对静态资源进行拦截处理，也就是说当请求的是静态资源，则直接到当前目录下的public文件夹中去查找数据</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>使用<code>PORT=8000 node ./bin/www</code> 来启动服务器时，不能指定端口为80，因为80端口一般是给管理员来使用的，需要使用sudo来运行该命令，这主要是针对linux服务器<br><strong>参考</strong><ul>\n<li><a href=\"http://expressjs.com/zh-cn/\" target=\"_blank\" rel=\"external\">官方文档</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一些知识点\"><a href=\"#一些知识点\" class=\"headerlink\" title=\"一些知识点\"></a>一些知识点</h2><ul>\n<li><p>控制路由的跳转的就是MVC中的Controller；与数据库交互，向外界提供比较友好的数据接口就是Model；面向用户的展示就是View(试图)</p>\n</li>\n<li><p>项目开发中文件的结构划分方式：<strong>按应用划分</strong> 和 <strong>按功能划分</strong><br>按应用划分：例如一个网站中，有多个页面，那么可以将多个页面的js文件放到app的文件夹中，这就是按应用划分<br>按功能划分：将引用的库放在lib文件夹中，模块放在mod文件夹中，这就是按功能划分，也就是根据代码功能的不同，将其划分到不同的文件夹中<br>参考：<a href=\"https://segmentfault.com/a/1190000010384268\" target=\"_blank\" rel=\"external\">文件的划分方式</a></p>\n</li>\n</ul>\n"},{"title":"前端单元测试初探","date":"2017-09-11T08:03:26.000Z","_content":"## 什么是单元测试(what?)\n单元测试又称为 **模块测试**，指针对 **程序模块**(最小可测试部件)进行正确性检测的测试工作。\n\n**程序模块**\n分为两类：**过程化编程** 和 **面试对象编程**\n对于过程化编程而言：可能是单个程序、函数、过程等\n对于面向对象编程而言，最小单元就是 **方法**，包括基类(超类)、抽象类、或者派生类中的方法\n\n对于JavaScript来说，通常也是针对 **函数**、**对象**和 **模块**的测试\n\n## 为什么进行单元测试(why?)\n>经验表明一个尽责的单元测试方法将会在软件开发的某个阶段发现很多的Bug，并且修改它们的成本也很低。在软件开发的后期阶段，Bug的发现并修改将会变得更加困难，并要消耗大量的时间和开发费用。无论什么时候作出修改都要进行完整的回归测试，在生命周期中尽早地对软件产品进行测试将使效率和质量得到最好的保证。在提供了经过测试的单元的情况下，系统集成过程将会大大地简化。开发人员可以将精力集中在单元之间的交互作用和全局的功能实现上，而不是陷入充满很多Bug的单元之中不能自拔。——百度百科\n\n \n\n## 怎样进行单元测试(how?)\n- 测试管理工具\n  主要用来管理和组织整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行测试代码，进行测试。\n  代表有：[karma 测试框架的前世今生 ](http://taobaofed.org/blog/2016/01/08/karma-origin/)\n\n- 测试框架\n  测试框架是单元测试的核心，它提供了单元测试所需的各种API，你可以使用它们来对代码进行单元测试\n  Javascript的测试框架很多，具体对比可以参考：[javascript单元测试](http://www.cnblogs.com/frostbelt/archive/2012/08/03/2622302.html)\n\n- 断言库\n  用于描述具体测试的API，有了它们，你的测试代码便能简单直接，也更加语义化。\n  测试断言库的选择也不少：better-assert、should.js、expect.js、chai.js等等（有关它们的对比，可以参考[几款前端测试断言库(Assertions lib)的选型总结](http://blog.lvscar.info/post/tech/assertions_lib/)\n\n有了上面的三个工具，你就可以开始对你的node代码进行测试了。但是如果想要对前端代码进行测试，还需要另外一个工具:\n\n- 测试浏览器\n  前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持 **调用**和运行 **本地浏览器** 来进行测试，如果测试仅仅是针对函数或模块的单元测试，则完全可以使用一款无界面的浏览器：**PhantomJs**\n\n另外，还有一个很重要的事情就是测试覆盖率的统计。一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。\n\n - 测试覆盖率统计工具\n  Karma-Coverage是Karma官方提供的覆盖率统计插件，自然成为项目的首选。\n\n\n\n\n\n## 参考\n- [前端自动化单元测试初探](http://www.jianshu.com/p/6726c0410650)\n\n","source":"_posts/前端单元测试初探.md","raw":"---\ntitle: 前端单元测试初探\ndate: 2017-09-11 16:03:26\ncategories:\ntags: WEB\n---\n## 什么是单元测试(what?)\n单元测试又称为 **模块测试**，指针对 **程序模块**(最小可测试部件)进行正确性检测的测试工作。\n\n**程序模块**\n分为两类：**过程化编程** 和 **面试对象编程**\n对于过程化编程而言：可能是单个程序、函数、过程等\n对于面向对象编程而言，最小单元就是 **方法**，包括基类(超类)、抽象类、或者派生类中的方法\n\n对于JavaScript来说，通常也是针对 **函数**、**对象**和 **模块**的测试\n\n## 为什么进行单元测试(why?)\n>经验表明一个尽责的单元测试方法将会在软件开发的某个阶段发现很多的Bug，并且修改它们的成本也很低。在软件开发的后期阶段，Bug的发现并修改将会变得更加困难，并要消耗大量的时间和开发费用。无论什么时候作出修改都要进行完整的回归测试，在生命周期中尽早地对软件产品进行测试将使效率和质量得到最好的保证。在提供了经过测试的单元的情况下，系统集成过程将会大大地简化。开发人员可以将精力集中在单元之间的交互作用和全局的功能实现上，而不是陷入充满很多Bug的单元之中不能自拔。——百度百科\n\n \n\n## 怎样进行单元测试(how?)\n- 测试管理工具\n  主要用来管理和组织整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行测试代码，进行测试。\n  代表有：[karma 测试框架的前世今生 ](http://taobaofed.org/blog/2016/01/08/karma-origin/)\n\n- 测试框架\n  测试框架是单元测试的核心，它提供了单元测试所需的各种API，你可以使用它们来对代码进行单元测试\n  Javascript的测试框架很多，具体对比可以参考：[javascript单元测试](http://www.cnblogs.com/frostbelt/archive/2012/08/03/2622302.html)\n\n- 断言库\n  用于描述具体测试的API，有了它们，你的测试代码便能简单直接，也更加语义化。\n  测试断言库的选择也不少：better-assert、should.js、expect.js、chai.js等等（有关它们的对比，可以参考[几款前端测试断言库(Assertions lib)的选型总结](http://blog.lvscar.info/post/tech/assertions_lib/)\n\n有了上面的三个工具，你就可以开始对你的node代码进行测试了。但是如果想要对前端代码进行测试，还需要另外一个工具:\n\n- 测试浏览器\n  前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持 **调用**和运行 **本地浏览器** 来进行测试，如果测试仅仅是针对函数或模块的单元测试，则完全可以使用一款无界面的浏览器：**PhantomJs**\n\n另外，还有一个很重要的事情就是测试覆盖率的统计。一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。\n\n - 测试覆盖率统计工具\n  Karma-Coverage是Karma官方提供的覆盖率统计插件，自然成为项目的首选。\n\n\n\n\n\n## 参考\n- [前端自动化单元测试初探](http://www.jianshu.com/p/6726c0410650)\n\n","slug":"前端单元测试初探","published":1,"updated":"2017-09-27T01:03:49.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7getz000yekrixjuys0yp","content":"<h2 id=\"什么是单元测试-what\"><a href=\"#什么是单元测试-what\" class=\"headerlink\" title=\"什么是单元测试(what?)\"></a>什么是单元测试(what?)</h2><p>单元测试又称为 <strong>模块测试</strong>，指针对 <strong>程序模块</strong>(最小可测试部件)进行正确性检测的测试工作。</p>\n<p><strong>程序模块</strong><br>分为两类：<strong>过程化编程</strong> 和 <strong>面试对象编程</strong><br>对于过程化编程而言：可能是单个程序、函数、过程等<br>对于面向对象编程而言，最小单元就是 <strong>方法</strong>，包括基类(超类)、抽象类、或者派生类中的方法</p>\n<p>对于JavaScript来说，通常也是针对 <strong>函数</strong>、<strong>对象</strong>和 <strong>模块</strong>的测试</p>\n<h2 id=\"为什么进行单元测试-why\"><a href=\"#为什么进行单元测试-why\" class=\"headerlink\" title=\"为什么进行单元测试(why?)\"></a>为什么进行单元测试(why?)</h2><blockquote>\n<p>经验表明一个尽责的单元测试方法将会在软件开发的某个阶段发现很多的Bug，并且修改它们的成本也很低。在软件开发的后期阶段，Bug的发现并修改将会变得更加困难，并要消耗大量的时间和开发费用。无论什么时候作出修改都要进行完整的回归测试，在生命周期中尽早地对软件产品进行测试将使效率和质量得到最好的保证。在提供了经过测试的单元的情况下，系统集成过程将会大大地简化。开发人员可以将精力集中在单元之间的交互作用和全局的功能实现上，而不是陷入充满很多Bug的单元之中不能自拔。——百度百科</p>\n</blockquote>\n<h2 id=\"怎样进行单元测试-how\"><a href=\"#怎样进行单元测试-how\" class=\"headerlink\" title=\"怎样进行单元测试(how?)\"></a>怎样进行单元测试(how?)</h2><ul>\n<li><p>测试管理工具<br>主要用来管理和组织整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行测试代码，进行测试。<br>代表有：<a href=\"http://taobaofed.org/blog/2016/01/08/karma-origin/\" target=\"_blank\" rel=\"external\">karma 测试框架的前世今生 </a></p>\n</li>\n<li><p>测试框架<br>测试框架是单元测试的核心，它提供了单元测试所需的各种API，你可以使用它们来对代码进行单元测试<br>Javascript的测试框架很多，具体对比可以参考：<a href=\"http://www.cnblogs.com/frostbelt/archive/2012/08/03/2622302.html\" target=\"_blank\" rel=\"external\">javascript单元测试</a></p>\n</li>\n<li><p>断言库<br>用于描述具体测试的API，有了它们，你的测试代码便能简单直接，也更加语义化。<br>测试断言库的选择也不少：better-assert、should.js、expect.js、chai.js等等（有关它们的对比，可以参考<a href=\"http://blog.lvscar.info/post/tech/assertions_lib/\" target=\"_blank\" rel=\"external\">几款前端测试断言库(Assertions lib)的选型总结</a></p>\n</li>\n</ul>\n<p>有了上面的三个工具，你就可以开始对你的node代码进行测试了。但是如果想要对前端代码进行测试，还需要另外一个工具:</p>\n<ul>\n<li>测试浏览器<br>前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持 <strong>调用</strong>和运行 <strong>本地浏览器</strong> 来进行测试，如果测试仅仅是针对函数或模块的单元测试，则完全可以使用一款无界面的浏览器：<strong>PhantomJs</strong></li>\n</ul>\n<p>另外，还有一个很重要的事情就是测试覆盖率的统计。一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。</p>\n<ul>\n<li>测试覆盖率统计工具<br>Karma-Coverage是Karma官方提供的覆盖率统计插件，自然成为项目的首选。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/6726c0410650\" target=\"_blank\" rel=\"external\">前端自动化单元测试初探</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是单元测试-what\"><a href=\"#什么是单元测试-what\" class=\"headerlink\" title=\"什么是单元测试(what?)\"></a>什么是单元测试(what?)</h2><p>单元测试又称为 <strong>模块测试</strong>，指针对 <strong>程序模块</strong>(最小可测试部件)进行正确性检测的测试工作。</p>\n<p><strong>程序模块</strong><br>分为两类：<strong>过程化编程</strong> 和 <strong>面试对象编程</strong><br>对于过程化编程而言：可能是单个程序、函数、过程等<br>对于面向对象编程而言，最小单元就是 <strong>方法</strong>，包括基类(超类)、抽象类、或者派生类中的方法</p>\n<p>对于JavaScript来说，通常也是针对 <strong>函数</strong>、<strong>对象</strong>和 <strong>模块</strong>的测试</p>\n<h2 id=\"为什么进行单元测试-why\"><a href=\"#为什么进行单元测试-why\" class=\"headerlink\" title=\"为什么进行单元测试(why?)\"></a>为什么进行单元测试(why?)</h2><blockquote>\n<p>经验表明一个尽责的单元测试方法将会在软件开发的某个阶段发现很多的Bug，并且修改它们的成本也很低。在软件开发的后期阶段，Bug的发现并修改将会变得更加困难，并要消耗大量的时间和开发费用。无论什么时候作出修改都要进行完整的回归测试，在生命周期中尽早地对软件产品进行测试将使效率和质量得到最好的保证。在提供了经过测试的单元的情况下，系统集成过程将会大大地简化。开发人员可以将精力集中在单元之间的交互作用和全局的功能实现上，而不是陷入充满很多Bug的单元之中不能自拔。——百度百科</p>\n</blockquote>\n<h2 id=\"怎样进行单元测试-how\"><a href=\"#怎样进行单元测试-how\" class=\"headerlink\" title=\"怎样进行单元测试(how?)\"></a>怎样进行单元测试(how?)</h2><ul>\n<li><p>测试管理工具<br>主要用来管理和组织整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行测试代码，进行测试。<br>代表有：<a href=\"http://taobaofed.org/blog/2016/01/08/karma-origin/\" target=\"_blank\" rel=\"external\">karma 测试框架的前世今生 </a></p>\n</li>\n<li><p>测试框架<br>测试框架是单元测试的核心，它提供了单元测试所需的各种API，你可以使用它们来对代码进行单元测试<br>Javascript的测试框架很多，具体对比可以参考：<a href=\"http://www.cnblogs.com/frostbelt/archive/2012/08/03/2622302.html\" target=\"_blank\" rel=\"external\">javascript单元测试</a></p>\n</li>\n<li><p>断言库<br>用于描述具体测试的API，有了它们，你的测试代码便能简单直接，也更加语义化。<br>测试断言库的选择也不少：better-assert、should.js、expect.js、chai.js等等（有关它们的对比，可以参考<a href=\"http://blog.lvscar.info/post/tech/assertions_lib/\" target=\"_blank\" rel=\"external\">几款前端测试断言库(Assertions lib)的选型总结</a></p>\n</li>\n</ul>\n<p>有了上面的三个工具，你就可以开始对你的node代码进行测试了。但是如果想要对前端代码进行测试，还需要另外一个工具:</p>\n<ul>\n<li>测试浏览器<br>前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持 <strong>调用</strong>和运行 <strong>本地浏览器</strong> 来进行测试，如果测试仅仅是针对函数或模块的单元测试，则完全可以使用一款无界面的浏览器：<strong>PhantomJs</strong></li>\n</ul>\n<p>另外，还有一个很重要的事情就是测试覆盖率的统计。一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。</p>\n<ul>\n<li>测试覆盖率统计工具<br>Karma-Coverage是Karma官方提供的覆盖率统计插件，自然成为项目的首选。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://www.jianshu.com/p/6726c0410650\" target=\"_blank\" rel=\"external\">前端自动化单元测试初探</a></li>\n</ul>\n"},{"title":"预加载","date":"2017-09-09T06:57:32.000Z","_content":"图片预加载的方法\n## CSS 实现法\n\n## JS 实现法\n\n## ajax 实现图片、js、css等文件的预加载\n","source":"_posts/预加载.md","raw":"---\ntitle: 预加载\ndate: 2017-09-09 14:57:32\ncategories:\ntags: 性能优化\n---\n图片预加载的方法\n## CSS 实现法\n\n## JS 实现法\n\n## ajax 实现图片、js、css等文件的预加载\n","slug":"预加载","published":1,"updated":"2017-09-09T07:14:28.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7geu2000zekrig6s8l1uo","content":"<p>图片预加载的方法</p>\n<h2 id=\"CSS-实现法\"><a href=\"#CSS-实现法\" class=\"headerlink\" title=\"CSS 实现法\"></a>CSS 实现法</h2><h2 id=\"JS-实现法\"><a href=\"#JS-实现法\" class=\"headerlink\" title=\"JS 实现法\"></a>JS 实现法</h2><h2 id=\"ajax-实现图片、js、css等文件的预加载\"><a href=\"#ajax-实现图片、js、css等文件的预加载\" class=\"headerlink\" title=\"ajax 实现图片、js、css等文件的预加载\"></a>ajax 实现图片、js、css等文件的预加载</h2>","site":{"data":{}},"excerpt":"","more":"<p>图片预加载的方法</p>\n<h2 id=\"CSS-实现法\"><a href=\"#CSS-实现法\" class=\"headerlink\" title=\"CSS 实现法\"></a>CSS 实现法</h2><h2 id=\"JS-实现法\"><a href=\"#JS-实现法\" class=\"headerlink\" title=\"JS 实现法\"></a>JS 实现法</h2><h2 id=\"ajax-实现图片、js、css等文件的预加载\"><a href=\"#ajax-实现图片、js、css等文件的预加载\" class=\"headerlink\" title=\"ajax 实现图片、js、css等文件的预加载\"></a>ajax 实现图片、js、css等文件的预加载</h2>"},{"title":"callee和caller用法和区别","date":"2017-09-10T03:04:14.000Z","_content":"## 简介\n从字面上看，`callee`的意思是*被调用者*， `caller`的意思是*调用者*；\n在JavaScript MDN上可以看到比较官方的解释：\n- [callee](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee): 指向当前被调用的函数\n- [caller](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller): 指向调用当前函数的函数\n\n## 用法\n```\nvar readBook = function(){\n    console.log(arguments.callee);//这里返回的是readBook函数\n    console.log(arguments.caller);//这里返回的应该是go函数，注意是“应该”\n};\nvar go = function(){\n    readBook();\n};\ngo();\n```\n然而运行一下这串代码就会发现，callee确实是返回正在执行的参数readBook，而caller返回的是undefined。\n\n在[caller的官方文档中](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller)可以发现，`arguments.caller`已经不被推荐，但是可以仍然可以通过`Function.caller`访问，\n\n如:\n```\nfunction whoCalled() {\n   if (whoCalled.caller == null)\n      console.log('I was called from the global scope.');\n   else\n      console.log(whoCalled.caller + ' called me!');\n}\n```\n\n## 注意\n值得注意的是，在 **严格模式**下，使用`arguments.callee`和`Function.caller`时浏览器都会抛出错误，还有在 **严格模式**下，假如给caller属性赋值的话，同样也会抛出错误。\n\n## 实例\n在实现递归的时候，可以达到解耦的作用，我们可以不必理会函数名是什么。例如下面的阶乘函数：\n```\nfunction factorial(number){\n  if(number <= 1){\n    return 1;\n  }else{\n    return number*arguments.callee(number-1);\n  }\n}\nfactorial(100);\n```\n\n## 兼容性\n几乎所有浏览器都支持 **callee**属性，而对于 **caller**则并基本上不支持，尽量不要使用。\n\n## 参考\n[caller](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller)\n[callee](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee)\n","source":"_posts/callee和caller用法和区别.md","raw":"---\ntitle: callee和caller用法和区别\ndate: 2017-09-10 11:04:14\ncategories:\ntags: Javascript\n---\n## 简介\n从字面上看，`callee`的意思是*被调用者*， `caller`的意思是*调用者*；\n在JavaScript MDN上可以看到比较官方的解释：\n- [callee](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee): 指向当前被调用的函数\n- [caller](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller): 指向调用当前函数的函数\n\n## 用法\n```\nvar readBook = function(){\n    console.log(arguments.callee);//这里返回的是readBook函数\n    console.log(arguments.caller);//这里返回的应该是go函数，注意是“应该”\n};\nvar go = function(){\n    readBook();\n};\ngo();\n```\n然而运行一下这串代码就会发现，callee确实是返回正在执行的参数readBook，而caller返回的是undefined。\n\n在[caller的官方文档中](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller)可以发现，`arguments.caller`已经不被推荐，但是可以仍然可以通过`Function.caller`访问，\n\n如:\n```\nfunction whoCalled() {\n   if (whoCalled.caller == null)\n      console.log('I was called from the global scope.');\n   else\n      console.log(whoCalled.caller + ' called me!');\n}\n```\n\n## 注意\n值得注意的是，在 **严格模式**下，使用`arguments.callee`和`Function.caller`时浏览器都会抛出错误，还有在 **严格模式**下，假如给caller属性赋值的话，同样也会抛出错误。\n\n## 实例\n在实现递归的时候，可以达到解耦的作用，我们可以不必理会函数名是什么。例如下面的阶乘函数：\n```\nfunction factorial(number){\n  if(number <= 1){\n    return 1;\n  }else{\n    return number*arguments.callee(number-1);\n  }\n}\nfactorial(100);\n```\n\n## 兼容性\n几乎所有浏览器都支持 **callee**属性，而对于 **caller**则并基本上不支持，尽量不要使用。\n\n## 参考\n[caller](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller)\n[callee](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee)\n","slug":"callee和caller用法和区别","published":1,"updated":"2017-09-10T03:25:13.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7geu60013ekrifjh6lef0","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>从字面上看，<code>callee</code>的意思是<em>被调用者</em>， <code>caller</code>的意思是<em>调用者</em>；<br>在JavaScript MDN上可以看到比较官方的解释：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee\" target=\"_blank\" rel=\"external\">callee</a>: 指向当前被调用的函数</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller\" target=\"_blank\" rel=\"external\">caller</a>: 指向调用当前函数的函数</li>\n</ul>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var readBook = function()&#123;</div><div class=\"line\">    console.log(arguments.callee);//这里返回的是readBook函数</div><div class=\"line\">    console.log(arguments.caller);//这里返回的应该是go函数，注意是“应该”</div><div class=\"line\">&#125;;</div><div class=\"line\">var go = function()&#123;</div><div class=\"line\">    readBook();</div><div class=\"line\">&#125;;</div><div class=\"line\">go();</div></pre></td></tr></table></figure>\n<p>然而运行一下这串代码就会发现，callee确实是返回正在执行的参数readBook，而caller返回的是undefined。</p>\n<p>在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller\" target=\"_blank\" rel=\"external\">caller的官方文档中</a>可以发现，<code>arguments.caller</code>已经不被推荐，但是可以仍然可以通过<code>Function.caller</code>访问，</p>\n<p>如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function whoCalled() &#123;</div><div class=\"line\">   if (whoCalled.caller == null)</div><div class=\"line\">      console.log(&apos;I was called from the global scope.&apos;);</div><div class=\"line\">   else</div><div class=\"line\">      console.log(whoCalled.caller + &apos; called me!&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>值得注意的是，在 <strong>严格模式</strong>下，使用<code>arguments.callee</code>和<code>Function.caller</code>时浏览器都会抛出错误，还有在 <strong>严格模式</strong>下，假如给caller属性赋值的话，同样也会抛出错误。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>在实现递归的时候，可以达到解耦的作用，我们可以不必理会函数名是什么。例如下面的阶乘函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function factorial(number)&#123;</div><div class=\"line\">  if(number &lt;= 1)&#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;else&#123;</div><div class=\"line\">    return number*arguments.callee(number-1);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">factorial(100);</div></pre></td></tr></table></figure></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>几乎所有浏览器都支持 <strong>callee</strong>属性，而对于 <strong>caller</strong>则并基本上不支持，尽量不要使用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller\" target=\"_blank\" rel=\"external\">caller</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee\" target=\"_blank\" rel=\"external\">callee</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>从字面上看，<code>callee</code>的意思是<em>被调用者</em>， <code>caller</code>的意思是<em>调用者</em>；<br>在JavaScript MDN上可以看到比较官方的解释：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee\" target=\"_blank\" rel=\"external\">callee</a>: 指向当前被调用的函数</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller\" target=\"_blank\" rel=\"external\">caller</a>: 指向调用当前函数的函数</li>\n</ul>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var readBook = function()&#123;</div><div class=\"line\">    console.log(arguments.callee);//这里返回的是readBook函数</div><div class=\"line\">    console.log(arguments.caller);//这里返回的应该是go函数，注意是“应该”</div><div class=\"line\">&#125;;</div><div class=\"line\">var go = function()&#123;</div><div class=\"line\">    readBook();</div><div class=\"line\">&#125;;</div><div class=\"line\">go();</div></pre></td></tr></table></figure>\n<p>然而运行一下这串代码就会发现，callee确实是返回正在执行的参数readBook，而caller返回的是undefined。</p>\n<p>在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller\" target=\"_blank\" rel=\"external\">caller的官方文档中</a>可以发现，<code>arguments.caller</code>已经不被推荐，但是可以仍然可以通过<code>Function.caller</code>访问，</p>\n<p>如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function whoCalled() &#123;</div><div class=\"line\">   if (whoCalled.caller == null)</div><div class=\"line\">      console.log(&apos;I was called from the global scope.&apos;);</div><div class=\"line\">   else</div><div class=\"line\">      console.log(whoCalled.caller + &apos; called me!&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>值得注意的是，在 <strong>严格模式</strong>下，使用<code>arguments.callee</code>和<code>Function.caller</code>时浏览器都会抛出错误，还有在 <strong>严格模式</strong>下，假如给caller属性赋值的话，同样也会抛出错误。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>在实现递归的时候，可以达到解耦的作用，我们可以不必理会函数名是什么。例如下面的阶乘函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function factorial(number)&#123;</div><div class=\"line\">  if(number &lt;= 1)&#123;</div><div class=\"line\">    return 1;</div><div class=\"line\">  &#125;else&#123;</div><div class=\"line\">    return number*arguments.callee(number-1);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">factorial(100);</div></pre></td></tr></table></figure></p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>几乎所有浏览器都支持 <strong>callee</strong>属性，而对于 <strong>caller</strong>则并基本上不支持，尽量不要使用。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/caller\" target=\"_blank\" rel=\"external\">caller</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee\" target=\"_blank\" rel=\"external\">callee</a></p>\n"},{"title":"SEO的一些介绍","date":"2017-09-09T07:27:05.000Z","_content":"## 谈谈以前端角度出发做好SEO需要考虑什么？\n- 了解搜索引擎是如何抓取网页和索引网页\n- Meta标签的优化\n  主要包括：主题(title), 网站描述(Description), 和关键字(keywords)\n- 合理使用标签\n- 如何选取关键词，并在网页中放置关键字\n  搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。\n- 了解主要的搜索引擎\n\n## 前端的性能优化\n**前端优化**\n- 文件压缩，减小文件大小\n- 文件合并，减少http请求，同时可以利用缓存\n- 减少DOM操作，例如在需要遍历DOM时，需要用到DOM节点的长度，可以将其保存起来，而不是去实时查询\n- 使用事件代理绑定事件\n- 利用雪碧图\n\n**体验的优化**\n- 图片懒加载，分页\n- 功能懒加载（html和css先加载，js最后再加载）\n\n**后端优化：**\n- 服务器端开始gzip，那么服务端传输文件就是经过压缩的\n- 增加CDN\n- 添加多个静态资源服务器\n- 将资源放在多个域名下，提高并发\n\n\n## 为什么利用多个域名来存储网站资源会更有效\n- CDN缓存更方便\n- 突破浏览器的并发限制(浏览器的并发限制是基于domain来实现的，目前并发最大支持8个，也就是说同一个域名同一时间，最多发送8个请求，假设有16个资源要访问，那么必须分两次请求，其实这里面应该是当完成一个请求之后，再继续下一个请求，只是最大保持在线请求为8个，如果16个资源都放在一个domain下，那么最少两次请求，才能全部获取到资源，假设将16个资源放在两个域名下，那么就可以同时往两个域名下各发送一次请求，相当于时间减少了一半)\n- 节约cookie 带宽\n- 减少主域名的连接数，从而提高客户端网络带宽的利用率，优化页面响应\n\n\n\n","source":"_posts/性能优化.md","raw":"---\ntitle: SEO的一些介绍\ndate: 2017-09-09 15:27:05\ncategories:\ntags: 性能优化\n---\n## 谈谈以前端角度出发做好SEO需要考虑什么？\n- 了解搜索引擎是如何抓取网页和索引网页\n- Meta标签的优化\n  主要包括：主题(title), 网站描述(Description), 和关键字(keywords)\n- 合理使用标签\n- 如何选取关键词，并在网页中放置关键字\n  搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。\n- 了解主要的搜索引擎\n\n## 前端的性能优化\n**前端优化**\n- 文件压缩，减小文件大小\n- 文件合并，减少http请求，同时可以利用缓存\n- 减少DOM操作，例如在需要遍历DOM时，需要用到DOM节点的长度，可以将其保存起来，而不是去实时查询\n- 使用事件代理绑定事件\n- 利用雪碧图\n\n**体验的优化**\n- 图片懒加载，分页\n- 功能懒加载（html和css先加载，js最后再加载）\n\n**后端优化：**\n- 服务器端开始gzip，那么服务端传输文件就是经过压缩的\n- 增加CDN\n- 添加多个静态资源服务器\n- 将资源放在多个域名下，提高并发\n\n\n## 为什么利用多个域名来存储网站资源会更有效\n- CDN缓存更方便\n- 突破浏览器的并发限制(浏览器的并发限制是基于domain来实现的，目前并发最大支持8个，也就是说同一个域名同一时间，最多发送8个请求，假设有16个资源要访问，那么必须分两次请求，其实这里面应该是当完成一个请求之后，再继续下一个请求，只是最大保持在线请求为8个，如果16个资源都放在一个domain下，那么最少两次请求，才能全部获取到资源，假设将16个资源放在两个域名下，那么就可以同时往两个域名下各发送一次请求，相当于时间减少了一半)\n- 节约cookie 带宽\n- 减少主域名的连接数，从而提高客户端网络带宽的利用率，优化页面响应\n\n\n\n","slug":"性能优化","published":1,"updated":"2017-09-25T08:19:24.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7geu90014ekrim9x477b4","content":"<h2 id=\"谈谈以前端角度出发做好SEO需要考虑什么？\"><a href=\"#谈谈以前端角度出发做好SEO需要考虑什么？\" class=\"headerlink\" title=\"谈谈以前端角度出发做好SEO需要考虑什么？\"></a>谈谈以前端角度出发做好SEO需要考虑什么？</h2><ul>\n<li>了解搜索引擎是如何抓取网页和索引网页</li>\n<li>Meta标签的优化<br>主要包括：主题(title), 网站描述(Description), 和关键字(keywords)</li>\n<li>合理使用标签</li>\n<li>如何选取关键词，并在网页中放置关键字<br>搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。</li>\n<li>了解主要的搜索引擎</li>\n</ul>\n<h2 id=\"前端的性能优化\"><a href=\"#前端的性能优化\" class=\"headerlink\" title=\"前端的性能优化\"></a>前端的性能优化</h2><p><strong>前端优化</strong></p>\n<ul>\n<li>文件压缩，减小文件大小</li>\n<li>文件合并，减少http请求，同时可以利用缓存</li>\n<li>减少DOM操作，例如在需要遍历DOM时，需要用到DOM节点的长度，可以将其保存起来，而不是去实时查询</li>\n<li>使用事件代理绑定事件</li>\n<li>利用雪碧图</li>\n</ul>\n<p><strong>体验的优化</strong></p>\n<ul>\n<li>图片懒加载，分页</li>\n<li>功能懒加载（html和css先加载，js最后再加载）</li>\n</ul>\n<p><strong>后端优化：</strong></p>\n<ul>\n<li>服务器端开始gzip，那么服务端传输文件就是经过压缩的</li>\n<li>增加CDN</li>\n<li>添加多个静态资源服务器</li>\n<li>将资源放在多个域名下，提高并发</li>\n</ul>\n<h2 id=\"为什么利用多个域名来存储网站资源会更有效\"><a href=\"#为什么利用多个域名来存储网站资源会更有效\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源会更有效\"></a>为什么利用多个域名来存储网站资源会更有效</h2><ul>\n<li>CDN缓存更方便</li>\n<li>突破浏览器的并发限制(浏览器的并发限制是基于domain来实现的，目前并发最大支持8个，也就是说同一个域名同一时间，最多发送8个请求，假设有16个资源要访问，那么必须分两次请求，其实这里面应该是当完成一个请求之后，再继续下一个请求，只是最大保持在线请求为8个，如果16个资源都放在一个domain下，那么最少两次请求，才能全部获取到资源，假设将16个资源放在两个域名下，那么就可以同时往两个域名下各发送一次请求，相当于时间减少了一半)</li>\n<li>节约cookie 带宽</li>\n<li>减少主域名的连接数，从而提高客户端网络带宽的利用率，优化页面响应</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"谈谈以前端角度出发做好SEO需要考虑什么？\"><a href=\"#谈谈以前端角度出发做好SEO需要考虑什么？\" class=\"headerlink\" title=\"谈谈以前端角度出发做好SEO需要考虑什么？\"></a>谈谈以前端角度出发做好SEO需要考虑什么？</h2><ul>\n<li>了解搜索引擎是如何抓取网页和索引网页</li>\n<li>Meta标签的优化<br>主要包括：主题(title), 网站描述(Description), 和关键字(keywords)</li>\n<li>合理使用标签</li>\n<li>如何选取关键词，并在网页中放置关键字<br>搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。</li>\n<li>了解主要的搜索引擎</li>\n</ul>\n<h2 id=\"前端的性能优化\"><a href=\"#前端的性能优化\" class=\"headerlink\" title=\"前端的性能优化\"></a>前端的性能优化</h2><p><strong>前端优化</strong></p>\n<ul>\n<li>文件压缩，减小文件大小</li>\n<li>文件合并，减少http请求，同时可以利用缓存</li>\n<li>减少DOM操作，例如在需要遍历DOM时，需要用到DOM节点的长度，可以将其保存起来，而不是去实时查询</li>\n<li>使用事件代理绑定事件</li>\n<li>利用雪碧图</li>\n</ul>\n<p><strong>体验的优化</strong></p>\n<ul>\n<li>图片懒加载，分页</li>\n<li>功能懒加载（html和css先加载，js最后再加载）</li>\n</ul>\n<p><strong>后端优化：</strong></p>\n<ul>\n<li>服务器端开始gzip，那么服务端传输文件就是经过压缩的</li>\n<li>增加CDN</li>\n<li>添加多个静态资源服务器</li>\n<li>将资源放在多个域名下，提高并发</li>\n</ul>\n<h2 id=\"为什么利用多个域名来存储网站资源会更有效\"><a href=\"#为什么利用多个域名来存储网站资源会更有效\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源会更有效\"></a>为什么利用多个域名来存储网站资源会更有效</h2><ul>\n<li>CDN缓存更方便</li>\n<li>突破浏览器的并发限制(浏览器的并发限制是基于domain来实现的，目前并发最大支持8个，也就是说同一个域名同一时间，最多发送8个请求，假设有16个资源要访问，那么必须分两次请求，其实这里面应该是当完成一个请求之后，再继续下一个请求，只是最大保持在线请求为8个，如果16个资源都放在一个domain下，那么最少两次请求，才能全部获取到资源，假设将16个资源放在两个域名下，那么就可以同时往两个域名下各发送一次请求，相当于时间减少了一半)</li>\n<li>节约cookie 带宽</li>\n<li>减少主域名的连接数，从而提高客户端网络带宽的利用率，优化页面响应</li>\n</ul>\n"},{"title":"浏览器兼容性问题总结","date":"2017-09-21T03:15:39.000Z","_content":"## 区分ie6_7_8\n```\n.ie6_7_8 {\n  width: 300px;\n  padding: 40px;\n  background: #f0f3f9;\n  color: blue;          // 所有浏览器\n  color: red\\9;         // IE8 及 以下浏览器\n  *color: green;        // IE7 及 以下浏览器\n  _color: purple;       // IE6 浏览器\n}\n```\n**说明**：\n- 所有浏览器都能识别: `*`;\n- IE8及以下浏览器都能识别: `\\9`;\n- IE6能识别：`_`;\n- IE6不能识别：`!important`，其他浏览器都能识别，但是不建议使用\n所以，所以为了区分i6、ie7和ie8，可以使用上面的顺序来定义属性\n\n## 常见兼容性问题\n### margin和padding\n问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大\n碰到频率：100%\n解决方法：\n  - 使用 `*{margin: 0; padding: 0;}`，作用范围大\n  - 对指定的元素使用`{margin:0; padding:0;}`；如p，h1~h6，input，ul，li，dl，dt，dd等标签，具体情况可以在实际调试中进行修改调整\n\n### 在IE下双边距bug\n问题症状：在IE浏览器下，当为 **块级元素添加float，且浮动元素有`margin-left`或`margin-right`，那么实际的`margin-left和margin-right`要比设置的大一倍**;\n碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）\n解决方法：\n  - 在浮动元素上添加 `display: inline-block` 即可；\"*\"只能被IE识别，对其他的浏览器没有影响\n  \n### 设置一个较小高度的标签(一般小于10px), 在IE6、IE7中，实际高度会超出设置的高度值\n问题症状：在IE6，IE7里的高度不受控制，超出自己设置的高度\n碰到频率：60%\n解决方法：\n  - 给超出高度的标签设置 `overflow: hidden`\n  - 或者设置行高 `line-height` 小于你设置的高度\n备注：这种情况主要出现在我们设置小圆角背景的标签里。出现这个问题的原因是因为 **IE8之前的浏览器不允许元素的高度小于字体的高度**\n\n### 图片默认有边距\n问题症状：几个img标签放在一起的时候，有些浏览器会有默认的边距，即使使用了 `img{margin: 0; padding: 0` 也不起作用\n碰到几率：20%\n解决方法：使用float属性为 img 布局\n备注：因为img标签是行内元素，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距，可使用float布局去除这个间距\n\n### 标签最低高度 min-height 不兼容\n问题症状：在IE6上，设置min-height和min-width无效，为了达到效果统一，需要对IE6另做处理\n碰到几率：5%\n解决方法：**主要利用IE6对`!important`不识别来做处理**\n\n  ```\n   {\n     min-height: 200px;\n     height: auto !important;   \n     height: 200px;  \n   }\n  ```\n  说明：`height: auto !important`  对于现代浏览器，该语句的权重最大，因此，该语句生效，表示标签高度随内容高度而变，但最小高度为200px；因为IE6对 `!important`不识别，因此，该语句无效，所以后面的`height: 200px`生效，**而在IE6中，当内容的高度大于容器的设置高度，容器将会被撑开；如果小于容器高度，则为height值**\n  \n### 列表li的楼梯Bug\n问题症状：li在IE6下呈楼梯状的效果，在IE6下的经典bug；当li里面放了一些float的内容标签，但是li本身不浮动，此时在IE上就会有楼梯出现。代码如下：\n\n  ```\n  <ul>\n      <li><a href=\"#\"></a></li>\n      <li><a href=\"#\"></a></li>\n      <li><a href=\"#\"></a></li>\n  </ul>\n  // css\n  ul {\n    list-style: none;\n  }\n  ul li a {\n    display: block;\n    width: 130px;\n    height: 30px;\n    text-align: center;\n    color: #fff;\n    float: left;\n    background: #95CFEF;\n    border: solid 1px #36f;\n    margin: 30px 5px;\n  }\n  ```\n解决方法：\n  - 在li元素中也加上一个float： `ul li {float: left;}`\n  - 在li元素上应用: `ul li {display: inline-block;}`\n\n### 居中布局\n问题描述：当在container中对content块居中布局，常用`margin: Npx auto`实现，但在IE6下会发现content块没有居中，反而居左对齐了\n解决方法：在父元素container中使用`text-align: center`，而在content中使用`text-align: left;`(防止content中的文本居中)\n\n\n\n","source":"_posts/浏览器兼容性问题总结.md","raw":"---\ntitle: 浏览器兼容性问题总结\ndate: 2017-09-21 11:15:39\ncategories:\ntags: WEB\n---\n## 区分ie6_7_8\n```\n.ie6_7_8 {\n  width: 300px;\n  padding: 40px;\n  background: #f0f3f9;\n  color: blue;          // 所有浏览器\n  color: red\\9;         // IE8 及 以下浏览器\n  *color: green;        // IE7 及 以下浏览器\n  _color: purple;       // IE6 浏览器\n}\n```\n**说明**：\n- 所有浏览器都能识别: `*`;\n- IE8及以下浏览器都能识别: `\\9`;\n- IE6能识别：`_`;\n- IE6不能识别：`!important`，其他浏览器都能识别，但是不建议使用\n所以，所以为了区分i6、ie7和ie8，可以使用上面的顺序来定义属性\n\n## 常见兼容性问题\n### margin和padding\n问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大\n碰到频率：100%\n解决方法：\n  - 使用 `*{margin: 0; padding: 0;}`，作用范围大\n  - 对指定的元素使用`{margin:0; padding:0;}`；如p，h1~h6，input，ul，li，dl，dt，dd等标签，具体情况可以在实际调试中进行修改调整\n\n### 在IE下双边距bug\n问题症状：在IE浏览器下，当为 **块级元素添加float，且浮动元素有`margin-left`或`margin-right`，那么实际的`margin-left和margin-right`要比设置的大一倍**;\n碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）\n解决方法：\n  - 在浮动元素上添加 `display: inline-block` 即可；\"*\"只能被IE识别，对其他的浏览器没有影响\n  \n### 设置一个较小高度的标签(一般小于10px), 在IE6、IE7中，实际高度会超出设置的高度值\n问题症状：在IE6，IE7里的高度不受控制，超出自己设置的高度\n碰到频率：60%\n解决方法：\n  - 给超出高度的标签设置 `overflow: hidden`\n  - 或者设置行高 `line-height` 小于你设置的高度\n备注：这种情况主要出现在我们设置小圆角背景的标签里。出现这个问题的原因是因为 **IE8之前的浏览器不允许元素的高度小于字体的高度**\n\n### 图片默认有边距\n问题症状：几个img标签放在一起的时候，有些浏览器会有默认的边距，即使使用了 `img{margin: 0; padding: 0` 也不起作用\n碰到几率：20%\n解决方法：使用float属性为 img 布局\n备注：因为img标签是行内元素，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距，可使用float布局去除这个间距\n\n### 标签最低高度 min-height 不兼容\n问题症状：在IE6上，设置min-height和min-width无效，为了达到效果统一，需要对IE6另做处理\n碰到几率：5%\n解决方法：**主要利用IE6对`!important`不识别来做处理**\n\n  ```\n   {\n     min-height: 200px;\n     height: auto !important;   \n     height: 200px;  \n   }\n  ```\n  说明：`height: auto !important`  对于现代浏览器，该语句的权重最大，因此，该语句生效，表示标签高度随内容高度而变，但最小高度为200px；因为IE6对 `!important`不识别，因此，该语句无效，所以后面的`height: 200px`生效，**而在IE6中，当内容的高度大于容器的设置高度，容器将会被撑开；如果小于容器高度，则为height值**\n  \n### 列表li的楼梯Bug\n问题症状：li在IE6下呈楼梯状的效果，在IE6下的经典bug；当li里面放了一些float的内容标签，但是li本身不浮动，此时在IE上就会有楼梯出现。代码如下：\n\n  ```\n  <ul>\n      <li><a href=\"#\"></a></li>\n      <li><a href=\"#\"></a></li>\n      <li><a href=\"#\"></a></li>\n  </ul>\n  // css\n  ul {\n    list-style: none;\n  }\n  ul li a {\n    display: block;\n    width: 130px;\n    height: 30px;\n    text-align: center;\n    color: #fff;\n    float: left;\n    background: #95CFEF;\n    border: solid 1px #36f;\n    margin: 30px 5px;\n  }\n  ```\n解决方法：\n  - 在li元素中也加上一个float： `ul li {float: left;}`\n  - 在li元素上应用: `ul li {display: inline-block;}`\n\n### 居中布局\n问题描述：当在container中对content块居中布局，常用`margin: Npx auto`实现，但在IE6下会发现content块没有居中，反而居左对齐了\n解决方法：在父元素container中使用`text-align: center`，而在content中使用`text-align: left;`(防止content中的文本居中)\n\n\n\n","slug":"浏览器兼容性问题总结","published":1,"updated":"2017-09-27T01:10:03.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7geue0017ekriv8zc9f4j","content":"<h2 id=\"区分ie6-7-8\"><a href=\"#区分ie6-7-8\" class=\"headerlink\" title=\"区分ie6_7_8\"></a>区分ie6_7_8</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.ie6_7_8 &#123;</div><div class=\"line\">  width: 300px;</div><div class=\"line\">  padding: 40px;</div><div class=\"line\">  background: #f0f3f9;</div><div class=\"line\">  color: blue;          // 所有浏览器</div><div class=\"line\">  color: red\\9;         // IE8 及 以下浏览器</div><div class=\"line\">  *color: green;        // IE7 及 以下浏览器</div><div class=\"line\">  _color: purple;       // IE6 浏览器</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>说明</strong>：</p>\n<ul>\n<li>所有浏览器都能识别: <code>*</code>;</li>\n<li>IE8及以下浏览器都能识别: <code>\\9</code>;</li>\n<li>IE6能识别：<code>_</code>;</li>\n<li>IE6不能识别：<code>!important</code>，其他浏览器都能识别，但是不建议使用<br>所以，所以为了区分i6、ie7和ie8，可以使用上面的顺序来定义属性</li>\n</ul>\n<h2 id=\"常见兼容性问题\"><a href=\"#常见兼容性问题\" class=\"headerlink\" title=\"常见兼容性问题\"></a>常见兼容性问题</h2><h3 id=\"margin和padding\"><a href=\"#margin和padding\" class=\"headerlink\" title=\"margin和padding\"></a>margin和padding</h3><p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大<br>碰到频率：100%<br>解决方法：</p>\n<ul>\n<li>使用 <code>*{margin: 0; padding: 0;}</code>，作用范围大</li>\n<li>对指定的元素使用<code>{margin:0; padding:0;}</code>；如p，h1~h6，input，ul，li，dl，dt，dd等标签，具体情况可以在实际调试中进行修改调整</li>\n</ul>\n<h3 id=\"在IE下双边距bug\"><a href=\"#在IE下双边距bug\" class=\"headerlink\" title=\"在IE下双边距bug\"></a>在IE下双边距bug</h3><p>问题症状：在IE浏览器下，当为 <strong>块级元素添加float，且浮动元素有<code>margin-left</code>或<code>margin-right</code>，那么实际的<code>margin-left和margin-right</code>要比设置的大一倍</strong>;<br>碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）<br>解决方法：</p>\n<ul>\n<li>在浮动元素上添加 <code>display: inline-block</code> 即可；”*”只能被IE识别，对其他的浏览器没有影响</li>\n</ul>\n<h3 id=\"设置一个较小高度的标签-一般小于10px-在IE6、IE7中，实际高度会超出设置的高度值\"><a href=\"#设置一个较小高度的标签-一般小于10px-在IE6、IE7中，实际高度会超出设置的高度值\" class=\"headerlink\" title=\"设置一个较小高度的标签(一般小于10px), 在IE6、IE7中，实际高度会超出设置的高度值\"></a>设置一个较小高度的标签(一般小于10px), 在IE6、IE7中，实际高度会超出设置的高度值</h3><p>问题症状：在IE6，IE7里的高度不受控制，超出自己设置的高度<br>碰到频率：60%<br>解决方法：</p>\n<ul>\n<li>给超出高度的标签设置 <code>overflow: hidden</code></li>\n<li>或者设置行高 <code>line-height</code> 小于你设置的高度<br>备注：这种情况主要出现在我们设置小圆角背景的标签里。出现这个问题的原因是因为 <strong>IE8之前的浏览器不允许元素的高度小于字体的高度</strong></li>\n</ul>\n<h3 id=\"图片默认有边距\"><a href=\"#图片默认有边距\" class=\"headerlink\" title=\"图片默认有边距\"></a>图片默认有边距</h3><p>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的边距，即使使用了 <code>img{margin: 0; padding: 0</code> 也不起作用<br>碰到几率：20%<br>解决方法：使用float属性为 img 布局<br>备注：因为img标签是行内元素，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距，可使用float布局去除这个间距</p>\n<h3 id=\"标签最低高度-min-height-不兼容\"><a href=\"#标签最低高度-min-height-不兼容\" class=\"headerlink\" title=\"标签最低高度 min-height 不兼容\"></a>标签最低高度 min-height 不兼容</h3><p>问题症状：在IE6上，设置min-height和min-width无效，为了达到效果统一，需要对IE6另做处理<br>碰到几率：5%<br>解决方法：<strong>主要利用IE6对<code>!important</code>不识别来做处理</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  min-height: 200px;</div><div class=\"line\">  height: auto !important;   </div><div class=\"line\">  height: 200px;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  说明：<code>height: auto !important</code>  对于现代浏览器，该语句的权重最大，因此，该语句生效，表示标签高度随内容高度而变，但最小高度为200px；因为IE6对 <code>!important</code>不识别，因此，该语句无效，所以后面的<code>height: 200px</code>生效，<strong>而在IE6中，当内容的高度大于容器的设置高度，容器将会被撑开；如果小于容器高度，则为height值</strong></p>\n<h3 id=\"列表li的楼梯Bug\"><a href=\"#列表li的楼梯Bug\" class=\"headerlink\" title=\"列表li的楼梯Bug\"></a>列表li的楼梯Bug</h3><p>问题症状：li在IE6下呈楼梯状的效果，在IE6下的经典bug；当li里面放了一些float的内容标签，但是li本身不浮动，此时在IE上就会有楼梯出现。代码如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">// css</div><div class=\"line\">ul &#123;</div><div class=\"line\">  list-style: none;</div><div class=\"line\">&#125;</div><div class=\"line\">ul li a &#123;</div><div class=\"line\">  display: block;</div><div class=\"line\">  width: 130px;</div><div class=\"line\">  height: 30px;</div><div class=\"line\">  text-align: center;</div><div class=\"line\">  color: #fff;</div><div class=\"line\">  float: left;</div><div class=\"line\">  background: #95CFEF;</div><div class=\"line\">  border: solid 1px #36f;</div><div class=\"line\">  margin: 30px 5px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解决方法：</p>\n<ul>\n<li>在li元素中也加上一个float： <code>ul li {float: left;}</code></li>\n<li>在li元素上应用: <code>ul li {display: inline-block;}</code></li>\n</ul>\n<h3 id=\"居中布局\"><a href=\"#居中布局\" class=\"headerlink\" title=\"居中布局\"></a>居中布局</h3><p>问题描述：当在container中对content块居中布局，常用<code>margin: Npx auto</code>实现，但在IE6下会发现content块没有居中，反而居左对齐了<br>解决方法：在父元素container中使用<code>text-align: center</code>，而在content中使用<code>text-align: left;</code>(防止content中的文本居中)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"区分ie6-7-8\"><a href=\"#区分ie6-7-8\" class=\"headerlink\" title=\"区分ie6_7_8\"></a>区分ie6_7_8</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.ie6_7_8 &#123;</div><div class=\"line\">  width: 300px;</div><div class=\"line\">  padding: 40px;</div><div class=\"line\">  background: #f0f3f9;</div><div class=\"line\">  color: blue;          // 所有浏览器</div><div class=\"line\">  color: red\\9;         // IE8 及 以下浏览器</div><div class=\"line\">  *color: green;        // IE7 及 以下浏览器</div><div class=\"line\">  _color: purple;       // IE6 浏览器</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>说明</strong>：</p>\n<ul>\n<li>所有浏览器都能识别: <code>*</code>;</li>\n<li>IE8及以下浏览器都能识别: <code>\\9</code>;</li>\n<li>IE6能识别：<code>_</code>;</li>\n<li>IE6不能识别：<code>!important</code>，其他浏览器都能识别，但是不建议使用<br>所以，所以为了区分i6、ie7和ie8，可以使用上面的顺序来定义属性</li>\n</ul>\n<h2 id=\"常见兼容性问题\"><a href=\"#常见兼容性问题\" class=\"headerlink\" title=\"常见兼容性问题\"></a>常见兼容性问题</h2><h3 id=\"margin和padding\"><a href=\"#margin和padding\" class=\"headerlink\" title=\"margin和padding\"></a>margin和padding</h3><p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大<br>碰到频率：100%<br>解决方法：</p>\n<ul>\n<li>使用 <code>*{margin: 0; padding: 0;}</code>，作用范围大</li>\n<li>对指定的元素使用<code>{margin:0; padding:0;}</code>；如p，h1~h6，input，ul，li，dl，dt，dd等标签，具体情况可以在实际调试中进行修改调整</li>\n</ul>\n<h3 id=\"在IE下双边距bug\"><a href=\"#在IE下双边距bug\" class=\"headerlink\" title=\"在IE下双边距bug\"></a>在IE下双边距bug</h3><p>问题症状：在IE浏览器下，当为 <strong>块级元素添加float，且浮动元素有<code>margin-left</code>或<code>margin-right</code>，那么实际的<code>margin-left和margin-right</code>要比设置的大一倍</strong>;<br>碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）<br>解决方法：</p>\n<ul>\n<li>在浮动元素上添加 <code>display: inline-block</code> 即可；”*”只能被IE识别，对其他的浏览器没有影响</li>\n</ul>\n<h3 id=\"设置一个较小高度的标签-一般小于10px-在IE6、IE7中，实际高度会超出设置的高度值\"><a href=\"#设置一个较小高度的标签-一般小于10px-在IE6、IE7中，实际高度会超出设置的高度值\" class=\"headerlink\" title=\"设置一个较小高度的标签(一般小于10px), 在IE6、IE7中，实际高度会超出设置的高度值\"></a>设置一个较小高度的标签(一般小于10px), 在IE6、IE7中，实际高度会超出设置的高度值</h3><p>问题症状：在IE6，IE7里的高度不受控制，超出自己设置的高度<br>碰到频率：60%<br>解决方法：</p>\n<ul>\n<li>给超出高度的标签设置 <code>overflow: hidden</code></li>\n<li>或者设置行高 <code>line-height</code> 小于你设置的高度<br>备注：这种情况主要出现在我们设置小圆角背景的标签里。出现这个问题的原因是因为 <strong>IE8之前的浏览器不允许元素的高度小于字体的高度</strong></li>\n</ul>\n<h3 id=\"图片默认有边距\"><a href=\"#图片默认有边距\" class=\"headerlink\" title=\"图片默认有边距\"></a>图片默认有边距</h3><p>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的边距，即使使用了 <code>img{margin: 0; padding: 0</code> 也不起作用<br>碰到几率：20%<br>解决方法：使用float属性为 img 布局<br>备注：因为img标签是行内元素，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距，可使用float布局去除这个间距</p>\n<h3 id=\"标签最低高度-min-height-不兼容\"><a href=\"#标签最低高度-min-height-不兼容\" class=\"headerlink\" title=\"标签最低高度 min-height 不兼容\"></a>标签最低高度 min-height 不兼容</h3><p>问题症状：在IE6上，设置min-height和min-width无效，为了达到效果统一，需要对IE6另做处理<br>碰到几率：5%<br>解决方法：<strong>主要利用IE6对<code>!important</code>不识别来做处理</strong></p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  min-height: 200px;</div><div class=\"line\">  height: auto !important;   </div><div class=\"line\">  height: 200px;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  说明：<code>height: auto !important</code>  对于现代浏览器，该语句的权重最大，因此，该语句生效，表示标签高度随内容高度而变，但最小高度为200px；因为IE6对 <code>!important</code>不识别，因此，该语句无效，所以后面的<code>height: 200px</code>生效，<strong>而在IE6中，当内容的高度大于容器的设置高度，容器将会被撑开；如果小于容器高度，则为height值</strong></p>\n<h3 id=\"列表li的楼梯Bug\"><a href=\"#列表li的楼梯Bug\" class=\"headerlink\" title=\"列表li的楼梯Bug\"></a>列表li的楼梯Bug</h3><p>问题症状：li在IE6下呈楼梯状的效果，在IE6下的经典bug；当li里面放了一些float的内容标签，但是li本身不浮动，此时在IE上就会有楼梯出现。代码如下：</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">// css</div><div class=\"line\">ul &#123;</div><div class=\"line\">  list-style: none;</div><div class=\"line\">&#125;</div><div class=\"line\">ul li a &#123;</div><div class=\"line\">  display: block;</div><div class=\"line\">  width: 130px;</div><div class=\"line\">  height: 30px;</div><div class=\"line\">  text-align: center;</div><div class=\"line\">  color: #fff;</div><div class=\"line\">  float: left;</div><div class=\"line\">  background: #95CFEF;</div><div class=\"line\">  border: solid 1px #36f;</div><div class=\"line\">  margin: 30px 5px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解决方法：</p>\n<ul>\n<li>在li元素中也加上一个float： <code>ul li {float: left;}</code></li>\n<li>在li元素上应用: <code>ul li {display: inline-block;}</code></li>\n</ul>\n<h3 id=\"居中布局\"><a href=\"#居中布局\" class=\"headerlink\" title=\"居中布局\"></a>居中布局</h3><p>问题描述：当在container中对content块居中布局，常用<code>margin: Npx auto</code>实现，但在IE6下会发现content块没有居中，反而居左对齐了<br>解决方法：在父元素container中使用<code>text-align: center</code>，而在content中使用<code>text-align: left;</code>(防止content中的文本居中)</p>\n"},{"title":"前端工程化初探","date":"2017-10-04T01:18:53.000Z","_content":"","source":"_posts/前端工程化初探.md","raw":"---\ntitle: 前端工程化初探\ndate: 2017-10-04 09:18:53\ncategories:\ntags:\n---\n","slug":"前端工程化初探","published":1,"updated":"2017-10-04T01:18:53.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8i7geuh0019ekrirjjiu5wr","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cj8i7gete000pekrip0jbi4xo","category_id":"cj8i7getn000tekri7by6i8oh","_id":"cj8i7geu60011ekriem10030d"}],"PostTag":[{"post_id":"cj8i7gerx0002ekriff2nth2v","tag_id":"cj8i7ges40004ekriukfkrrcu","_id":"cj8i7gesp0009ekri7v1awn3l"},{"post_id":"cj8i7ges00003ekriratrz8am","tag_id":"cj8i7geso0008ekrii5wgmnw1","_id":"cj8i7gesw000eekri3inw55e9"},{"post_id":"cj8i7gesr000bekri93y2mt5i","tag_id":"cj8i7geso0008ekrii5wgmnw1","_id":"cj8i7gesy000gekri30pnxec0"},{"post_id":"cj8i7gesc0005ekri87mk66o6","tag_id":"cj8i7geso0008ekrii5wgmnw1","_id":"cj8i7get5000jekridhsonxh4"},{"post_id":"cj8i7gesx000fekrifolb11nz","tag_id":"cj8i7geso0008ekrii5wgmnw1","_id":"cj8i7get7000lekri4saqae3z"},{"post_id":"cj8i7gesf0006ekrilh0uqeli","tag_id":"cj8i7gesz000hekri78epw3ms","_id":"cj8i7getd000oekridyyke0cn"},{"post_id":"cj8i7gesn0007ekri69aer27i","tag_id":"cj8i7get8000mekrirkgey1f2","_id":"cj8i7getm000sekridwpam6s4"},{"post_id":"cj8i7gesu000dekrigd05qr8s","tag_id":"cj8i7get8000mekrirkgey1f2","_id":"cj8i7gety000xekri03pnvsig"},{"post_id":"cj8i7get6000kekriemvlvr63","tag_id":"cj8i7getu000vekrimdvhfeta","_id":"cj8i7geu60012ekrim6w4rjdq"},{"post_id":"cj8i7geu60013ekrifjh6lef0","tag_id":"cj8i7gesz000hekri78epw3ms","_id":"cj8i7geud0016ekrial5levvo"},{"post_id":"cj8i7geta000nekri0p5a3bkk","tag_id":"cj8i7geu40010ekritntgctco","_id":"cj8i7geuh0018ekriztv969ph"},{"post_id":"cj8i7geue0017ekriv8zc9f4j","tag_id":"cj8i7geu40010ekritntgctco","_id":"cj8i7geul001bekrin3wxlar3"},{"post_id":"cj8i7gete000pekrip0jbi4xo","tag_id":"cj8i7geu40010ekritntgctco","_id":"cj8i7geul001cekrivpz8n8mz"},{"post_id":"cj8i7getj000rekriw3j0dqw7","tag_id":"cj8i7geuk001aekri71vdlrpa","_id":"cj8i7geum001eekri84mu3uam"},{"post_id":"cj8i7geto000uekrik6dy189y","tag_id":"cj8i7geul001dekrijx44g2kz","_id":"cj8i7geup001gekrifhk6jfkm"},{"post_id":"cj8i7getv000wekri21cbfu2s","tag_id":"cj8i7geuo001fekrirrcych6w","_id":"cj8i7geuq001iekrixrfiut9w"},{"post_id":"cj8i7getz000yekrixjuys0yp","tag_id":"cj8i7geu40010ekritntgctco","_id":"cj8i7geur001kekrih8ywwsm2"},{"post_id":"cj8i7geu2000zekrig6s8l1uo","tag_id":"cj8i7geur001jekriddl0mtmy","_id":"cj8i7geut001mekrig455hr3u"},{"post_id":"cj8i7geu90014ekrim9x477b4","tag_id":"cj8i7geur001jekriddl0mtmy","_id":"cj8i7geuu001nekritvqk2x0s"}],"Tag":[{"name":"面试相关","_id":"cj8i7ges40004ekriukfkrrcu"},{"name":"Vue","_id":"cj8i7geso0008ekrii5wgmnw1"},{"name":"Javascript","_id":"cj8i7gesz000hekri78epw3ms"},{"name":"Vue-Router","_id":"cj8i7get8000mekrirkgey1f2"},{"name":"Webpack","_id":"cj8i7getu000vekrimdvhfeta"},{"name":"WEB","_id":"cj8i7geu40010ekritntgctco"},{"name":"leetcode","_id":"cj8i7geuk001aekri71vdlrpa"},{"name":"算法","_id":"cj8i7geul001dekrijx44g2kz"},{"name":"个人项目","_id":"cj8i7geuo001fekrirrcych6w"},{"name":"性能优化","_id":"cj8i7geur001jekriddl0mtmy"}]}}